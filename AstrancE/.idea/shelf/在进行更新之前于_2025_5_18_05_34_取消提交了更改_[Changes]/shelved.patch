Index: modules/axfs/src/dev.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use axdriver::prelude::*;\n\nconst BLOCK_SIZE: usize = 512;\n\n/// A disk device with a cursor.\npub struct Disk {\n    block_id: u64,\n    offset: usize,\n    dev: AxBlockDevice,\n}\n\nimpl Disk {\n    /// Create a new disk.\n    pub fn new(dev: AxBlockDevice) -> Self {\n        assert_eq!(BLOCK_SIZE, dev.block_size());\n        Self {\n            block_id: 0,\n            offset: 0,\n            dev,\n        }\n    }\n\n    /// Get the size of the disk.\n    pub fn size(&self) -> u64 {\n        self.dev.num_blocks() * BLOCK_SIZE as u64\n    }\n\n    /// Get the position of the cursor.\n    pub fn position(&self) -> u64 {\n        self.block_id * BLOCK_SIZE as u64 + self.offset as u64\n    }\n\n    /// Set the position of the cursor.\n    pub fn set_position(&mut self, pos: u64) {\n        self.block_id = pos / BLOCK_SIZE as u64;\n        self.offset = pos as usize % BLOCK_SIZE;\n    }\n\n    /// Read within one block, returns the number of bytes read.\n    pub fn read_one(&mut self, buf: &mut [u8]) -> DevResult<usize> {\n        let read_size = if self.offset == 0 && buf.len() >= BLOCK_SIZE {\n            // whole block\n            let mut data = [0u8; BLOCK_SIZE];\n            self.dev.read_block(self.block_id, &mut data)?;\n            buf[0..BLOCK_SIZE].copy_from_slice(&data);\n            // self.dev\n            //     .read_block(self.block_id, &mut buf[0..BLOCK_SIZE])?;\n            self.block_id += 1;\n            BLOCK_SIZE\n        } else {\n            // partial block\n            let mut data = [0u8; BLOCK_SIZE];\n            let start = self.offset;\n            let count = buf.len().min(BLOCK_SIZE - self.offset);\n\n            self.dev.read_block(self.block_id, &mut data)?;\n            buf[..count].copy_from_slice(&data[start..start + count]);\n\n            self.offset += count;\n            if self.offset >= BLOCK_SIZE {\n                self.block_id += 1;\n                self.offset -= BLOCK_SIZE;\n            }\n            count\n        };\n        Ok(read_size)\n    }\n\n    /// Write within one block, returns the number of bytes written.\n    pub fn write_one(&mut self, buf: &[u8]) -> DevResult<usize> {\n        let write_size = if self.offset == 0 && buf.len() >= BLOCK_SIZE {\n            // whole block\n            self.dev.write_block(self.block_id, &buf[0..BLOCK_SIZE])?;\n            self.block_id += 1;\n            BLOCK_SIZE\n        } else {\n            // partial block\n            let mut data = [0u8; BLOCK_SIZE];\n            let start = self.offset;\n            let count = buf.len().min(BLOCK_SIZE - self.offset);\n\n            self.dev.read_block(self.block_id, &mut data)?;\n            data[start..start + count].copy_from_slice(&buf[..count]);\n            self.dev.write_block(self.block_id, &data)?;\n\n            self.offset += count;\n            if self.offset >= BLOCK_SIZE {\n                self.block_id += 1;\n                self.offset -= BLOCK_SIZE;\n            }\n            count\n        };\n        Ok(write_size)\n    }\n\n    /// Read a single block starting from the specified offset.\n    #[allow(unused)]\n    pub fn read_offset(&mut self, offset: usize) -> [u8; BLOCK_SIZE] {\n        let block_id = offset / BLOCK_SIZE;\n        let mut block_data = [0u8; BLOCK_SIZE];\n        self.dev\n            .read_block(block_id as u64, &mut block_data)\n            .unwrap();\n        block_data\n    }\n\n    /// Write single block starting from the specified offset.\n    #[allow(unused)]\n    pub fn write_offset(&mut self, offset: usize, buf: &[u8]) -> DevResult<usize> {\n        assert!(\n            buf.len() == BLOCK_SIZE,\n            \"Buffer length must be equal to BLOCK_SIZE\"\n        );\n        assert!(offset % BLOCK_SIZE == 0);\n        let block_id = offset / BLOCK_SIZE;\n        self.dev.write_block(block_id as u64, buf).unwrap();\n        Ok(buf.len())\n    }\n}\n\nunsafe impl Send for Disk {}\nunsafe impl Sync for Disk {}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/modules/axfs/src/dev.rs b/modules/axfs/src/dev.rs
--- a/modules/axfs/src/dev.rs	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/modules/axfs/src/dev.rs	(date 1747546107310)
@@ -1,22 +1,24 @@
 use axdriver::prelude::*;
-
+use axfs_vfs::{VfsNodeAttr, VfsNodeOps, VfsResult};
+use axdriver_block::ramdisk::RamDisk;
 const BLOCK_SIZE: usize = 512;
-
 /// A disk device with a cursor.
 pub struct Disk {
     block_id: u64,
     offset: usize,
-    dev: AxBlockDevice,
+    dev: AxBlockDevice, //Ramdisk
+    dev_t: (u8, u8),
 }
 
 impl Disk {
     /// Create a new disk.
-    pub fn new(dev: AxBlockDevice) -> Self {
+    pub fn new(dev:AxBlockDevice, major: u8, minor: u8) -> Self {
         assert_eq!(BLOCK_SIZE, dev.block_size());
         Self {
             block_id: 0,
             offset: 0,
             dev,
+            dev_t: (major, minor),
         }
     }
 
@@ -24,6 +26,19 @@
     pub fn size(&self) -> u64 {
         self.dev.num_blocks() * BLOCK_SIZE as u64
     }
+    
+    // ///Clone disk for filesystem
+    // pub fn get_dev(&self) -> AxBlockDevice {
+    //     let dev = self.dev.deep_clone().expect("Clone failed");
+    // 
+    //     // 尝试从 trait object 恢复为具体类型
+    //     dev.as_any()
+    //         .downcast_ref::<AxBlockDevice>()
+    //         .expect("Not a RamDisk")
+    //         .clone()
+    // }
+    ///Get dev index
+    pub fn dev_t(&self) -> (u8, u8) {self.dev_t}
 
     /// Get the position of the cursor.
     pub fn position(&self) -> u64 {
@@ -118,5 +133,27 @@
     }
 }
 
+// impl VfsNodeOps for Disk{
+//     fn get_attr(&self) -> VfsResult<VfsNodeAttr> {
+//         //TODO:dev num
+//         Ok(VfsNodeAttr::new_file(4096, 1))
+//     }
+//     fn remove(&self, _path: &str) -> VfsResult {
+//         todo!()
+//     }
+// 
+// }
+// 
+// impl Clone for Disk {
+//     fn clone(&self) -> Self {
+//         Disk {
+//             block_id: self.block_id,
+//             offset: self.offset,
+//             dev: self.get_dev(), // 确保 dev 实现了 Clone
+//             dev_t: self.dev_t,
+//         }
+//     }
+// }
+
 unsafe impl Send for Disk {}
 unsafe impl Sync for Disk {}
Index: modules/axfs/src/root.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//! Root directory of the filesystem\n//!\n//! TODO: it doesn't work very well if the mount points have containment relationships.\n\nuse alloc::{string::String, sync::Arc, vec::Vec};\nuse axerrno::{AxError, AxResult, ax_err};\nuse axfs_vfs::{VfsNodeAttr, VfsNodeOps, VfsNodeRef, VfsNodeType, VfsOps, VfsResult};\nuse axio::Read;\nuse axns::{ResArc, def_resource};\nuse axsync::Mutex;\nuse lazyinit::LazyInit;\nuse spin::RwLock;\n\nuse crate::{\n    api::{self, FileType},\n    dev::Disk,\n    fs::{self},\n    mounts,\n};\n\ndef_resource! {\n    pub static CURRENT_DIR_PATH: ResArc<Mutex<String>> = ResArc::new();\n    pub static CURRENT_DIR: ResArc<Mutex<VfsNodeRef>> = ResArc::new();\n}\n\nimpl CURRENT_DIR_PATH {\n    /// Return a copy of the inner path.\n    pub fn copy_inner(&self) -> Mutex<String> {\n        Mutex::new(self.lock().clone())\n    }\n}\n\nimpl CURRENT_DIR {\n    /// Return a copy of the CURRENT_DIR_NODE.\n    pub fn copy_inner(&self) -> Mutex<VfsNodeRef> {\n        Mutex::new(self.lock().clone())\n    }\n}\n\nstruct MountPoint {\n    path: &'static str,\n    fs: Arc<dyn VfsOps>,\n}\n\nstruct RootDirectory {\n    main_fs: Arc<dyn VfsOps>,\n    mounts: RwLock<Vec<MountPoint>>,\n}\n\npub static ROOT_DIR: LazyInit<Arc<RootDirectory>> = LazyInit::new();\n\nimpl MountPoint {\n    pub fn new(path: &'static str, fs: Arc<dyn VfsOps>) -> Self {\n        Self { path, fs }\n    }\n}\n\nimpl Drop for MountPoint {\n    fn drop(&mut self) {\n        self.fs.umount().ok();\n    }\n}\n\nimpl RootDirectory {\n    pub const fn new(main_fs: Arc<dyn VfsOps>) -> Self {\n        Self {\n            main_fs,\n            mounts: RwLock::new(Vec::new()),\n        }\n    }\n\n    pub fn mount(&self, path: &'static str, fs: Arc<dyn VfsOps>) -> AxResult {\n        if path == \"/\" {\n            return ax_err!(InvalidInput, \"cannot mount root filesystem\");\n        }\n        if !path.starts_with('/') {\n            return ax_err!(InvalidInput, \"mount path must start with '/'\");\n        }\n        if self.mounts.read().iter().any(|mp| mp.path == path) {\n            return ax_err!(InvalidInput, \"mount point already exists\");\n        }\n        // create the mount point in the main filesystem if it does not exist\n        self.main_fs.root_dir().create(path, FileType::Dir)?;\n        fs.mount(path, self.main_fs.root_dir().lookup(path)?)?;\n        self.mounts.write().push(MountPoint::new(path, fs));\n        Ok(())\n    }\n\n    pub fn _umount(&self, path: &str) {\n        self.mounts.write().retain(|mp| mp.path != path);\n    }\n\n    pub fn contains(&self, path: &str) -> bool {\n        self.mounts.read().iter().any(|mp| mp.path == path)\n    }\n\n    fn lookup_mounted_fs<F, T>(&self, path: &str, f: F) -> AxResult<T>\n    where\n        F: FnOnce(Arc<dyn VfsOps>, &str) -> AxResult<T>,\n    {\n        debug!(\"lookup at root: {}\", path);\n        let path = path.trim_matches('/');\n        if let Some(rest) = path.strip_prefix(\"./\") {\n            return self.lookup_mounted_fs(rest, f);\n        }\n\n        let mut idx = 0;\n        let mut max_len = 0;\n\n        // Find the filesystem that has the longest mounted path match\n        // TODO: more efficient, e.g. trie\n        for (i, mp) in self.mounts.read().iter().enumerate() {\n            // skip the first '/'\n            if path.starts_with(&mp.path[1..]) && mp.path.len() - 1 > max_len {\n                max_len = mp.path.len() - 1;\n                idx = i;\n            }\n        }\n\n        if max_len == 0 {\n            f(self.main_fs.clone(), path) // not matched any mount point\n        } else {\n            f(self.mounts.read()[idx].fs.clone(), &path[max_len..]) // matched at `idx`\n        }\n    }\n}\n\nimpl VfsNodeOps for RootDirectory {\n    axfs_vfs::impl_vfs_dir_default! {}\n\n    fn get_attr(&self) -> VfsResult<VfsNodeAttr> {\n        self.main_fs.root_dir().get_attr()\n    }\n\n    fn lookup(self: Arc<Self>, path: &str) -> VfsResult<VfsNodeRef> {\n        self.lookup_mounted_fs(path, |fs, rest_path| fs.root_dir().lookup(rest_path))\n    }\n\n    fn create(&self, path: &str, ty: VfsNodeType) -> VfsResult {\n        self.lookup_mounted_fs(path, |fs, rest_path| {\n            if rest_path.is_empty() {\n                Ok(()) // already exists\n            } else {\n                fs.root_dir().create(rest_path, ty)\n            }\n        })\n    }\n\n    fn remove(&self, path: &str) -> VfsResult {\n        self.lookup_mounted_fs(path, |fs, rest_path| {\n            if rest_path.is_empty() {\n                ax_err!(PermissionDenied) // cannot remove mount points\n            } else {\n                fs.root_dir().remove(rest_path)\n            }\n        })\n    }\n\n    fn rename(&self, src_path: &str, dst_path: &str) -> VfsResult {\n        self.lookup_mounted_fs(src_path, |fs, rest_path| {\n            if rest_path.is_empty() {\n                ax_err!(PermissionDenied) // cannot rename mount points\n            } else {\n                fs.root_dir().rename(rest_path, dst_path)\n            }\n        })\n    }\n}\n\npub(crate) fn init_rootfs(disk: crate::dev::Disk) {\n    cfg_if::cfg_if! {\n        if #[cfg(feature = \"myfs\")] { // override the default filesystem\n            let main_fs = fs::myfs::new_myfs(disk);\n        } else if #[cfg(feature = \"lwext4_rs\")] {\n            static EXT4_FS: LazyInit<Arc<fs::lwext4_rust::Ext4FileSystem<Disk>>> = LazyInit::new();\n            EXT4_FS.init_once(Arc::new(fs::lwext4_rust::Ext4FileSystem::new(disk)));\n            let main_fs = EXT4_FS.clone();\n        } else if #[cfg(feature = \"fatfs\")] {\n            static FAT_FS: LazyInit<Arc<fs::fatfs::FatFileSystem>> = LazyInit::new();\n            FAT_FS.init_once(Arc::new(fs::fatfs::FatFileSystem::new(disk)));\n            FAT_FS.init();\n            let main_fs = FAT_FS.clone();\n        }\n    }\n\n    let root_dir = RootDirectory::new(main_fs);\n\n    #[cfg(feature = \"devfs\")]\n    root_dir\n        .mount(\"/dev\", mounts::devfs())\n        .expect(\"failed to mount devfs at /dev\");\n\n    #[cfg(feature = \"ramfs\")]\n    root_dir\n        .mount(\"/tmp\", mounts::ramfs())\n        .expect(\"failed to mount ramfs at /tmp\");\n\n    // Mount another ramfs as procfs\n    #[cfg(feature = \"procfs\")]\n    root_dir // should not fail\n        .mount(\"/proc\", mounts::procfs().unwrap())\n        .expect(\"fail to mount procfs at /proc\");\n\n    // Mount another ramfs as sysfs\n    #[cfg(feature = \"sysfs\")]\n    root_dir // should not fail\n        .mount(\"/sys\", mounts::sysfs().unwrap())\n        .expect(\"fail to mount sysfs at /sys\");\n\n    ROOT_DIR.init_once(Arc::new(root_dir));\n    info!(\"rootfs initialized\");\n    CURRENT_DIR.init_new(Mutex::new(ROOT_DIR.clone()));\n    info!(\"test\");\n    CURRENT_DIR_PATH.init_new(Mutex::new(\"/\".into()));\n}\n\nfn parent_node_of(dir: Option<&VfsNodeRef>, path: &str) -> VfsNodeRef {\n    if path.starts_with('/') {\n        ROOT_DIR.clone()\n    } else {\n        dir.cloned().unwrap_or_else(|| CURRENT_DIR.lock().clone())\n    }\n}\n\npub(crate) fn absolute_path(path: &str) -> AxResult<String> {\n    if path.starts_with('/') {\n        Ok(axfs_vfs::path::canonicalize(path))\n    } else {\n        let path = CURRENT_DIR_PATH.lock().clone() + path;\n        Ok(axfs_vfs::path::canonicalize(&path))\n    }\n}\n\npub(crate) fn lookup(dir: Option<&VfsNodeRef>, path: &str) -> AxResult<VfsNodeRef> {\n    if path.is_empty() {\n        return ax_err!(NotFound);\n    }\n    let node = parent_node_of(dir, path).lookup(path)?;\n    if path.ends_with('/') && !node.get_attr()?.is_dir() {\n        ax_err!(NotADirectory)\n    } else {\n        Ok(node)\n    }\n}\n\npub(crate) fn create_file(dir: Option<&VfsNodeRef>, path: &str) -> AxResult<VfsNodeRef> {\n    if path.is_empty() {\n        return ax_err!(NotFound);\n    } else if path.ends_with('/') {\n        return ax_err!(NotADirectory);\n    }\n    let parent = parent_node_of(dir, path);\n    parent.create(path, VfsNodeType::File)?;\n    parent.lookup(path)\n}\n\npub(crate) fn create_dir(dir: Option<&VfsNodeRef>, path: &str) -> AxResult {\n    match lookup(dir, path) {\n        Ok(_) => ax_err!(AlreadyExists),\n        Err(AxError::NotFound) => parent_node_of(dir, path).create(path, VfsNodeType::Dir),\n        Err(e) => Err(e),\n    }\n}\n\npub(crate) fn remove_file(dir: Option<&VfsNodeRef>, path: &str) -> AxResult {\n    let node = lookup(dir, path)?;\n    let attr = node.get_attr()?;\n    if attr.is_dir() {\n        ax_err!(IsADirectory)\n    } else if !attr.perm().owner_writable() {\n        ax_err!(PermissionDenied)\n    } else {\n        parent_node_of(dir, path).remove(path)\n    }\n}\n\npub(crate) fn remove_dir(dir: Option<&VfsNodeRef>, path: &str) -> AxResult {\n    if path.is_empty() {\n        return ax_err!(NotFound);\n    }\n    let path_check = path.trim_matches('/');\n    if path_check.is_empty() {\n        return ax_err!(DirectoryNotEmpty); // rm -d '/'\n    } else if path_check == \".\"\n        || path_check == \"..\"\n        || path_check.ends_with(\"/.\")\n        || path_check.ends_with(\"/..\")\n    {\n        return ax_err!(InvalidInput);\n    }\n    if ROOT_DIR.contains(&absolute_path(path)?) {\n        return ax_err!(PermissionDenied);\n    }\n\n    let node = lookup(dir, path)?;\n    let attr = node.get_attr()?;\n    if !attr.is_dir() {\n        ax_err!(NotADirectory)\n    } else if !attr.perm().owner_writable() {\n        ax_err!(PermissionDenied)\n    } else {\n        parent_node_of(dir, path).remove(path)\n    }\n}\n\npub(crate) fn current_dir() -> AxResult<String> {\n    Ok(CURRENT_DIR_PATH.lock().clone())\n}\n\npub(crate) fn set_current_dir(path: &str) -> AxResult {\n    let mut abs_path = absolute_path(path)?;\n    if !abs_path.ends_with('/') {\n        abs_path += \"/\";\n    }\n    if abs_path == \"/\" {\n        *CURRENT_DIR.lock() = ROOT_DIR.clone();\n        *CURRENT_DIR_PATH.lock() = \"/\".into();\n        return Ok(());\n    }\n\n    let node = lookup(None, &abs_path)?;\n    let attr = node.get_attr()?;\n    if !attr.is_dir() {\n        ax_err!(NotADirectory)\n    } else if !attr.perm().owner_executable() {\n        ax_err!(PermissionDenied)\n    } else {\n        *CURRENT_DIR.lock() = node;\n        *CURRENT_DIR_PATH.lock() = abs_path;\n        Ok(())\n    }\n}\n\npub(crate) fn rename(old: &str, new: &str) -> AxResult {\n    if parent_node_of(None, new).lookup(new).is_ok() {\n        warn!(\"dst file already exist, now remove it\");\n        remove_file(None, new)?;\n    }\n    parent_node_of(None, old).rename(old, new)\n}\n\npub fn mount(source: &'static str, target: &'static str, flags: usize) -> AxResult {\n    let img = crate::api::File::open(source)?;\n    warn!(\"mounting {} to {}\", source, target);\n    let fs = fs::lwext4_rust::Ext4FileSystem::new(img);\n\n    ROOT_DIR.mount(&target, Arc::new(fs));\n    Ok(())\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/modules/axfs/src/root.rs b/modules/axfs/src/root.rs
--- a/modules/axfs/src/root.rs	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/modules/axfs/src/root.rs	(date 1747546008238)
@@ -10,13 +10,18 @@
 use axsync::Mutex;
 use lazyinit::LazyInit;
 use spin::RwLock;
-
+use axdriver::AxBlockDevice;
+use axfs_devfs::DeviceFileSystem;
 use crate::{
     api::{self, FileType},
     dev::Disk,
     fs::{self},
     mounts,
 };
+use crate::fs::fatfs::FatFileSystem;
+use crate::fs::lwext4_rust::Ext4FileSystem;
+// use crate::devfile::DeviceNode;
+use crate::mounts::devfs;
 
 def_resource! {
     pub static CURRENT_DIR_PATH: ResArc<Mutex<String>> = ResArc::new();
@@ -42,7 +47,7 @@
     fs: Arc<dyn VfsOps>,
 }
 
-struct RootDirectory {
+struct RootDirectory { 
     main_fs: Arc<dyn VfsOps>,
     mounts: RwLock<Vec<MountPoint>>,
 }
@@ -123,6 +128,12 @@
             f(self.mounts.read()[idx].fs.clone(), &path[max_len..]) // matched at `idx`
         }
     }
+
+    fn root_dir() -> Arc<RootDirectory> {
+        ROOT_DIR.get()
+            .expect("ROOT_DIR not initialized")
+            .clone()
+    }
 }
 
 impl VfsNodeOps for RootDirectory {
@@ -166,8 +177,10 @@
         })
     }
 }
-
-pub(crate) fn init_rootfs(disk: crate::dev::Disk) {
+//disk: crate::dev::Disk
+pub(crate) fn init_rootfs(disk: crate::dev::Disk){
+    // let demo = axfs_devfs::blkdev::Blkdev::new(dev,8,0);
+    // disk = Disk::new(demo.get_dev());
     cfg_if::cfg_if! {
         if #[cfg(feature = "myfs")] { // override the default filesystem
             let main_fs = fs::myfs::new_myfs(disk);
@@ -175,6 +188,7 @@
             static EXT4_FS: LazyInit<Arc<fs::lwext4_rust::Ext4FileSystem<Disk>>> = LazyInit::new();
             EXT4_FS.init_once(Arc::new(fs::lwext4_rust::Ext4FileSystem::new(disk)));
             let main_fs = EXT4_FS.clone();
+            // let dev_fs =  EXT4_FS.clone();
         } else if #[cfg(feature = "fatfs")] {
             static FAT_FS: LazyInit<Arc<fs::fatfs::FatFileSystem>> = LazyInit::new();
             FAT_FS.init_once(Arc::new(fs::fatfs::FatFileSystem::new(disk)));
@@ -189,7 +203,6 @@
     root_dir
         .mount("/dev", mounts::devfs())
         .expect("failed to mount devfs at /dev");
-
     #[cfg(feature = "ramfs")]
     root_dir
         .mount("/tmp", mounts::ramfs())
@@ -206,7 +219,7 @@
     root_dir // should not fail
         .mount("/sys", mounts::sysfs().unwrap())
         .expect("fail to mount sysfs at /sys");
-
+    
     ROOT_DIR.init_once(Arc::new(root_dir));
     info!("rootfs initialized");
     CURRENT_DIR.init_new(Mutex::new(ROOT_DIR.clone()));
@@ -339,11 +352,62 @@
     parent_node_of(None, old).rename(old, new)
 }
 
-pub fn mount(source: &'static str, target: &'static str, flags: usize) -> AxResult {
-    let img = crate::api::File::open(source)?;
-    warn!("mounting {} to {}", source, target);
-    let fs = fs::lwext4_rust::Ext4FileSystem::new(img);
+// pub fn mount(source: &'static str, target: &'static str, flags: usize) -> AxResult {
+//     let img = crate::api::File::open(source)?;
+//     warn!("mounting {} to {}", source, target);
+//     let fs = fs::lwext4_rust::Ext4FileSystem::new(img);
+// 
+//     ROOT_DIR.mount(&target, Arc::new(fs));
+//     Ok(())
+// }
+
+// pub fn mount_dev(_path: &str, mnt: &str, fstype: &str) -> AxResult
+// {
+//     //TODO:cheack _path availble
+//     if _path.is_empty() || !_path.starts_with("/dev/") {
+//         return ax_err!(NotFound);
+//     }
+// 
+//     if !mnt.starts_with('/') || mnt.len() < 2 {
+//         return ax_err!(InvalidInput);
+//     }
+//     //TODO:fix lookup the mounted fs
+//     let root = ROOT_DIR.clone();
+//     let devfs = lookup_mounted_fs(root,"/dev");
+//     let dev_path = _path.strip_prefix("/dev/").ok_or(AxError::NotFound)?;
+//     let dev = devfs.root_dir().lookup(dev_path)?;
+//     let disk = Disk::new(dev.get_dev());
+// 
+//     let fs:Arc<dyn VfsOps>=match fstype {
+//         "ext4" => Arc::new(Ext4FileSystem::new(disk)),
+//         "vfat" => Arc::new(FatFileSystem::new(disk)),
+//         _ => return ax_err!(UnsupportedFs),
+//     };
+//     //TODO:cheack mnt availble
+//     ROOT_DIR.mount(mnt, fs)?;
+//     Ok(())
+// }
+// pub fn umount_dev(_path: &str) -> AxResult
+// {
+//     //TODO:check _path and drop the mounted fs
+//     ROOT_DIR._umount(_path);
+//     Ok(())
+// }
 
-    ROOT_DIR.mount(&target, Arc::new(fs));
-    Ok(())
-}
+// fn mount_device(dev_path: &str, mount_path: &str, fstype: &str) -> Result<()> {
+//     let root  = ROOT_DIR.clone();
+//     let dev_node = root.lookup(dev_path)?;
+//     let dev_file = dev_node.clone();
+// 
+//     let disk = dev_file.inner.lock().clone(); // 需要 Disk 实现 Clone，或重新构造
+// 
+//     let fs: Arc<dyn VfsOps> = match fstype {
+//         "ext4" => Arc::new(Ext4FileSystem::new(disk)),
+//         // 其他文件系统……
+//         _ => return Err(err_invalid()),
+//     };
+//     
+//     ROOT_DIR.mount(mount_path, fs)?;
+//     Ok(())
+// }
+
Index: modules/axfs/src/lib.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//! [ArceOS](https://github.com/arceos-org/arceos) filesystem module.\n//!\n//! It provides unified filesystem operations for various filesystems.\n//!\n//! # Cargo Features\n//!\n//! - `fatfs`: Use [FAT] as the main filesystem and mount it on `/`. This feature\n//!    is **enabled** by default.\n//! - `devfs`: Mount [`axfs_devfs::DeviceFileSystem`] on `/dev`. This feature is\n//!    **enabled** by default.\n//! - `ramfs`: Mount [`axfs_ramfs::RamFileSystem`] on `/tmp`. This feature is\n//!    **enabled** by default.\n//! - `myfs`: Allow users to define their custom filesystems to override the\n//!    default. In this case, [`MyFileSystemIf`] is required to be implemented\n//!    to create and initialize other filesystems. This feature is **disabled** by\n//!    by default, but it will override other filesystem selection features if\n//!    both are enabled.\n//!\n//! [FAT]: https://en.wikipedia.org/wiki/File_Allocation_Table\n//! [`MyFileSystemIf`]: fops::MyFileSystemIf\n\n#![cfg_attr(all(not(test), not(doc)), no_std)]\n#![feature(doc_auto_cfg)]\n\n#[macro_use]\nextern crate log;\nextern crate alloc;\n\nmod dev;\nmod fs;\nmod mounts;\nmod root;\n\npub mod api;\npub mod fops;\npub use root::{CURRENT_DIR, CURRENT_DIR_PATH, mount};\n\nuse axdriver::{AxDeviceContainer, prelude::*};\n\n/// Initializes filesystems by block devices.\npub fn init_filesystems(mut blk_devs: AxDeviceContainer<AxBlockDevice>) {\n    info!(\"Initialize filesystems...\");\n\n    let dev = blk_devs.take_one().expect(\"No block device found!\");\n    info!(\"  use block device 0: {:?}\", dev.device_name());\n    self::root::init_rootfs(self::dev::Disk::new(dev));\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/modules/axfs/src/lib.rs b/modules/axfs/src/lib.rs
--- a/modules/axfs/src/lib.rs	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/modules/axfs/src/lib.rs	(date 1747546037444)
@@ -25,23 +25,31 @@
 #[macro_use]
 extern crate log;
 extern crate alloc;
-
+use alloc::sync::Arc;
 mod dev;
 mod fs;
 mod mounts;
 mod root;
-
+mod blkdev;
 pub mod api;
 pub mod fops;
-pub use root::{CURRENT_DIR, CURRENT_DIR_PATH, mount};
+pub use root::{CURRENT_DIR, CURRENT_DIR_PATH};
 
 use axdriver::{AxDeviceContainer, prelude::*};
+use axfs_vfs::{VfsNodeOps, VfsOps};
+use crate::dev::Disk;
 
 /// Initializes filesystems by block devices.
 pub fn init_filesystems(mut blk_devs: AxDeviceContainer<AxBlockDevice>) {
     info!("Initialize filesystems...");
-
     let dev = blk_devs.take_one().expect("No block device found!");
     info!("  use block device 0: {:?}", dev.device_name());
-    self::root::init_rootfs(self::dev::Disk::new(dev));
+    // root::init_rootfs(self::dev::Disk::new(dev));
+    // let disk = Disk::new(dev,1,0);
+    // let devfs = mounts::devfs();
+    // devfs.add("ram1",Arc::new(disk.clone()));
+    // let node = devfs.root_dir().lookup("ram1").unwrap();
+    //let disk = Disk::new(node.get_dev(),1,0);
+    root::init_rootfs(Disk::new(dev,1,0));
+    info!("Initialize device filesystems...");
 }
Index: modules/axfs/src/mounts.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use alloc::sync::Arc;\nuse axfs_vfs::{VfsNodeType, VfsOps, VfsResult};\n\nuse crate::fs;\n\n#[cfg(feature = \"devfs\")]\npub(crate) fn devfs() -> Arc<fs::devfs::DeviceFileSystem> {\n    let null = fs::devfs::NullDev;\n    let zero = fs::devfs::ZeroDev;\n    let bar = fs::devfs::ZeroDev;\n    let devfs = fs::devfs::DeviceFileSystem::new();\n    let foo_dir = devfs.mkdir(\"foo\");\n    devfs.add(\"null\", Arc::new(null));\n    devfs.add(\"zero\", Arc::new(zero));\n    foo_dir.add(\"bar\", Arc::new(bar));\n    Arc::new(devfs)\n}\n\n#[cfg(feature = \"ramfs\")]\npub(crate) fn ramfs() -> Arc<fs::ramfs::RamFileSystem> {\n    Arc::new(fs::ramfs::RamFileSystem::new())\n}\n\n#[cfg(feature = \"procfs\")]\npub(crate) fn procfs() -> VfsResult<Arc<fs::ramfs::RamFileSystem>> {\n    let procfs = fs::ramfs::RamFileSystem::new();\n    let proc_root = procfs.root_dir();\n\n    // Create /proc/sys/net/core/somaxconn\n    proc_root.create(\"sys\", VfsNodeType::Dir)?;\n    proc_root.create(\"sys/net\", VfsNodeType::Dir)?;\n    proc_root.create(\"sys/net/core\", VfsNodeType::Dir)?;\n    proc_root.create(\"sys/net/core/somaxconn\", VfsNodeType::File)?;\n    let file_somaxconn = proc_root.clone().lookup(\"./sys/net/core/somaxconn\")?;\n    file_somaxconn.write_at(0, b\"4096\\n\")?;\n\n    // Create /proc/sys/vm/overcommit_memory\n    proc_root.create(\"sys/vm\", VfsNodeType::Dir)?;\n    proc_root.create(\"sys/vm/overcommit_memory\", VfsNodeType::File)?;\n    let file_over = proc_root.clone().lookup(\"./sys/vm/overcommit_memory\")?;\n    file_over.write_at(0, b\"0\\n\")?;\n\n    // Create /proc/self/stat\n    proc_root.create(\"self\", VfsNodeType::Dir)?;\n    proc_root.create(\"self/stat\", VfsNodeType::File)?;\n\n    Ok(Arc::new(procfs))\n}\n\n#[cfg(feature = \"sysfs\")]\npub(crate) fn sysfs() -> VfsResult<Arc<fs::ramfs::RamFileSystem>> {\n    let sysfs = fs::ramfs::RamFileSystem::new();\n    let sys_root = sysfs.root_dir();\n\n    // Create /sys/kernel/mm/transparent_hugepage/enabled\n    sys_root.create(\"kernel\", VfsNodeType::Dir)?;\n    sys_root.create(\"kernel/mm\", VfsNodeType::Dir)?;\n    sys_root.create(\"kernel/mm/transparent_hugepage\", VfsNodeType::Dir)?;\n    sys_root.create(\"kernel/mm/transparent_hugepage/enabled\", VfsNodeType::File)?;\n    let file_hp = sys_root\n        .clone()\n        .lookup(\"./kernel/mm/transparent_hugepage/enabled\")?;\n    file_hp.write_at(0, b\"always [madvise] never\\n\")?;\n\n    // Create /sys/devices/system/clocksource/clocksource0/current_clocksource\n    sys_root.create(\"devices\", VfsNodeType::Dir)?;\n    sys_root.create(\"devices/system\", VfsNodeType::Dir)?;\n    sys_root.create(\"devices/system/clocksource\", VfsNodeType::Dir)?;\n    sys_root.create(\"devices/system/clocksource/clocksource0\", VfsNodeType::Dir)?;\n    sys_root.create(\n        \"devices/system/clocksource/clocksource0/current_clocksource\",\n        VfsNodeType::File,\n    )?;\n    let file_cc = sys_root\n        .clone()\n        .lookup(\"devices/system/clocksource/clocksource0/current_clocksource\")?;\n    file_cc.write_at(0, b\"tsc\\n\")?;\n\n    Ok(Arc::new(sysfs))\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/modules/axfs/src/mounts.rs b/modules/axfs/src/mounts.rs
--- a/modules/axfs/src/mounts.rs	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/modules/axfs/src/mounts.rs	(date 1747157435099)
@@ -1,18 +1,31 @@
 use alloc::sync::Arc;
 use axfs_vfs::{VfsNodeType, VfsOps, VfsResult};
-
-use crate::fs;
+// use devfile::{DeviceNode,DiskFile};
+use crate::{fs};
+use crate::dev::Disk;
 
 #[cfg(feature = "devfs")]
 pub(crate) fn devfs() -> Arc<fs::devfs::DeviceFileSystem> {
-    let null = fs::devfs::NullDev;
-    let zero = fs::devfs::ZeroDev;
-    let bar = fs::devfs::ZeroDev;
+    // let null = fs::devfs::NullDev;
+    // let zero = fs::devfs::ZeroDev;
+    // let bar = fs::devfs::ZeroDev;
+    let null = Arc::new(fs::devfs::NullDev);
+    let zero = Arc::new(fs::devfs::ZeroDev);
+    let bar = Arc::new(fs::devfs::ZeroDev);
+    
     let devfs = fs::devfs::DeviceFileSystem::new();
-    let foo_dir = devfs.mkdir("foo");
-    devfs.add("null", Arc::new(null));
-    devfs.add("zero", Arc::new(zero));
-    foo_dir.add("bar", Arc::new(bar));
+    // let sda1_dir = devfs.mkdir("sda1");
+    
+    // devfs.add("null", Arc::new(null));
+    // devfs.add("zero", Arc::new(zero));
+    // foo_dir.add("bar", Arc::new(bar));
+    devfs.add("null", null.clone());
+    devfs.add("zero", zero.clone());
+    devfs.add("sda1", bar.clone());
+    // devfs.register_device_by_name("sda1",8,0,fs).expect("No Device");
+    // devfs.register_device(1, 3, null);
+    // devfs.register_device(1, 5, zero);
+    // devfs.register_device(1, 0, bar);
     Arc::new(devfs)
 }
 
Index: Cargo.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[workspace]\nresolver = \"2\"\n\nmembers = [\n  \"modules/*\",\n  #\"crates/*\",\n\n  \"api/axfeat\",\n  \"api/arceos_api\",\n  \"api/arceos_posix_api\",\n\n  \"ulib/axstd\",\n  \"ulib/axlibc\",\n\n  \"examples/helloworld\",\n  \"examples/httpclient\",\n  \"examples/httpserver\",\n  \"examples/httpserver\",\n  \"examples/shell\",\n  \"ulib/axmono\",\n]\n\n[workspace.package]\nversion = \"0.1.0\"\nedition = \"2024\"\nauthors = [\"Yuekai Jia <equation618@gmail.com>\"]\nlicense = \"GPL-3.0-or-later OR Apache-2.0 OR MulanPSL-2.0\"\nhomepage = \"https://github.com/arceos-org/arceos\"\ndocumentation = \"https://arceos-org.github.io/arceos\"\nrepository = \"https://github.com/arceos-org/arceos\"\nkeywords = [\"arceos\", \"kernel\"]\ncategories = [\"os\", \"no-std\"]\n\n[workspace.dependencies]\naxstd = { path = \"ulib/axstd\" }\naxlibc = { path = \"ulib/axlibc\" }\naxmono = { path = \"ulib/axmono\" }\narceos_api = { path = \"api/arceos_api\" }\narceos_posix_api = { path = \"api/arceos_posix_api\" }\naxfeat = { path = \"api/axfeat\" }\n\naxalloc = { path = \"modules/axalloc\" }\naxconfig = { path = \"modules/axconfig\" }\naxdisplay = { path = \"modules/axdisplay\" }\naxdriver = { path = \"modules/axdriver\" }\naxfs = { path = \"modules/axfs\" }\naxhal = { path = \"modules/axhal\" }\naxlog = { path = \"modules/axlog\" }\naxmm = { path = \"modules/axmm\" }\naxnet = { path = \"modules/axnet\" }\naxns = { path = \"modules/axns\" }\naxruntime = { path = \"modules/axruntime\" }\naxsync = { path = \"modules/axsync\" }\naxtask = { path = \"modules/axtask\" }\naxdma = { path = \"modules/axdma\" }\naxsyscall = { path = \"modules/axsyscall\" }\nacbat = { path = \"modules/acbat\" }\n\nsyscalls = { git = \"https://github.com/jasonwhite/syscalls.git\", default-features = false, features = [\n  \"loongarch64\",\n  \"riscv64\",\n] }\n\nmemory_set = { path = \"./crates/axmm_crates/memory_set\" }\nmemory_addr = { path = \"./crates/axmm_crates/memory_addr\" }\npage_table_multiarch = { path = \"./crates/page_table_multiarch/page_table_multiarch\" }\npage_table_entry = { path = \"./crates/page_table_multiarch/page_table_entry\" }\naxfs_vfs = {path = \"./crates/axfs_crates/axfs_vfs\" }\naxfs_devfs = {path = \"./crates/axfs_crates/axfs_devfs\"}\naxfs_ramfs = {path =\"./crates/axfs_crates/axfs_ramfs\"}\nbitflags = \"2.9.0\"\nlinkme = \"0.3.32\"\n\n\n#[patch.crates-io]\n#page_table_multiarch = { git = \"https://github.com/oscomp/page_table_multiarch.git\", rev = \"c8a13b0\"}\n#page_table_entry = { git = \"https://github.com/oscomp/page_table_multiarch.git\", rev = \"c8a13b0\" }\n\n[profile.release]\nlto = true\n\n#[patch.crates-io]\n#page_table_multiarch = { git = \"https://github.com/Mivik/page_table_multiarch.git\", rev = \"19ededd\" }\n#page_table_entry = { git = \"https://github.com/Mivik/page_table_multiarch.git\", rev = \"19ededd\" }\n\n[patch.crates-io]\npage_table_multiarch = { path = \"./crates/page_table_multiarch/page_table_multiarch\" }\npage_table_entry = { path = \"./crates/page_table_multiarch/page_table_entry\" }\naxfs_vfs = {path = \"./crates/axfs_crates/axfs_vfs\" }\naxfs_devfs = {path = \"./crates/axfs_crates/axfs_devfs\"}\naxfs_ramfs = {path =\"./crates/axfs_crates/axfs_ramfs\"}\nlwext4_rust ={path =\"./crates/lwext4_rust\"}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Cargo.toml b/Cargo.toml
--- a/Cargo.toml	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/Cargo.toml	(date 1747331427908)
@@ -3,7 +3,7 @@
 
 members = [
   "modules/*",
-  #"crates/*",
+#  "crates/*",
 
   "api/axfeat",
   "api/arceos_api",
@@ -17,6 +17,7 @@
   "examples/httpserver",
   "examples/httpserver",
   "examples/shell",
+#  "examples/TCP_test",
   "ulib/axmono",
 ]
 
@@ -44,7 +45,7 @@
 axdisplay = { path = "modules/axdisplay" }
 axdriver = { path = "modules/axdriver" }
 axfs = { path = "modules/axfs" }
-axhal = { path = "modules/axhal" }
+axhal = { path = "modules/axhal"}
 axlog = { path = "modules/axlog" }
 axmm = { path = "modules/axmm" }
 axnet = { path = "modules/axnet" }
@@ -56,12 +57,9 @@
 axsyscall = { path = "modules/axsyscall" }
 acbat = { path = "modules/acbat" }
 
-syscalls = { git = "https://github.com/jasonwhite/syscalls.git", default-features = false, features = [
-  "loongarch64",
-  "riscv64",
-] }
+syscalls = { version = "0.6.18", default-features = false }
 
-memory_set = { path = "./crates/axmm_crates/memory_set" }
+memory_set = { path = "./crates/axmm_crates/memory_set"}
 memory_addr = { path = "./crates/axmm_crates/memory_addr" }
 page_table_multiarch = { path = "./crates/page_table_multiarch/page_table_multiarch" }
 page_table_entry = { path = "./crates/page_table_multiarch/page_table_entry" }
@@ -70,24 +68,23 @@
 axfs_ramfs = {path ="./crates/axfs_crates/axfs_ramfs"}
 bitflags = "2.9.0"
 linkme = "0.3.32"
-
-
-#[patch.crates-io]
-#page_table_multiarch = { git = "https://github.com/oscomp/page_table_multiarch.git", rev = "c8a13b0"}
-#page_table_entry = { git = "https://github.com/oscomp/page_table_multiarch.git", rev = "c8a13b0" }
+axdriver_block={path = "./crates/axdriver_crates/axdriver_block",features = ["ramdisk"]}
+axdriver_base={path = "./crates/axdriver_crates/axdriver_base"}
+axdriver_display = {path = "./crates/axdriver_crates/axdriver_display"}
+axdriver_net ={path = "./crates/axdriver_crates/axdriver_net"}
+axdriver_pci ={path = "./crates/axdriver_crates/axdriver_pci"}
+axdriver_virtio = {path = "./crates/axdriver_crates/axdriver_virtio"}
 
 [profile.release]
 lto = true
-
-#[patch.crates-io]
-#page_table_multiarch = { git = "https://github.com/Mivik/page_table_multiarch.git", rev = "19ededd" }
-#page_table_entry = { git = "https://github.com/Mivik/page_table_multiarch.git", rev = "19ededd" }
-
 [patch.crates-io]
 page_table_multiarch = { path = "./crates/page_table_multiarch/page_table_multiarch" }
 page_table_entry = { path = "./crates/page_table_multiarch/page_table_entry" }
 axfs_vfs = {path = "./crates/axfs_crates/axfs_vfs" }
 axfs_devfs = {path = "./crates/axfs_crates/axfs_devfs"}
 axfs_ramfs = {path ="./crates/axfs_crates/axfs_ramfs"}
-lwext4_rust ={path ="./crates/lwext4_rust"}
+
+
+[patch.'https://github.com/Azure-stars/lwext4_rust.git']
+lwext4_rust={path = "./crates/lwext4_rust"}
 
Index: ulib/axmono/src/ctypes.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//! clone 任务时指定的参数。\n\nuse arceos_posix_api::ctypes::*;\nuse bitflags::*;\n\nbitflags! {\n    /// 用于 sys_clone 的选项\n    #[derive(Debug, Clone, Copy)]\n    pub struct CloneFlags: u32 {\n        const CSIGNAL = 0xff;\n        /**\n         * cloning flags intersect with CSIGNAL so can be used with unshare and clone3\n         * syscalls only:\n         */\n        const CLONE_NEWTIME = 1 << 7;\n        /// 共享地址空间\n        const CLONE_VM = 1 << 8;\n        /// 共享文件系统新信息\n        const CLONE_FS = 1 << 9;\n        /// 共享文件描述符(fd)表\n        const CLONE_FILES = 1 << 10;\n        /// 共享信号处理函数\n        const CLONE_SIGHAND = 1 << 11;\n        /// 创建指向子任务的fd，用于 sys_pidfd_open\n        const CLONE_PIDFD = 1 << 12;\n        /// 用于 sys_ptrace\n        const CLONE_PTRACE = 1 << 13;\n        /// 指定父任务创建后立即阻塞，直到子任务退出才继续\n        const CLONE_VFORK = 1 << 14;\n        /// 指定子任务的 ppid 为当前任务的 ppid，相当于创建“兄弟”而不是“子女”\n        const CLONE_PARENT = 1 << 15;\n        /// 作为一个“线程”被创建。具体来说，它同 CLONE_PARENT 一样设置 ppid，且不可被 wait\n        const CLONE_THREAD = 1 << 16;\n        /// 子任务使用新的命名空间。目前还未用到\n        const CLONE_NEWNS = 1 << 17;\n        /// 子任务共享同一组信号量。用于 sys_semop\n        const CLONE_SYSVSEM = 1 << 18;\n        /// 要求设置 tls\n        const CLONE_SETTLS = 1 << 19;\n        /// 要求在父任务的一个地址写入子任务的 tid\n        const CLONE_PARENT_SETTID = 1 << 20;\n        /// 要求将子任务的一个地址清零。这个地址会被记录下来，当子任务退出时会触发此处的 futex\n        const CLONE_CHILD_CLEARTID = 1 << 21;\n        /// 历史遗留的 flag，现在按 linux 要求应忽略\n        const CLONE_DETACHED = 1 << 22;\n        /// 与 sys_ptrace 相关，目前未用到\n        const CLONE_UNTRACED = 1 << 23;\n        /// 要求在子任务的一个地址写入子任务的 tid\n        const CLONE_CHILD_SETTID = 1 << 24;\n        /// New pid namespace.\n        const CLONE_NEWPID = 1 << 29;\n\n        const FORK = 0x11;\n    }\n\n    pub struct WaitFlags: u32 {\n        /// 不挂起当前进程，直接返回\n        const WNOHANG = 1 << 0;\n        /// 报告已执行结束的用户进程的状态\n        const WIMTRACED = 1 << 1;\n        /// 报告还未结束的用户进程的状态\n        const WCONTINUED = 1 << 3;\n        /// Wait for any child\n        const WALL = 1 << 30;\n        /// Wait for cloned process\n        const WCLONE = 1 << 31;\n    }\n\n}\n/// sys_wait4 的返回值\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum WaitStatus {\n    /// 子任务正常退出\n    Exited,\n    /// 子任务正在运行\n    Running,\n    /// 找不到对应的子任务\n    NotExist,\n}\n#[repr(C)]\npub struct Tms {\n    /// 进程用户态执行时间，单位为us\n    pub tms_utime: usize,\n    /// 进程内核态执行时间，单位为us\n    pub tms_stime: usize,\n    /// 子进程用户态执行时间和，单位为us\n    pub tms_cutime: usize,\n    /// 子进程内核态执行时间和，单位为us\n    pub tms_cstime: usize,\n}\n\nnumeric_enum_macro::numeric_enum! {\n    #[repr(i32)]\n    #[allow(non_camel_case_types)]\n    #[derive(Eq, PartialEq, Debug, Clone, Copy)]\n    pub enum TimerType {\n    /// 表示目前没有任何计时器(不在linux规范中，是os自己规定的)\n    NONE = -1,\n    /// 统计系统实际运行时间\n    REAL = 0,\n    /// 统计用户态运行时间\n    VIRTUAL = 1,\n    /// 统计进程的所有用户态/内核态运行时间\n    PROF = 2,\n    }\n}\n\nimpl From<usize> for TimerType {\n    fn from(num: usize) -> Self {\n        Self::try_from(num as i32).unwrap_or_else(|_| Self::NONE)\n    }\n}\npub struct TimeStat {\n    utime_ns: usize,\n    stime_ns: usize,\n    user_timestamp: usize,\n    kernel_timestamp: usize,\n    timer_type: TimerType,\n    timer_interval_ns: usize,\n    timer_remained_ns: usize,\n}\n\nimpl Default for TimeStat {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl TimeStat {\n    pub fn new() -> Self {\n        Self {\n            utime_ns: 0,\n            stime_ns: 0,\n            user_timestamp: 0,\n            kernel_timestamp: 0,\n            timer_type: TimerType::NONE,\n            timer_interval_ns: 0,\n            timer_remained_ns: 0,\n        }\n    }\n\n    pub fn output(&self) -> (usize, usize) {\n        (self.utime_ns, self.stime_ns)\n    }\n\n    pub fn reset(&mut self, current_timestamp: usize) {\n        self.utime_ns = 0;\n        self.stime_ns = 0;\n        self.user_timestamp = 0;\n        self.kernel_timestamp = current_timestamp;\n    }\n\n    pub fn switch_into_kernel_mode(&mut self, current_timestamp: usize) {\n        let now_time_ns = current_timestamp;\n        let delta = now_time_ns - self.kernel_timestamp;\n        self.utime_ns += delta;\n        self.kernel_timestamp = now_time_ns;\n        if self.timer_type != TimerType::NONE {\n            self.update_timer(delta);\n        };\n    }\n\n    pub fn switch_into_user_mode(&mut self, current_timestamp: usize) {\n        let now_time_ns = current_timestamp;\n        let delta = now_time_ns - self.kernel_timestamp;\n        self.stime_ns += delta;\n        self.user_timestamp = now_time_ns;\n        if self.timer_type == TimerType::REAL || self.timer_type == TimerType::PROF {\n            self.update_timer(delta);\n        }\n    }\n\n    pub fn switch_from_old_task(&mut self, current_timestamp: usize) {\n        let now_time_ns = current_timestamp;\n        let delta = now_time_ns - self.kernel_timestamp;\n        self.stime_ns += delta;\n        self.kernel_timestamp = now_time_ns;\n        if self.timer_type == TimerType::REAL || self.timer_type == TimerType::PROF {\n            self.update_timer(delta);\n        }\n    }\n\n    pub fn switch_to_new_task(&mut self, current_timestamp: usize) {\n        let now_time_ns = current_timestamp;\n        let delta = now_time_ns - self.kernel_timestamp;\n        self.kernel_timestamp = now_time_ns;\n        if self.timer_type == TimerType::REAL {\n            self.update_timer(delta);\n        }\n    }\n\n    pub fn set_timer(\n        &mut self,\n        timer_interval_ns: usize,\n        timer_remained_ns: usize,\n        timer_type: usize,\n    ) -> bool {\n        self.timer_type = timer_type.into();\n        self.timer_interval_ns = timer_interval_ns;\n        self.timer_remained_ns = timer_remained_ns;\n        self.timer_type != TimerType::NONE\n    }\n\n    pub fn update_timer(&mut self, delta: usize) {\n        if self.timer_remained_ns == 0 {\n            return;\n        }\n        if self.timer_remained_ns > delta {\n            self.timer_remained_ns -= delta;\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ulib/axmono/src/ctypes.rs b/ulib/axmono/src/ctypes.rs
--- a/ulib/axmono/src/ctypes.rs	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/ulib/axmono/src/ctypes.rs	(date 1745904419815)
@@ -1,5 +1,4 @@
 //! clone 任务时指定的参数。
-
 use arceos_posix_api::ctypes::*;
 use bitflags::*;
 
Index: ulib/axmono/src/task/mod.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use crate::{\n    copy_from_kernel,\n    ctypes::{CloneFlags, TimeStat, WaitStatus},\n    elf::ELFInfo,\n    loader::load_app_from_disk,\n    mm::map_elf_sections,\n};\nuse alloc::{\n    string::{String, ToString},\n    sync::Arc,\n    vec::Vec,\n};\nuse arceos_posix_api::FD_TABLE;\nuse axerrno::{AxError, AxResult};\nuse axfs::api::set_current_dir;\nuse axfs::{CURRENT_DIR, CURRENT_DIR_PATH};\nuse axhal::trap::{POST_TRAP, PRE_TRAP, register_trap_handler};\nuse signal::SignalContext;\nuse core::{\n    cell::UnsafeCell,\n    sync::atomic::{AtomicU64, Ordering},\n};\nuse memory_addr::{VirtAddr, VirtAddrRange};\n\nuse axhal::{\n    arch::{TrapFrame, UspaceContext},\n    time::{monotonic_time_nanos, NANOS_PER_MICROS, NANOS_PER_SEC},\n};\nuse axmm::heap::HeapSpace;\nuse axmm::{AddrSpace, kernel_aspace};\nuse axns::{AxNamespace, AxNamespaceIf};\nuse axsync::Mutex;\nuse axtask::{current, AxTaskRef, TaskExtRef, TaskInner};\n\n#[cfg(feature = \"sig\")]\nmod signal;\n\npub fn new_user_aspace_empty() -> AxResult<AddrSpace> {\n    AddrSpace::new_empty(\n        VirtAddr::from_usize(axconfig::plat::USER_SPACE_BASE),\n        axconfig::plat::USER_SPACE_SIZE,\n    )\n}\n\n/// Task extended data for the monolithic kernel.\npub struct TaskExt {\n    /// The process ID.\n    pub proc_id: usize,\n    /// The parent process ID.\n    pub parent_id: AtomicU64,\n    /// children process\n    pub children: Mutex<Vec<AxTaskRef>>,\n    /// The clear thread tid field\n    ///\n    /// See <https://manpages.debian.org/unstable/manpages-dev/set_tid_address.2.en.html#clear_child_tid>\n    ///\n    /// When the thread exits, the kernel clears the word at this address if it is not NULL.\n    clear_child_tid: AtomicU64,\n    /// The user space context.\n    pub uctx: UspaceContext,\n    /// The virtual memory address space.\n    pub aspace: Arc<Mutex<AddrSpace>>,\n    /// The resource namespace\n    pub ns: AxNamespace,\n    /// The time statistics\n    pub time: UnsafeCell<TimeStat>,\n    #[cfg(feature = \"sig\")]\n    pub sigctx: SignalContext,\n}\n\n#[allow(unused)]\nimpl TaskExt {\n    pub fn new(proc_id: usize, uctx: UspaceContext, aspace: Arc<Mutex<AddrSpace>>) -> Self {\n        Self {\n            proc_id,\n            parent_id: AtomicU64::new(1),\n            children: Mutex::new(Vec::new()),\n            uctx,\n            clear_child_tid: AtomicU64::new(0),\n            aspace,\n            ns: AxNamespace::new_thread_local(false),\n            time: TimeStat::new().into(),\n            sigctx: SignalContext::default()\n        }\n    }\n\n    pub(crate) fn clear_child_tid(&self) -> u64 {\n        self.clear_child_tid\n            .load(core::sync::atomic::Ordering::Relaxed)\n    }\n\n    pub(crate) fn set_clear_child_tid(&self, clear_child_tid: u64) {\n        self.clear_child_tid\n            .store(clear_child_tid, core::sync::atomic::Ordering::Relaxed);\n    }\n\n    pub(crate) fn get_parent(&self) -> u64 {\n        self.parent_id.load(Ordering::Acquire)\n    }\n\n    pub(crate) fn set_parent(&self, parent_id: u64) {\n        self.parent_id.store(parent_id, Ordering::Release);\n    }\n\n    /// Initialize the namespace for the new task.\n    /// TODO: from parent task\n    pub(crate) fn ns_init_new(&self) {\n        FD_TABLE.create(&self.ns).init_new(FD_TABLE.copy_inner());\n        CURRENT_DIR\n            .create(&self.ns)\n            .init_new(CURRENT_DIR.copy_inner());\n        CURRENT_DIR_PATH\n            .create(&self.ns)\n            .init_new(CURRENT_DIR_PATH.copy_inner());\n    }\n\n    pub(crate) fn time_stat_from_kernel_to_user(&self, current_tick: usize) {\n        let time = self.time.get();\n        unsafe {\n            (*time).switch_into_user_mode(current_tick);\n        }\n    }\n\n    pub(crate) fn time_stat_from_user_to_kernel(&self, current_tick: usize) {\n        let time = self.time.get();\n        unsafe {\n            (*time).switch_into_kernel_mode(current_tick);\n        }\n    }\n\n    pub(crate) fn time_stat_when_switch_from(&self, current_tick: usize) {\n        let time = self.time.get();\n        unsafe {\n            (*time).switch_from_old_task(current_tick);\n        }\n    }\n\n    pub(crate) fn time_stat_when_switch_to(&self, current_tick: usize) {\n        let time = self.time.get();\n        unsafe {\n            (*time).switch_to_new_task(current_tick);\n        }\n    }\n\n    pub(crate) fn time_stat_output(&self) -> (usize, usize) {\n        let time = self.time.get();\n        unsafe { (*time).output() }\n    }\n\n    pub(crate) fn set_heap_top(&self, top: VirtAddr) -> VirtAddr {\n        self.aspace.lock().set_heap_top(top)\n    }\n\n    pub(crate) fn set_heap_size(&self, size: usize) -> VirtAddr {\n        self.aspace.lock().set_heap_size(size)\n    }\n\n    pub(crate) fn heap_size(&self) -> usize {\n        self.aspace.lock().heap().size()\n    }\n\n    pub(crate) fn heap_top(&self) -> VirtAddr {\n        self.aspace.lock().heap().top()\n    }\n}\n\nimpl Drop for TaskExt {\n    fn drop(&mut self) {\n        if !cfg!(target_arch = \"aarch64\") && !cfg!(target_arch = \"loongarch64\") {\n            // See [`crate::new_user_aspace`]\n\n            debug!(\"Drop TaskExt: {}\", self.proc_id);\n\n            let kernel = kernel_aspace().lock();\n\n            self.aspace\n                .lock()\n                .clear_mappings(VirtAddrRange::from_start_size(kernel.base(), kernel.size()));\n        }\n    }\n}\n\nstruct AxNamespaceImpl;\n\n#[crate_interface::impl_interface]\nimpl AxNamespaceIf for AxNamespaceImpl {\n    #[inline(never)]\n    fn current_namespace_base() -> *mut u8 {\n        let current = axtask::current();\n        /*\n         *println!(\"current_namespace_base: {:p}\", unsafe {\n         *    current.task_ext_ptr()\n         *});\n         */\n        // Safety: We only check whether the task extended data is null and do not access it.\n        if unsafe { current.task_ext_ptr() }.is_null() {\n            return axns::AxNamespace::global().base();\n        }\n        current.task_ext().ns.base()\n    }\n}\n\naxtask::def_task_ext!(TaskExt);\n\npub fn spawn_user_task_inner(\n    app_name: &str,\n    aspace: Arc<Mutex<AddrSpace>>,\n    uctx: UspaceContext,\n) -> TaskInner {\n    let mut task = TaskInner::new(\n        move || {\n            // TODO: no current\n            let curr = axtask::current();\n            let kstack_top = curr.kernel_stack_top().unwrap();\n            error!(\"tp:{:?}\", curr.task_ext().uctx.0.regs.tp);\n            trace!(\n                \"Enter user space: entry={:#x}, ustack={:#x}, kstack={:#x}\",\n                curr.task_ext().uctx.get_ip(),\n                curr.task_ext().uctx.get_sp(),\n                kstack_top,\n            );\n            // FIXME:\n            set_current_dir(\"/\");\n            unsafe { curr.task_ext().uctx.enter_uspace(kstack_top) };\n        },\n        app_name.into(),\n        axconfig::plat::KERNEL_STACK_SIZE,\n    );\n    task.ctx_mut()\n        .set_page_table_root(aspace.lock().page_table_root());\n\n    task.init_task_ext(TaskExt::new(task.id().as_u64() as usize, uctx, aspace));\n\n    // TODO:\n    task.task_ext().ns_init_new();\n    task\n}\n\npub fn spawn_user_task(\n    app_name: &str,\n    aspace: Arc<Mutex<AddrSpace>>,\n    uctx: UspaceContext,\n) -> AxTaskRef {\n    spawn_user_task_inner(app_name, aspace, uctx).into_arc()\n    /*\n     *let task_inner = spawn_user_task_inner(app_name, aspace, uctx);\n     *axtask::spawn_task(task_inner)\n     */\n}\n\n/// Unable to work for cloned task since task will overwrite trap_frame from uctx\npub fn write_trapframe_to_kstack(kstack_top: usize, trap_frame: &TrapFrame) {\n    let trap_frame_size = core::mem::size_of::<TrapFrame>();\n    let trap_frame_ptr = (kstack_top - trap_frame_size) as *mut TrapFrame;\n    unsafe {\n        *trap_frame_ptr = *trap_frame;\n    }\n}\n\npub fn read_trapframe_from_kstack(kstack_top: usize) -> TrapFrame {\n    let trap_frame_size = core::mem::size_of::<TrapFrame>();\n    let trap_frame_ptr = (kstack_top - trap_frame_size) as *mut TrapFrame;\n    unsafe { *trap_frame_ptr }\n}\n\n/// From starry-next\npub fn wait_pid(task: AxTaskRef, pid: i32, exit_code_ptr: *mut i32) -> Result<u64, WaitStatus> {\n    let mut exit_task_id: usize = 0;\n    let mut answer_id: u64 = 0;\n    let mut answer_status = WaitStatus::NotExist;\n\n    for (index, child) in task.task_ext().children.lock().iter().enumerate() {\n        if pid <= 0 {\n            if pid == 0 {\n                axlog::warn!(\"Don't support for process group.\");\n            }\n\n            answer_status = WaitStatus::Running;\n            if child.state() == axtask::TaskState::Exited {\n                let exit_code = child.exit_code();\n                answer_status = WaitStatus::Exited;\n                debug!(\n                    \"wait pid _{}_ with code _{}_\",\n                    child.id().as_u64(),\n                    exit_code\n                );\n                exit_task_id = index;\n                if !exit_code_ptr.is_null() {\n                    unsafe {\n                        *exit_code_ptr = exit_code << 8;\n                    }\n                }\n                answer_id = child.id().as_u64();\n                break;\n            }\n        } else if child.id().as_u64() == pid as u64 {\n            if let Some(exit_code) = child.join() {\n                answer_status = WaitStatus::Exited;\n                info!(\n                    \"wait pid _{}_ with code _{:?}_\",\n                    child.id().as_u64(),\n                    exit_code\n                );\n                exit_task_id = index;\n                if !exit_code_ptr.is_null() {\n                    unsafe {\n                        *exit_code_ptr = exit_code << 8;\n                    }\n                }\n                answer_id = child.id().as_u64();\n            } else {\n                answer_status = WaitStatus::Running;\n            }\n            break;\n        }\n    }\n\n    if answer_status == WaitStatus::Running {\n        axtask::yield_now();\n    }\n\n    if answer_status == WaitStatus::Exited {\n        task.task_ext().children.lock().remove(exit_task_id);\n        return Ok(answer_id);\n    }\n    Err(answer_status)\n}\n\n/// fork current task\n/// **Return**\n/// - `Ok(new_task_ref)` if fork successfully\npub fn fork(current_task: AxTaskRef, from_umode: bool) -> AxResult<AxTaskRef> {\n    clone_task(current_task, None, CloneFlags::FORK, from_umode)\n}\n\npub fn clone_task(\n    current_task: AxTaskRef,\n    stack: Option<usize>,\n    clone_flags: CloneFlags,\n    from_umode: bool,\n    /*\n     *_ptid: usize,\n     *_tls: usize,\n     *_ctid: usize,\n     */\n) -> AxResult<AxTaskRef> {\n    axconfig::plat::KERNEL_STACK_SIZE;\n    // TODO: support all flags\n\n    let current_task_ext = current_task.task_ext();\n    // new task with same ip and sp of current task\n    let mut trap_frame = read_trapframe_from_kstack(current_task.get_kernel_stack_top().unwrap());\n\n    let mut current_aspace = current_task_ext.aspace.lock();\n    let mut new_aspace;\n    #[cfg(feature = \"COW\")]\n    {\n        new_aspace = current_aspace.clone_on_write()?;\n    }\n    #[cfg(not(feature = \"COW\"))]\n    {\n        new_aspace = current_aspace.clone_or_err()?;\n    }\n\n    copy_from_kernel(&mut new_aspace);\n\n    //let new_uctx = current_task_ext.uctx.0;\n\n    if from_umode {\n        trap_frame.set_ret_code(0);\n        trap_frame.inc_sepc();\n    }\n\n    // TODO: clone stack since it's always changed.\n    // stack is copied meanwhilst addr space is copied\n    //trap_frame.set_user_sp(stack);\n    if let Some(stack) = stack {\n        trap_frame.set_user_sp(stack);\n    }\n\n    //write_trapframe_to_kstack(new_task_ref.kernel_stack_top().unwrap().into(), &trap_frame);\n    //write_trapframe_to_kstack(new_task_ref.kernel_stack_top().unwrap().into(), &TrapFrame::default());\n    //new_uctx.0 = trap_frame;\n    let new_uctx = UspaceContext::from(&trap_frame);\n    //panic!();\n\n    let new_task_ref = spawn_user_task(\n        current_task.name(),\n        Arc::new(Mutex::new(new_aspace)),\n        new_uctx,\n    );\n\n    // TODO: children task management\n    current_task_ext.children.lock().push(new_task_ref.clone());\n\n    Ok(new_task_ref)\n}\n\n/// execve\n/// mainly from starry\n/// **Return**\n/// - `Ok(handler)` if exec successfully, call handler to enter task.\n/// - `Err(AxError)` if exec failed\npub fn exec_current(program_name: &str, args: &[String], envs: &[String]) -> AxResult {\n    warn!(\n        \"exec: {} with args {:?}, envs {:?}\",\n        program_name, args, envs\n    );\n\n    let program_path = program_name.to_string();\n    let elf_file = load_app_from_disk(&program_path)?;\n\n    let current_task = current();\n\n    let mut aspace = current_task.task_ext().aspace.lock();\n    let elf_info = ELFInfo::new(elf_file, aspace.base());\n\n    if Arc::strong_count(&current_task.task_ext().aspace) != 1 {\n        warn!(\"Address space is shared by multiple tasks, exec is not supported.\");\n        return Err(AxError::Unsupported);\n    }\n\n    aspace.unmap_user_areas()?;\n    axhal::arch::flush_tlb(None);\n\n    //TODO: clone envs??\n    let (entry_point, user_stack_base) =\n        map_elf_sections(elf_info, &mut aspace, Some(args), Some(envs))?;\n\n    let task_ext = unsafe { &mut *(current_task.task_ext_ptr() as *mut TaskExt) };\n    task_ext.uctx = UspaceContext::new(entry_point.as_usize(), user_stack_base, 0);\n\n    unsafe { current_task.task_ext().aspace.force_unlock() };\n\n    current_task.set_name(&program_path);\n\n    unsafe {\n        task_ext.uctx.enter_uspace(\n            current_task\n                .kernel_stack_top()\n                .expect(\"No kernel stack top\"),\n        )\n    }\n}\n\npub fn time_stat_from_kernel_to_user() {\n    let curr_task = current();\n    if (unsafe { curr_task.task_ext_ptr().is_null() }) {\n        return;\n    }\n    curr_task\n        .task_ext()\n        .time_stat_from_kernel_to_user(monotonic_time_nanos() as usize);\n}\n\npub fn time_stat_from_user_to_kernel() {\n    let curr_task = current();\n    if (unsafe { curr_task.task_ext_ptr().is_null() }) {\n        return;\n    }\n    curr_task\n        .task_ext()\n        .time_stat_from_user_to_kernel(monotonic_time_nanos() as usize);\n}\n\npub fn time_stat_output() -> (usize, usize, usize, usize) {\n    let curr_task = current();\n    let (utime_ns, stime_ns) = curr_task.task_ext().time_stat_output();\n    (\n        utime_ns / NANOS_PER_SEC as usize,\n        utime_ns / NANOS_PER_MICROS as usize,\n        stime_ns / NANOS_PER_SEC as usize,\n        stime_ns / NANOS_PER_MICROS as usize,\n    )\n}\n\npub fn time_stat_ns() -> (usize, usize) {\n    let curr_task = current();\n    curr_task.task_ext().time_stat_output()\n}\n\npub fn test(task: AxTaskRef) {\n    let task_ext = task.task_ext();\n    let mut buf = [0u8; 16];\n    task_ext\n        .aspace\n        .lock()\n        .read(0x1161c.into(), &mut buf)\n        .unwrap();\n}\n\n#[register_trap_handler(PRE_TRAP)]\nfn pre_trap_handler(trap_frame: &TrapFrame) -> bool {\n    time_stat_from_user_to_kernel();\n    true\n}\n\n#[register_trap_handler(POST_TRAP)]\nfn post_trap_handler(trap_frame: &TrapFrame) -> bool {\n    time_stat_from_kernel_to_user();\n    true\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ulib/axmono/src/task/mod.rs b/ulib/axmono/src/task/mod.rs
--- a/ulib/axmono/src/task/mod.rs	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/ulib/axmono/src/task/mod.rs	(date 1745660511129)
@@ -15,7 +15,7 @@
 use axfs::api::set_current_dir;
 use axfs::{CURRENT_DIR, CURRENT_DIR_PATH};
 use axhal::trap::{POST_TRAP, PRE_TRAP, register_trap_handler};
-use signal::SignalContext;
+// use signal::SignalContext;
 use core::{
     cell::UnsafeCell,
     sync::atomic::{AtomicU64, Ordering},
@@ -64,8 +64,9 @@
     pub ns: AxNamespace,
     /// The time statistics
     pub time: UnsafeCell<TimeStat>,
-    #[cfg(feature = "sig")]
-    pub sigctx: SignalContext,
+    
+    // #[cfg(feature = "sig")]
+    // pub sigctx: SignalContext,
 }
 
 #[allow(unused)]
@@ -80,7 +81,7 @@
             aspace,
             ns: AxNamespace::new_thread_local(false),
             time: TimeStat::new().into(),
-            sigctx: SignalContext::default()
+            // sigctx: SignalContext::default()
         }
     }
 
Index: modules/axsyscall/Cargo.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[package]\nname = \"axsyscall\"\nversion.workspace = true\nedition.workspace = true\nauthors.workspace = true\nlicense.workspace = true\nhomepage.workspace = true\ndocumentation.workspace = true\nrepository.workspace = true\nkeywords.workspace = true\ncategories.workspace = true\n[features]\ndefault = [\"basic_impl\"]\nbasic_impl = []\nfs = [\"arceos_posix_api/fs\", \"dep:axfs\"]\nfd = [\"arceos_posix_api/fd\"]\nnet = [\"arceos_posix_api/net\"]\npipe = [\"arceos_posix_api/pipe\"]\nmultitask = [\"arceos_posix_api/multitask\"]\n[dependencies]\nsyscalls = { workspace = true }\narceos_posix_api = { workspace = true }\naxerrno = \"0.1\"\naxhal = { workspace = true }\naxtask = { workspace = true }\naxfs = { workspace = true, optional = true }\naxmm = { workspace = true }\naxconfig = { workspace = true }\naxlog = { workspace = true }\n\nlinkme = { workspace = true }\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/modules/axsyscall/Cargo.toml b/modules/axsyscall/Cargo.toml
--- a/modules/axsyscall/Cargo.toml	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/modules/axsyscall/Cargo.toml	(date 1745898648248)
@@ -28,4 +28,5 @@
 axconfig = { workspace = true }
 axlog = { workspace = true }
 
+
 linkme = { workspace = true }
Index: ulib/axmono/src/task/signal.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use arceos_posix_api::ctypes::*;\nuse axhal::arch::{TrapFrame, UspaceContext};\nuse axtask::{current, AxTaskRef, TaskExtMut, TaskExtRef};\nuse bitflags::*;\nuse syscalls::Sysno;\n\nconst NSIG: i32 = 32;\n/// signals\n#[repr(i32)]\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\npub enum Signal {\n    SIGBLOCK = SIG_BLOCK,\n    SIGUNBLOCK = SIG_UNBLOCK,\n    SIGSETMASK = SIG_SETMASK,\n    SIGHUP = SIGHUP,\n    SIGINT = SIGINT,\n    SIGQUIT = SIGQUIT,\n    SIGILL = SIGILL,\n    SIGTRAP = SIGTRAP,\n    SIGABRT = SIGABRT,\n    SIGIOT = SIGIOT,\n    SIGBUS = SIGBUS,\n    SIGFPE = SIGFPE,\n    SIGKILL = SIGKILL,\n    SIGUSR1 = SIGUSR1,\n    SIGSEGV = SIGSEGV,\n    SIGUSR2 = SIGUSR2,\n    SIGPIPE = SIGPIPE,\n    SIGALRM = SIGALRM,\n    SIGTERM = SIGTERM,\n    SIGSTKFLT = SIGSTKFLT,\n    SIGCHLD = SIGCHLD,\n    SIGCONT = SIGCONT,\n    SIGSTOP = SIGSTOP,\n    SIGTSTP = SIGTSTP,\n    SIGTTIN = SIGTTIN,\n    SIGTTOU = SIGTTOU,\n    SIGURG = SIGURG,\n    SIGXCPU = SIGXCPU,\n    SIGXFSZ = SIGXFSZ,\n    SIGVTALRM = SIGVTALRM,\n    SIGPROF = SIGPROF,\n    SIGWINCH = SIGWINCH,\n    SIGIO = SIGIO,\n    SIGPOLL = SIGPOLL,\n    SIGPWR = SIGPWR,\n    SIGSYS = SIGSYS,\n    SIGUNUSED = SIGUNUSED,\n}\n\nimpl Signal {\n    pub fn from_u32(n: u32) -> Option<Self> {\n        if n > NSIG {\n            None\n        } else {\n            Some(unsafe { core::mem::transmute(n) })\n        }\n    }\n}\n\nbitflags! {\n    pub struct SignalSet :u32 {\n        const SIG_BLOCK = 1 << Signal::SIGBLOCK as usize;\n    }\n}\n\nimpl SignalSet {\n    pub fn get_one(&self) -> Option<Signal> {\n        let sig = self.bits().trailing_zeros();\n        Signal::from_u32(sig)\n    }\n}\n\nimpl From<Signal> for SignalSet {\n    fn from(sig: Signal) -> Self {\n        Self::from_bits_retain(1 << sig as usize)\n    }\n}\n\npub enum SigHandler {\n    Default,\n    Ignore,\n    Handler(unsafe extern \"C\" fn(i32)),\n}\n\n// 信号动作配置\npub struct SigAction {\n    pub handler: SigHandler,\n    pub mask: SignalSet,\n    pub flags: i32,\n}\n\n#[naked]\n#[no_mangle]\nunsafe extern \"C\" fn sigreturn_trampoline() {\n    // 内联汇编确保无函数前导/后导代码\n    asm!(\n        \"li a7, {sysno}\",\n        \"ecall\",\n        sysno = const Sysno::rt_sigreturn as usize,\n        options(noreturn)\n    );\n}\n\n/// 信号返回trampoline\nglobal_asm!(\n    r#\"\n    .global sigreturn_trampoline\n    sigreturn_trampoline:\n        li a7, {sys_sigreturn}\n        ecall\n    \"#,\n    sys_sigreturn = const Sysno::rt_sigreturn,\n);\n\n// 进程信号上下文\n#[derive(Default)]\npub struct SignalContext {\n    pub handlers: [SigAction; NSIG as usize], // 信号处理表\n    pub blocked: SignalSet,                   // 被阻塞的信号\n    pub pending: SignalSet,                   // 待处理信号\n}\n\nimpl SignalContext {\n    /// 向进程发送信号\n    pub fn send_signal(&mut self, sig: Signal) {\n        let mask = 1 << (sig as u8 - 1);\n\n        // 如果信号未被阻塞，则加入待处理队列\n        if !self.pending.contains(sig) {\n            self.pending = self.pending.union(sig);\n        }\n    }\n\n    /// 检查是否有待处理信号\n    pub fn has_pending(&self) -> bool {\n        self.pending == 0\n    }\n}\n\npub fn handle_pending_signals() {\n    let current_task = current();\n    let tast_ext = current_task.task_ext_mut();\n    let mut ctx: SignalContext = tast_ext.sigctx;\n    let curr_sp = tast_ext.uctx.get_sp();\n\n    while ctx.has_pending() {\n        // 找到最高优先级的待处理信号\n        let sig = ctx.pending.get_one().unwrap();\n        let sig_action = &ctx.handlers[sig as usize];\n\n        match sig_action.handler {\n            SigHandler::Default => handle_default_signal(sig, regs),\n            SigHandler::Ignore => {} // 直接忽略\n            SigHandler::Handler(handler) => {\n                // 设置信号处理栈帧\n                // WARN: 在syscall rt_sigreturn中清除信号。\n                unsafe { enter_signal_handler(&mut ctx, curr_sp, handler, sig) };\n            }\n        }\n\n        // 清除已处理的信号\n        ctx.pending.remove(sig);\n    }\n}\n\nunsafe fn enter_signal_handler(\n    sigctx: &mut SignalContext,\n    ustack_top: usize,\n    sig_action: SigAction,\n    handler: unsafe extern \"C\" fn(i32),\n    sig: i32,\n) -> ! {\n    let curr = current();\n    let sigctx = curr.task_ext().sigctx;\n    // 设置用户处理函数上下文，栈接着原来的用户栈\n    // 信号编号作为第一个参数\n    let uctx = UspaceContext::new(handler as usize, ustack_top, sig as usize);\n\n    // 跳转到处理函数\n    uctx.set_ip(handler as usize);\n    uctx.sepc = handler as usize;\n\n    // 设置返回地址为信号返回trampoline\n    regs.ra = sigreturn_trampoline as usize;\n\n    // 设置信号屏蔽字\n    let old_mask = current_task().signal_ctx.blocked;\n    sigctx.blocked |= sig_action.mask;\n    frame.saved_mask = old_mask;\n    unsafe { uctx.enter_uspace(task.get_sig_stack_top()) };\n}\n\nfn enter_signal_handler(tf: &mut TrapFrame) {}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ulib/axmono/src/task/signal.rs b/ulib/axmono/src/task/signal.rs
--- a/ulib/axmono/src/task/signal.rs	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/ulib/axmono/src/task/signal.rs	(date 1745660511123)
@@ -1,194 +1,194 @@
-use arceos_posix_api::ctypes::*;
-use axhal::arch::{TrapFrame, UspaceContext};
-use axtask::{current, AxTaskRef, TaskExtMut, TaskExtRef};
-use bitflags::*;
-use syscalls::Sysno;
-
-const NSIG: i32 = 32;
-/// signals
-#[repr(i32)]
-#[derive(Debug, Copy, Clone, PartialEq, Eq)]
-pub enum Signal {
-    SIGBLOCK = SIG_BLOCK,
-    SIGUNBLOCK = SIG_UNBLOCK,
-    SIGSETMASK = SIG_SETMASK,
-    SIGHUP = SIGHUP,
-    SIGINT = SIGINT,
-    SIGQUIT = SIGQUIT,
-    SIGILL = SIGILL,
-    SIGTRAP = SIGTRAP,
-    SIGABRT = SIGABRT,
-    SIGIOT = SIGIOT,
-    SIGBUS = SIGBUS,
-    SIGFPE = SIGFPE,
-    SIGKILL = SIGKILL,
-    SIGUSR1 = SIGUSR1,
-    SIGSEGV = SIGSEGV,
-    SIGUSR2 = SIGUSR2,
-    SIGPIPE = SIGPIPE,
-    SIGALRM = SIGALRM,
-    SIGTERM = SIGTERM,
-    SIGSTKFLT = SIGSTKFLT,
-    SIGCHLD = SIGCHLD,
-    SIGCONT = SIGCONT,
-    SIGSTOP = SIGSTOP,
-    SIGTSTP = SIGTSTP,
-    SIGTTIN = SIGTTIN,
-    SIGTTOU = SIGTTOU,
-    SIGURG = SIGURG,
-    SIGXCPU = SIGXCPU,
-    SIGXFSZ = SIGXFSZ,
-    SIGVTALRM = SIGVTALRM,
-    SIGPROF = SIGPROF,
-    SIGWINCH = SIGWINCH,
-    SIGIO = SIGIO,
-    SIGPOLL = SIGPOLL,
-    SIGPWR = SIGPWR,
-    SIGSYS = SIGSYS,
-    SIGUNUSED = SIGUNUSED,
-}
-
-impl Signal {
-    pub fn from_u32(n: u32) -> Option<Self> {
-        if n > NSIG {
-            None
-        } else {
-            Some(unsafe { core::mem::transmute(n) })
-        }
-    }
-}
-
-bitflags! {
-    pub struct SignalSet :u32 {
-        const SIG_BLOCK = 1 << Signal::SIGBLOCK as usize;
-    }
-}
-
-impl SignalSet {
-    pub fn get_one(&self) -> Option<Signal> {
-        let sig = self.bits().trailing_zeros();
-        Signal::from_u32(sig)
-    }
-}
-
-impl From<Signal> for SignalSet {
-    fn from(sig: Signal) -> Self {
-        Self::from_bits_retain(1 << sig as usize)
-    }
-}
-
-pub enum SigHandler {
-    Default,
-    Ignore,
-    Handler(unsafe extern "C" fn(i32)),
-}
-
-// 信号动作配置
-pub struct SigAction {
-    pub handler: SigHandler,
-    pub mask: SignalSet,
-    pub flags: i32,
-}
-
-#[naked]
-#[no_mangle]
-unsafe extern "C" fn sigreturn_trampoline() {
-    // 内联汇编确保无函数前导/后导代码
-    asm!(
-        "li a7, {sysno}",
-        "ecall",
-        sysno = const Sysno::rt_sigreturn as usize,
-        options(noreturn)
-    );
-}
-
-/// 信号返回trampoline
-global_asm!(
-    r#"
-    .global sigreturn_trampoline
-    sigreturn_trampoline:
-        li a7, {sys_sigreturn}
-        ecall
-    "#,
-    sys_sigreturn = const Sysno::rt_sigreturn,
-);
-
-// 进程信号上下文
-#[derive(Default)]
-pub struct SignalContext {
-    pub handlers: [SigAction; NSIG as usize], // 信号处理表
-    pub blocked: SignalSet,                   // 被阻塞的信号
-    pub pending: SignalSet,                   // 待处理信号
-}
-
-impl SignalContext {
-    /// 向进程发送信号
-    pub fn send_signal(&mut self, sig: Signal) {
-        let mask = 1 << (sig as u8 - 1);
-
-        // 如果信号未被阻塞，则加入待处理队列
-        if !self.pending.contains(sig) {
-            self.pending = self.pending.union(sig);
-        }
-    }
-
-    /// 检查是否有待处理信号
-    pub fn has_pending(&self) -> bool {
-        self.pending == 0
-    }
-}
-
-pub fn handle_pending_signals() {
-    let current_task = current();
-    let tast_ext = current_task.task_ext_mut();
-    let mut ctx: SignalContext = tast_ext.sigctx;
-    let curr_sp = tast_ext.uctx.get_sp();
-
-    while ctx.has_pending() {
-        // 找到最高优先级的待处理信号
-        let sig = ctx.pending.get_one().unwrap();
-        let sig_action = &ctx.handlers[sig as usize];
-
-        match sig_action.handler {
-            SigHandler::Default => handle_default_signal(sig, regs),
-            SigHandler::Ignore => {} // 直接忽略
-            SigHandler::Handler(handler) => {
-                // 设置信号处理栈帧
-                // WARN: 在syscall rt_sigreturn中清除信号。
-                unsafe { enter_signal_handler(&mut ctx, curr_sp, handler, sig) };
-            }
-        }
-
-        // 清除已处理的信号
-        ctx.pending.remove(sig);
-    }
-}
-
-unsafe fn enter_signal_handler(
-    sigctx: &mut SignalContext,
-    ustack_top: usize,
-    sig_action: SigAction,
-    handler: unsafe extern "C" fn(i32),
-    sig: i32,
-) -> ! {
-    let curr = current();
-    let sigctx = curr.task_ext().sigctx;
-    // 设置用户处理函数上下文，栈接着原来的用户栈
-    // 信号编号作为第一个参数
-    let uctx = UspaceContext::new(handler as usize, ustack_top, sig as usize);
-
-    // 跳转到处理函数
-    uctx.set_ip(handler as usize);
-    uctx.sepc = handler as usize;
-
-    // 设置返回地址为信号返回trampoline
-    regs.ra = sigreturn_trampoline as usize;
-
-    // 设置信号屏蔽字
-    let old_mask = current_task().signal_ctx.blocked;
-    sigctx.blocked |= sig_action.mask;
-    frame.saved_mask = old_mask;
-    unsafe { uctx.enter_uspace(task.get_sig_stack_top()) };
-}
-
-fn enter_signal_handler(tf: &mut TrapFrame) {}
+// use arceos_posix_api::ctypes::*;
+// use axhal::arch::{TrapFrame, UspaceContext};
+// use axtask::{current, AxTaskRef, TaskExtMut, TaskExtRef};
+// use bitflags::*;
+// use syscalls::Sysno;
+// 
+// const NSIG: i32 = 32;
+// /// signals
+// #[repr(i32)]
+// #[derive(Debug, Copy, Clone, PartialEq, Eq)]
+// pub enum Signal {
+//     SIGBLOCK = SIG_BLOCK,
+//     SIGUNBLOCK = SIG_UNBLOCK,
+//     SIGSETMASK = SIG_SETMASK,
+//     SIGHUP = SIGHUP,
+//     SIGINT = SIGINT,
+//     SIGQUIT = SIGQUIT,
+//     SIGILL = SIGILL,
+//     SIGTRAP = SIGTRAP,
+//     SIGABRT = SIGABRT,
+//     SIGIOT = SIGIOT,
+//     SIGBUS = SIGBUS,
+//     SIGFPE = SIGFPE,
+//     SIGKILL = SIGKILL,
+//     SIGUSR1 = SIGUSR1,
+//     SIGSEGV = SIGSEGV,
+//     SIGUSR2 = SIGUSR2,
+//     SIGPIPE = SIGPIPE,
+//     SIGALRM = SIGALRM,
+//     SIGTERM = SIGTERM,
+//     SIGSTKFLT = SIGSTKFLT,
+//     SIGCHLD = SIGCHLD,
+//     SIGCONT = SIGCONT,
+//     SIGSTOP = SIGSTOP,
+//     SIGTSTP = SIGTSTP,
+//     SIGTTIN = SIGTTIN,
+//     SIGTTOU = SIGTTOU,
+//     SIGURG = SIGURG,
+//     SIGXCPU = SIGXCPU,
+//     SIGXFSZ = SIGXFSZ,
+//     SIGVTALRM = SIGVTALRM,
+//     SIGPROF = SIGPROF,
+//     SIGWINCH = SIGWINCH,
+//     SIGIO = SIGIO,
+//     SIGPOLL = SIGPOLL,
+//     SIGPWR = SIGPWR,
+//     SIGSYS = SIGSYS,
+//     SIGUNUSED = SIGUNUSED,
+// }
+// 
+// impl Signal {
+//     pub fn from_u32(n: u32) -> Option<Self> {
+//         if n > NSIG {
+//             None
+//         } else {
+//             Some(unsafe { core::mem::transmute(n) })
+//         }
+//     }
+// }
+// 
+// bitflags! {
+//     pub struct SignalSet :u32 {
+//         const SIG_BLOCK = 1 << Signal::SIGBLOCK as usize;
+//     }
+// }
+// 
+// impl SignalSet {
+//     pub fn get_one(&self) -> Option<Signal> {
+//         let sig = self.bits().trailing_zeros();
+//         Signal::from_u32(sig)
+//     }
+// }
+// 
+// impl From<Signal> for SignalSet {
+//     fn from(sig: Signal) -> Self {
+//         Self::from_bits_retain(1 << sig as usize)
+//     }
+// }
+// 
+// pub enum SigHandler {
+//     Default,
+//     Ignore,
+//     Handler(unsafe extern "C" fn(i32)),
+// }
+// 
+// // 信号动作配置
+// pub struct SigAction {
+//     pub handler: SigHandler,
+//     pub mask: SignalSet,
+//     pub flags: i32,
+// }
+// 
+// #[naked]
+// #[no_mangle]
+// unsafe extern "C" fn sigreturn_trampoline() {
+//     // 内联汇编确保无函数前导/后导代码
+//     asm!(
+//         "li a7, {sysno}",
+//         "ecall",
+//         sysno = const Sysno::rt_sigreturn as usize,
+//         options(noreturn)
+//     );
+// }
+// 
+// /// 信号返回trampoline
+// global_asm!(
+//     r#"
+//     .global sigreturn_trampoline
+//     sigreturn_trampoline:
+//         li a7, {sys_sigreturn}
+//         ecall
+//     "#,
+//     sys_sigreturn = const Sysno::rt_sigreturn,
+// );
+// 
+// // 进程信号上下文
+// #[derive(Default)]
+// pub struct SignalContext {
+//     pub handlers: [SigAction; NSIG as usize], // 信号处理表
+//     pub blocked: SignalSet,                   // 被阻塞的信号
+//     pub pending: SignalSet,                   // 待处理信号
+// }
+// 
+// impl SignalContext {
+//     /// 向进程发送信号
+//     pub fn send_signal(&mut self, sig: Signal) {
+//         let mask = 1 << (sig as u8 - 1);
+// 
+//         // 如果信号未被阻塞，则加入待处理队列
+//         if !self.pending.contains(sig) {
+//             self.pending = self.pending.union(sig);
+//         }
+//     }
+// 
+//     /// 检查是否有待处理信号
+//     pub fn has_pending(&self) -> bool {
+//         self.pending == 0
+//     }
+// }
+// 
+// pub fn handle_pending_signals() {
+//     let current_task = current();
+//     let tast_ext = current_task.task_ext_mut();
+//     let mut ctx: SignalContext = tast_ext.sigctx;
+//     let curr_sp = tast_ext.uctx.get_sp();
+// 
+//     while ctx.has_pending() {
+//         // 找到最高优先级的待处理信号
+//         let sig = ctx.pending.get_one().unwrap();
+//         let sig_action = &ctx.handlers[sig as usize];
+// 
+//         match sig_action.handler {
+//             SigHandler::Default => handle_default_signal(sig, regs),
+//             SigHandler::Ignore => {} // 直接忽略
+//             SigHandler::Handler(handler) => {
+//                 // 设置信号处理栈帧
+//                 // WARN: 在syscall rt_sigreturn中清除信号。
+//                 unsafe { enter_signal_handler(&mut ctx, curr_sp, handler, sig) };
+//             }
+//         }
+// 
+//         // 清除已处理的信号
+//         ctx.pending.remove(sig);
+//     }
+// }
+// 
+// unsafe fn enter_signal_handler(
+//     sigctx: &mut SignalContext,
+//     ustack_top: usize,
+//     sig_action: SigAction,
+//     handler: unsafe extern "C" fn(i32),
+//     sig: i32,
+// ) -> ! {
+//     let curr = current();
+//     let sigctx = curr.task_ext().sigctx;
+//     // 设置用户处理函数上下文，栈接着原来的用户栈
+//     // 信号编号作为第一个参数
+//     let uctx = UspaceContext::new(handler as usize, ustack_top, sig as usize);
+// 
+//     // 跳转到处理函数
+//     uctx.set_ip(handler as usize);
+//     uctx.sepc = handler as usize;
+// 
+//     // 设置返回地址为信号返回trampoline
+//     regs.ra = sigreturn_trampoline as usize;
+// 
+//     // 设置信号屏蔽字
+//     let old_mask = current_task().signal_ctx.blocked;
+//     sigctx.blocked |= sig_action.mask;
+//     frame.saved_mask = old_mask;
+//     unsafe { uctx.enter_uspace(task.get_sig_stack_top()) };
+// }
+// 
+// fn enter_signal_handler(tf: &mut TrapFrame) {}
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"ALL\" />\n  </component>\n  <component name=\"CargoProjects\">\n    <cargoProject FILE=\"$PROJECT_DIR$/Cargo.toml\">\n      <package file=\"$PROJECT_DIR$/examples/helloworld\">\n        <enabledFeature name=\"default\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/examples/httpclient\">\n        <enabledFeature name=\"default\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/examples/httpserver\">\n        <enabledFeature name=\"default\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/examples/shell\">\n        <enabledFeature name=\"default\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/api/arceos_api\">\n        <enabledFeature name=\"default\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/api/arceos_posix_api\">\n        <enabledFeature name=\"default\" />\n        <enabledFeature name=\"pipe\" />\n        <enabledFeature name=\"alloc\" />\n        <enabledFeature name=\"net\" />\n        <enabledFeature name=\"fs\" />\n        <enabledFeature name=\"fd\" />\n        <enabledFeature name=\"axfs_devfs\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/modules/axalloc\">\n        <enabledFeature name=\"tlsf\" />\n        <enabledFeature name=\"default\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/modules/axconfig\">\n        <enabledFeature name=\"default\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/modules/axdisplay\">\n        <enabledFeature name=\"default\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/modules/axdma\">\n        <enabledFeature name=\"default\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/modules/axdriver\">\n        <enabledFeature name=\"ramdisk\" />\n        <enabledFeature name=\"axdriver_virtio\" />\n        <enabledFeature name=\"axdriver_block\" />\n        <enabledFeature name=\"default\" />\n        <enabledFeature name=\"virtio\" />\n        <enabledFeature name=\"virtio-net\" />\n        <enabledFeature name=\"axdriver_net\" />\n        <enabledFeature name=\"block\" />\n        <enabledFeature name=\"virtio-blk\" />\n        <enabledFeature name=\"net\" />\n        <enabledFeature name=\"bus-pci\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/api/axfeat\">\n        <enabledFeature name=\"default\" />\n        <enabledFeature name=\"multitask\" />\n        <enabledFeature name=\"axalloc\" />\n        <enabledFeature name=\"axdriver\" />\n        <enabledFeature name=\"axsync\" />\n        <enabledFeature name=\"irq\" />\n        <enabledFeature name=\"paging\" />\n        <enabledFeature name=\"axtask\" />\n        <enabledFeature name=\"alloc\" />\n        <enabledFeature name=\"net\" />\n        <enabledFeature name=\"fs\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/modules/axfs\">\n        <enabledFeature name=\"default\" />\n        <enabledFeature name=\"devfs\" />\n        <enabledFeature name=\"lwext4_rs\" />\n        <enabledFeature name=\"sysfs\" />\n        <enabledFeature name=\"procfs\" />\n        <enabledFeature name=\"fatfs\" />\n        <enabledFeature name=\"ramfs\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/modules/axhal\">\n        <enabledFeature name=\"fp_simd\" />\n        <enabledFeature name=\"irq\" />\n        <enabledFeature name=\"default\" />\n        <enabledFeature name=\"paging\" />\n        <enabledFeature name=\"page_table_multiarch\" />\n        <enabledFeature name=\"axalloc\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/ulib/axlibc\">\n        <enabledFeature name=\"default\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/modules/axlog\">\n        <enabledFeature name=\"default\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/modules/axmm\">\n        <enabledFeature name=\"default\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/ulib/axmono\">\n        <enabledFeature name=\"mm\" />\n        <enabledFeature name=\"axns\" />\n        <enabledFeature name=\"default\" />\n        <enabledFeature name=\"process\" />\n        <enabledFeature name=\"irq\" />\n        <enabledFeature name=\"axmm\" />\n        <enabledFeature name=\"axtask\" />\n        <enabledFeature name=\"syscalls\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/modules/axnet\">\n        <enabledFeature name=\"smoltcp\" />\n        <enabledFeature name=\"default\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/modules/axns\">\n        <enabledFeature name=\"default\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/modules/axruntime\">\n        <enabledFeature name=\"multitask\" />\n        <enabledFeature name=\"axdriver\" />\n        <enabledFeature name=\"percpu\" />\n        <enabledFeature name=\"axfs\" />\n        <enabledFeature name=\"axnet\" />\n        <enabledFeature name=\"irq\" />\n        <enabledFeature name=\"paging\" />\n        <enabledFeature name=\"axtask\" />\n        <enabledFeature name=\"fs\" />\n        <enabledFeature name=\"kernel_guard\" />\n        <enabledFeature name=\"default\" />\n        <enabledFeature name=\"axalloc\" />\n        <enabledFeature name=\"axmm\" />\n        <enabledFeature name=\"alloc\" />\n        <enabledFeature name=\"net\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/ulib/axstd\">\n        <enabledFeature name=\"default\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/modules/axsync\">\n        <enabledFeature name=\"default\" />\n        <enabledFeature name=\"multitask\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/modules/axsyscall\">\n        <enabledFeature name=\"default\" />\n        <enabledFeature name=\"pipe\" />\n        <enabledFeature name=\"fs\" />\n        <enabledFeature name=\"fd\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/modules/axtask\">\n        <enabledFeature name=\"default\" />\n        <enabledFeature name=\"multitask\" />\n        <enabledFeature name=\"test\" />\n        <enabledFeature name=\"irq\" />\n        <enabledFeature name=\"sched_rr\" />\n        <enabledFeature name=\"preempt\" />\n        <enabledFeature name=\"kernel_guard\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/crates/axmm_crates/memory_addr\">\n        <enabledFeature name=\"RAII\" />\n        <enabledFeature name=\"default\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/crates/axmm_crates/memory_set\">\n        <enabledFeature name=\"RAII\" />\n        <enabledFeature name=\"default\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/crates/page_table_multiarch/page_table_entry\">\n        <enabledFeature name=\"default\" />\n        <enabledFeature name=\"COW\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/crates/page_table_multiarch/page_table_multiarch\">\n        <enabledFeature name=\"default\" />\n      </package>\n    </cargoProject>\n    <cargoProject FILE=\"$PROJECT_DIR$/crates/axfs_crates/Cargo.toml\">\n      <package file=\"$PROJECT_DIR$/crates/axfs_crates/axfs_devfs\">\n        <enabledFeature name=\"default\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/crates/axfs_crates/axfs_ramfs\">\n        <enabledFeature name=\"default\" />\n      </package>\n      <package file=\"$PROJECT_DIR$/crates/axfs_crates/axfs_vfs\">\n        <enabledFeature name=\"default\" />\n      </package>\n    </cargoProject>\n    <cargoProject FILE=\"$PROJECT_DIR$/crates/lwext4_rust/Cargo.toml\" />\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"7c2d0aa3-ed80-457d-a6b3-f7e100db3c2a\" name=\"Changes\" comment=\"mmap first\">\n      <change afterPath=\"$PROJECT_DIR$/crates/axfs_crates\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/crates/lwext4_rust\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.gitmodules\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.gitmodules\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/vcs.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/vcs.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/Cargo.lock\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Cargo.lock\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/Cargo.toml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/Cargo.toml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/crates/axfs_crates/axfs_devfs/src/null.rs\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/crates/axfs_crates/axfs_devfs/src/null.rs\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/crates/axfs_crates/axfs_devfs/src/zero.rs\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/crates/axfs_crates/axfs_devfs/src/zero.rs\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/crates/axfs_crates/axfs_vfs/src/structs.rs\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/crates/axfs_crates/axfs_vfs/src/structs.rs\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/crates/axmm_crates\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/crates/axmm_crates\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/crates/lwext4_rust/Cargo.toml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/crates/lwext4_rust/Cargo.toml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/crates/lwext4_rust/src/file.rs\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/crates/lwext4_rust/src/file.rs\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/crates/page_table_multiarch\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/crates/page_table_multiarch\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/modules/axfs/src/fs/lwext4_rust.rs\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/modules/axfs/src/fs/lwext4_rust.rs\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"ExecutionTargetManager\" SELECTED_TARGET=\"RsBuildProfile:test\" />\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"Rust File\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n    <option name=\"RESET_MODE\" value=\"HARD\" />\n    <option name=\"ROOT_SYNC\" value=\"DONT_SYNC\" />\n  </component>\n  <component name=\"GitHubPullRequestSearchHistory\">{\n  &quot;lastFilter&quot;: {\n    &quot;state&quot;: &quot;OPEN&quot;,\n    &quot;assignee&quot;: &quot;MukioXun&quot;\n  }\n}</component>\n  <component name=\"GithubPullRequestsUISettings\">{\n  &quot;selectedUrlAndAccountId&quot;: {\n    &quot;url&quot;: &quot;https://github.com/LEOibyug/AstrancE.git&quot;,\n    &quot;accountId&quot;: &quot;b8310bd9-d15b-4168-9f82-542a2e619b11&quot;\n  }\n}</component>\n  <component name=\"MacroExpansionManager\">\n    <option name=\"directoryName\" value=\"DajqZso8\" />\n  </component>\n  <component name=\"ProblemsViewState\">\n    <option name=\"selectedTabId\" value=\"ProjectErrors\" />\n  </component>\n  <component name=\"ProjectColorInfo\">{\n  &quot;associatedIndex&quot;: 2\n}</component>\n  <component name=\"ProjectId\" id=\"2uLzxLJBHEfUP17HllVl1xXPOD3\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\"><![CDATA[{\n  \"keyToString\": {\n    \"Cargo.Test test::write (2).executor\": \"Run\",\n    \"Cargo.Test test::write (3).executor\": \"Run\",\n    \"Cargo.Test test::write.executor\": \"Run\",\n    \"ModuleVcsDetector.initialDetectionPerformed\": \"true\",\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\n    \"RunOnceActivity.git.unshallow\": \"true\",\n    \"RunOnceActivity.rust.reset.selective.auto.import\": \"true\",\n    \"Shell Script.RUN.executor\": \"Run\",\n    \"Shell Script.TRACE.executor\": \"Run\",\n    \"deletionFromPopupRequiresConfirmation\": \"false\",\n    \"git-widget-placeholder\": \"main\",\n    \"last_opened_file_path\": \"/root/App_oscomp\",\n    \"node.js.detected.package.eslint\": \"true\",\n    \"node.js.detected.package.tslint\": \"true\",\n    \"node.js.selected.package.eslint\": \"(autodetect)\",\n    \"node.js.selected.package.tslint\": \"(autodetect)\",\n    \"nodejs_package_manager_path\": \"npm\",\n    \"org.rust.cargo.project.model.PROJECT_DISCOVERY\": \"true\",\n    \"org.rust.cargo.project.model.impl.CargoExternalSystemProjectAware.subscribe.first.balloon\": \"\",\n    \"org.rust.disableDetachedFileInspection/root/AstrancE/modules/axsyscall/src/mod.rs\": \"true\",\n    \"org.rust.first.attach.projects\": \"true\",\n    \"org.rust.hideNoCargoProjectNotifications/root/AstrancE/crates/axfs_vfs/src/structs.rs\": \"true\",\n    \"run.code.analysis.last.selected.profile\": \"pProject Default\",\n    \"settings.editor.selected.configurable\": \"project.propVCSSupport.DirectoryMappings\",\n    \"vue.rearranger.settings.migration\": \"true\"\n  }\n}]]></component>\n  <component name=\"RdControllerToolWindowsLayoutState\" isNewUi=\"true\">\n    <layout>\n      <window_info id=\"Bookmarks\" side_tool=\"true\" />\n      <window_info id=\"Merge Requests\" />\n      <window_info id=\"Commit_Guest\" show_stripe_button=\"false\" />\n      <window_info content_ui=\"combo\" id=\"Project\" order=\"0\" sideWeight=\"0.8772831\" weight=\"0.21133502\" />\n      <window_info id=\"Commit\" order=\"1\" weight=\"0.16425215\" />\n      <window_info id=\"Structure\" order=\"2\" sideWeight=\"0.122716896\" side_tool=\"true\" weight=\"0.16386719\" />\n      <window_info id=\"Pull Requests\" order=\"3\" weight=\"0.16425215\" />\n      <window_info anchor=\"bottom\" id=\"Database Changes\" />\n      <window_info anchor=\"bottom\" id=\"TypeScript\" />\n      <window_info anchor=\"bottom\" id=\"Debug\" />\n      <window_info anchor=\"bottom\" id=\"File Transfer\" />\n      <window_info anchor=\"bottom\" id=\"Services\" order=\"0\" weight=\"0.28315586\" />\n      <window_info anchor=\"bottom\" id=\"Version Control\" order=\"1\" weight=\"0.43234444\" />\n      <window_info anchor=\"bottom\" id=\"Problems\" order=\"2\" />\n      <window_info anchor=\"bottom\" id=\"Problems View\" order=\"3\" weight=\"0.7528143\" />\n      <window_info active=\"true\" anchor=\"bottom\" id=\"Terminal\" order=\"4\" visible=\"true\" weight=\"0.34962407\" />\n      <window_info anchor=\"bottom\" id=\"Find\" order=\"5\" weight=\"0.32962245\" />\n      <window_info anchor=\"bottom\" id=\"Build\" order=\"6\" weight=\"0.4801013\" />\n      <window_info anchor=\"bottom\" id=\"Run\" order=\"7\" weight=\"0.47975707\" />\n      <window_info anchor=\"bottom\" id=\"Messages\" order=\"8\" weight=\"0.33113274\" />\n      <window_info anchor=\"bottom\" id=\"TODO\" order=\"9\" weight=\"0.33113274\" />\n      <window_info anchor=\"right\" id=\"Notifications\" order=\"0\" weight=\"0.32977617\" />\n      <window_info anchor=\"right\" id=\"AIAssistant\" order=\"1\" weight=\"0.32977617\" />\n      <window_info anchor=\"right\" id=\"Database\" order=\"2\" weight=\"0.32977617\" />\n      <window_info anchor=\"right\" id=\"Gradle\" order=\"3\" weight=\"0.25\" />\n      <window_info anchor=\"right\" id=\"Maven\" order=\"4\" weight=\"0.25\" />\n      <window_info anchor=\"right\" id=\"Cargo\" order=\"5\" weight=\"0.2\" />\n      <window_info anchor=\"right\" id=\"RustCargo\" order=\"6\" weight=\"0.26191407\" />\n      <window_info anchor=\"right\" id=\"Coverage\" order=\"7\" side_tool=\"true\" weight=\"0.32977617\" />\n      <window_info anchor=\"right\" id=\"Hierarchy\" order=\"8\" weight=\"0.32977617\" />\n      <window_info anchor=\"right\" id=\"documentation.v2\" order=\"9\" side_tool=\"true\" weight=\"0.32977617\" />\n    </layout>\n  </component>\n  <component name=\"RecentsManager\">\n    <key name=\"MoveFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$\" />\n      <recent name=\"$PROJECT_DIR$/modules/axsyscall\" />\n      <recent name=\"$PROJECT_DIR$/modules\" />\n    </key>\n  </component>\n  <component name=\"RunManager\" selected=\"Shell Script.RUN\">\n    <configuration name=\"RUN\" type=\"ShConfigurationType\">\n      <option name=\"SCRIPT_TEXT\" value=\"make build ARCH=riscv64 FEATURES=lwext4_rs,fs BLK=y BUS=mmio &amp;&amp; qemu-system-riscv64 -m 128M -smp 1 -machine virt -bios default -kernel ./App_oscomp_riscv64-qemu-virt.bin -device virtio-blk-device,drive=disk0 -drive id=disk0,if=none,format=raw,file=./testfolder/disk.img -nographic\" />\n      <option name=\"INDEPENDENT_SCRIPT_PATH\" value=\"true\" />\n      <option name=\"SCRIPT_PATH\" value=\"\" />\n      <option name=\"SCRIPT_OPTIONS\" value=\"\" />\n      <option name=\"INDEPENDENT_SCRIPT_WORKING_DIRECTORY\" value=\"true\" />\n      <option name=\"SCRIPT_WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/../App_oscomp\" />\n      <option name=\"INDEPENDENT_INTERPRETER_PATH\" value=\"true\" />\n      <option name=\"INTERPRETER_PATH\" value=\"/bin/bash\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"EXECUTE_IN_TERMINAL\" value=\"true\" />\n      <option name=\"EXECUTE_SCRIPT_FILE\" value=\"false\" />\n      <envs />\n      <method v=\"2\" />\n    </configuration>\n    <configuration name=\"TRACE\" type=\"ShConfigurationType\">\n      <option name=\"SCRIPT_TEXT\" value=\"make build ARCH=riscv64 FEATURES=lwext4_rs,fs BLK=y BUS=mmio LOG=trace &amp;&amp; qemu-system-riscv64 -m 128M -smp 1 -machine virt -bios default -kernel ./App_oscomp_riscv64-qemu-virt.bin -device virtio-blk-device,drive=disk0 -drive id=disk0,if=none,format=raw,file=./testfolder/disk.img -nographic\" />\n      <option name=\"INDEPENDENT_SCRIPT_PATH\" value=\"true\" />\n      <option name=\"SCRIPT_PATH\" value=\"\" />\n      <option name=\"SCRIPT_OPTIONS\" value=\"\" />\n      <option name=\"INDEPENDENT_SCRIPT_WORKING_DIRECTORY\" value=\"true\" />\n      <option name=\"SCRIPT_WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/../App_oscomp\" />\n      <option name=\"INDEPENDENT_INTERPRETER_PATH\" value=\"true\" />\n      <option name=\"INTERPRETER_PATH\" value=\"/bin/bash\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"EXECUTE_IN_TERMINAL\" value=\"true\" />\n      <option name=\"EXECUTE_SCRIPT_FILE\" value=\"false\" />\n      <envs />\n      <method v=\"2\" />\n    </configuration>\n    <list>\n      <item itemvalue=\"Shell Script.TRACE\" />\n      <item itemvalue=\"Shell Script.RUN\" />\n    </list>\n  </component>\n  <component name=\"RustProjectSettings\">\n    <option name=\"rustcTarget\" value=\"riscv64gc-unknown-linux-gnu\" />\n    <option name=\"toolchainHomeDirectory\" value=\"$PROJECT_DIR$/../.cargo/bin\" />\n  </component>\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"7c2d0aa3-ed80-457d-a6b3-f7e100db3c2a\" name=\"Changes\" comment=\"\" />\n      <created>1742042889401</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1742042889401</updated>\n      <workItem from=\"1742042891665\" duration=\"514000\" />\n      <workItem from=\"1742043474402\" duration=\"4469000\" />\n      <workItem from=\"1742136684927\" duration=\"5048000\" />\n      <workItem from=\"1742296527407\" duration=\"6622000\" />\n      <workItem from=\"1742310360980\" duration=\"2209000\" />\n      <workItem from=\"1742388100039\" duration=\"8031000\" />\n      <workItem from=\"1742472028007\" duration=\"1054000\" />\n      <workItem from=\"1742473550669\" duration=\"35000\" />\n      <workItem from=\"1742473606290\" duration=\"7233000\" />\n      <workItem from=\"1742536863696\" duration=\"59000\" />\n      <workItem from=\"1742622660475\" duration=\"476000\" />\n      <workItem from=\"1742629217270\" duration=\"372000\" />\n      <workItem from=\"1742654550182\" duration=\"3906000\" />\n      <workItem from=\"1742658489719\" duration=\"6429000\" />\n      <workItem from=\"1742706603379\" duration=\"12513000\" />\n      <workItem from=\"1742862824537\" duration=\"3489000\" />\n      <workItem from=\"1742889737826\" duration=\"4725000\" />\n      <workItem from=\"1742897634587\" duration=\"3267000\" />\n      <workItem from=\"1742921052388\" duration=\"2386000\" />\n      <workItem from=\"1743248599572\" duration=\"703000\" />\n      <workItem from=\"1743506175200\" duration=\"2701000\" />\n      <workItem from=\"1743603346208\" duration=\"159000\" />\n      <workItem from=\"1743603881055\" duration=\"72000\" />\n      <workItem from=\"1743604224227\" duration=\"1207000\" />\n      <workItem from=\"1743660010972\" duration=\"4972000\" />\n      <workItem from=\"1744282757997\" duration=\"3020000\" />\n      <workItem from=\"1744286534750\" duration=\"79000\" />\n      <workItem from=\"1744433966283\" duration=\"14793000\" />\n      <workItem from=\"1744457142784\" duration=\"7906000\" />\n      <workItem from=\"1744606930065\" duration=\"14444000\" />\n      <workItem from=\"1744648060740\" duration=\"909000\" />\n      <workItem from=\"1744717969881\" duration=\"3946000\" />\n      <workItem from=\"1744721964591\" duration=\"6517000\" />\n      <workItem from=\"1744773530505\" duration=\"1938000\" />\n      <workItem from=\"1744775783944\" duration=\"1871000\" />\n      <workItem from=\"1744816417516\" duration=\"215000\" />\n      <workItem from=\"1744816982644\" duration=\"4921000\" />\n      <workItem from=\"1744866329946\" duration=\"3523000\" />\n      <workItem from=\"1745133474584\" duration=\"928000\" />\n      <workItem from=\"1745165234651\" duration=\"656000\" />\n      <workItem from=\"1745394975032\" duration=\"9068000\" />\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"Changes\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1742046140049</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1742046140049</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"将handler的返回类型改为Result便于错误处理与返回\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1742047892333</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1742047892333</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"change\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1742048069017</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1742048069017</updated>\n    </task>\n    <task id=\"LOCAL-00004\" summary=\"time相关添加\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1742142951501</created>\n      <option name=\"number\" value=\"00004\" />\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1742142951502</updated>\n    </task>\n    <task id=\"LOCAL-00005\" summary=\"优化目录结构\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1742298843331</created>\n      <option name=\"number\" value=\"00005\" />\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1742298843331</updated>\n    </task>\n    <task id=\"LOCAL-00006\" summary=\"优化目录结构\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1742301211648</created>\n      <option name=\"number\" value=\"00006\" />\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1742301211648</updated>\n    </task>\n    <task id=\"LOCAL-00007\" summary=\"完善net部分\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1742302124594</created>\n      <option name=\"number\" value=\"00007\" />\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1742302124594</updated>\n    </task>\n    <task id=\"LOCAL-00008\" summary=\"完善\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1742302207629</created>\n      <option name=\"number\" value=\"00008\" />\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1742302207629</updated>\n    </task>\n    <task id=\"LOCAL-00009\" summary=\"完善\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1742395544505</created>\n      <option name=\"number\" value=\"00009\" />\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1742395544505</updated>\n    </task>\n    <task id=\"LOCAL-00010\" summary=\"完善feature控制\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1742483177322</created>\n      <option name=\"number\" value=\"00010\" />\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1742483177322</updated>\n    </task>\n    <task id=\"LOCAL-00011\" summary=\"消除了syscall部分对于std的依赖，增添syscall_func的feature控制\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1742655700944</created>\n      <option name=\"number\" value=\"00011\" />\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1742655700944</updated>\n    </task>\n    <task id=\"LOCAL-00012\" summary=\"完善错误反馈机制\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1742660836210</created>\n      <option name=\"number\" value=\"00012\" />\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1742660836210</updated>\n    </task>\n    <task id=\"LOCAL-00013\" summary=\"完善了feature控制，使得syscall中的feature能控制zpi中的feature，完善了文件相关的系统调用\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1742713890476</created>\n      <option name=\"number\" value=\"00013\" />\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1742713890476</updated>\n    </task>\n    <task id=\"LOCAL-00014\" summary=\"修改了函数名，完善系统调用\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1742866288263</created>\n      <option name=\"number\" value=\"00014\" />\n      <option name=\"presentableId\" value=\"LOCAL-00014\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1742866288263</updated>\n    </task>\n    <task id=\"LOCAL-00015\" summary=\"mmap first\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1744284521845</created>\n      <option name=\"number\" value=\"00015\" />\n      <option name=\"presentableId\" value=\"LOCAL-00015\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1744284521845</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"16\" />\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"UnknownFeatures\">\n    <option featureType=\"com.intellij.fileTypeFactory\" implementationName=\".bashrc\" />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"RECENT_FILTERS\">\n      <map>\n        <entry key=\"Branch\">\n          <value>\n            <list>\n              <RecentGroup>\n                <option name=\"FILTER_VALUES\">\n                  <option value=\"dev_ycy\" />\n                </option>\n              </RecentGroup>\n              <RecentGroup>\n                <option name=\"FILTER_VALUES\">\n                  <option value=\"main\" />\n                </option>\n              </RecentGroup>\n              <RecentGroup>\n                <option name=\"FILTER_VALUES\">\n                  <option value=\"origin/main\" />\n                </option>\n              </RecentGroup>\n            </list>\n          </value>\n        </entry>\n      </map>\n    </option>\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State>\n              <option name=\"FILTERS\">\n                <map>\n                  <entry key=\"branch\">\n                    <value>\n                      <list>\n                        <option value=\"main\" />\n                      </list>\n                    </value>\n                  </entry>\n                </map>\n              </option>\n            </State>\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <MESSAGE value=\"Changes\" />\n    <MESSAGE value=\"将handler的返回类型改为Result便于错误处理与返回\" />\n    <MESSAGE value=\"change\" />\n    <MESSAGE value=\"time相关添加\" />\n    <MESSAGE value=\"优化目录结构\" />\n    <MESSAGE value=\"完善net部分\" />\n    <MESSAGE value=\"完善\" />\n    <MESSAGE value=\"完善feature控制\" />\n    <MESSAGE value=\"消除了syscall部分对于std的依赖，增添syscall_func的feature控制\" />\n    <MESSAGE value=\"完善错误反馈机制\" />\n    <MESSAGE value=\"完善了feature控制，使得syscall中的feature能控制zpi中的feature，完善了文件相关的系统调用\" />\n    <MESSAGE value=\"修改了函数名，完善系统调用\" />\n    <MESSAGE value=\"mmap first\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"mmap first\" />\n  </component>\n  <component name=\"XSLT-Support.FileAssociations.UIState\">\n    <expand />\n    <select />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/.idea/workspace.xml	(date 1747546120000)
@@ -28,12 +28,16 @@
         <enabledFeature name="fs" />
         <enabledFeature name="fd" />
         <enabledFeature name="axfs_devfs" />
+        <enabledFeature name="uspace" />
       </package>
       <package file="$PROJECT_DIR$/modules/axalloc">
         <enabledFeature name="tlsf" />
         <enabledFeature name="default" />
       </package>
       <package file="$PROJECT_DIR$/modules/axconfig">
+        <enabledFeature name="default" />
+      </package>
+      <package file="$PROJECT_DIR$/modules/axdevice">
         <enabledFeature name="default" />
       </package>
       <package file="$PROJECT_DIR$/modules/axdisplay">
@@ -54,6 +58,24 @@
         <enabledFeature name="virtio-blk" />
         <enabledFeature name="net" />
         <enabledFeature name="bus-pci" />
+      </package>
+      <package file="$PROJECT_DIR$/crates/axdriver_crates/axdriver_base">
+        <enabledFeature name="default" />
+      </package>
+      <package file="$PROJECT_DIR$/crates/axdriver_crates/axdriver_block">
+        <enabledFeature name="default" />
+      </package>
+      <package file="$PROJECT_DIR$/crates/axdriver_crates/axdriver_display">
+        <enabledFeature name="default" />
+      </package>
+      <package file="$PROJECT_DIR$/crates/axdriver_crates/axdriver_net">
+        <enabledFeature name="default" />
+      </package>
+      <package file="$PROJECT_DIR$/crates/axdriver_crates/axdriver_pci">
+        <enabledFeature name="default" />
+      </package>
+      <package file="$PROJECT_DIR$/crates/axdriver_crates/axdriver_virtio">
+        <enabledFeature name="default" />
       </package>
       <package file="$PROJECT_DIR$/api/axfeat">
         <enabledFeature name="default" />
@@ -63,6 +85,7 @@
         <enabledFeature name="axsync" />
         <enabledFeature name="irq" />
         <enabledFeature name="paging" />
+        <enabledFeature name="tls" />
         <enabledFeature name="axtask" />
         <enabledFeature name="alloc" />
         <enabledFeature name="net" />
@@ -96,6 +119,7 @@
       </package>
       <package file="$PROJECT_DIR$/ulib/axmono">
         <enabledFeature name="mm" />
+        <enabledFeature name="sig" />
         <enabledFeature name="axns" />
         <enabledFeature name="default" />
         <enabledFeature name="process" />
@@ -138,6 +162,7 @@
       <package file="$PROJECT_DIR$/modules/axsyscall">
         <enabledFeature name="default" />
         <enabledFeature name="pipe" />
+        <enabledFeature name="multitask" />
         <enabledFeature name="fs" />
         <enabledFeature name="fd" />
       </package>
@@ -178,24 +203,78 @@
       </package>
     </cargoProject>
     <cargoProject FILE="$PROJECT_DIR$/crates/lwext4_rust/Cargo.toml" />
+    <cargoProject FILE="$PROJECT_DIR$/crates/page_table_multiarch/Cargo.toml">
+      <package file="$PROJECT_DIR$/crates/page_table_multiarch/page_table_entry">
+        <enabledFeature name="default" />
+      </package>
+      <package file="$PROJECT_DIR$/crates/page_table_multiarch/page_table_multiarch">
+        <enabledFeature name="default" />
+      </package>
+    </cargoProject>
+    <cargoProject FILE="$PROJECT_DIR$/crates/axdriver_crates/Cargo.toml">
+      <package file="$PROJECT_DIR$/crates/axdriver_crates/axdriver_base">
+        <enabledFeature name="default" />
+      </package>
+      <package file="$PROJECT_DIR$/crates/axdriver_crates/axdriver_block">
+        <enabledFeature name="default" />
+      </package>
+      <package file="$PROJECT_DIR$/crates/axdriver_crates/axdriver_display">
+        <enabledFeature name="default" />
+      </package>
+      <package file="$PROJECT_DIR$/crates/axdriver_crates/axdriver_net">
+        <enabledFeature name="default" />
+      </package>
+      <package file="$PROJECT_DIR$/crates/axdriver_crates/axdriver_pci">
+        <enabledFeature name="default" />
+      </package>
+      <package file="$PROJECT_DIR$/crates/axdriver_crates/axdriver_virtio">
+        <enabledFeature name="default" />
+      </package>
+    </cargoProject>
   </component>
   <component name="ChangeListManager">
     <list default="true" id="7c2d0aa3-ed80-457d-a6b3-f7e100db3c2a" name="Changes" comment="mmap first">
-      <change afterPath="$PROJECT_DIR$/crates/axfs_crates" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/crates/lwext4_rust" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/crates/axdriver_crates" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/crates/axfs_crates/axfs_devfs/src/chrdev.rs" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/modules/axdevice/src/disk.rs" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/modules/axdevice/src/disk_file.rs" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/modules/axfs/src/blkdev.rs" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.gitmodules" beforeDir="false" afterPath="$PROJECT_DIR$/.gitmodules" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/vcs.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/vcs.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/Cargo.lock" beforeDir="false" afterPath="$PROJECT_DIR$/Cargo.lock" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/Cargo.toml" beforeDir="false" afterPath="$PROJECT_DIR$/Cargo.toml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/crates/axfs_crates/axfs_devfs/src/null.rs" beforeDir="false" afterPath="$PROJECT_DIR$/crates/axfs_crates/axfs_devfs/src/null.rs" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/crates/axfs_crates/axfs_devfs/src/zero.rs" beforeDir="false" afterPath="$PROJECT_DIR$/crates/axfs_crates/axfs_devfs/src/zero.rs" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/api/arceos_posix_api/src/imp/fs.rs" beforeDir="false" afterPath="$PROJECT_DIR$/api/arceos_posix_api/src/imp/fs.rs" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/api/arceos_posix_api/src/lib.rs" beforeDir="false" afterPath="$PROJECT_DIR$/api/arceos_posix_api/src/lib.rs" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/crates/axdriver_crates/axdriver_base/Cargo.toml" beforeDir="false" afterPath="$PROJECT_DIR$/crates/axdriver_crates/axdriver_base/Cargo.toml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/crates/axdriver_crates/axdriver_block/src/lib.rs" beforeDir="false" afterPath="$PROJECT_DIR$/crates/axdriver_crates/axdriver_block/src/lib.rs" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/crates/axdriver_crates/axdriver_block/src/ramdisk.rs" beforeDir="false" afterPath="$PROJECT_DIR$/crates/axdriver_crates/axdriver_block/src/ramdisk.rs" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/crates/axdriver_crates/axdriver_virtio/src/blk.rs" beforeDir="false" afterPath="$PROJECT_DIR$/crates/axdriver_crates/axdriver_virtio/src/blk.rs" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/crates/axfs_crates" beforeDir="false" afterPath="$PROJECT_DIR$/crates/axfs_crates" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/crates/axfs_crates/axfs_devfs/src/dir.rs" beforeDir="false" afterPath="$PROJECT_DIR$/crates/axfs_crates/axfs_devfs/src/dir.rs" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/crates/axfs_crates/axfs_devfs/src/lib.rs" beforeDir="false" afterPath="$PROJECT_DIR$/crates/axfs_crates/axfs_devfs/src/lib.rs" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/crates/axfs_crates/axfs_vfs/src/lib.rs" beforeDir="false" afterPath="$PROJECT_DIR$/crates/axfs_crates/axfs_vfs/src/lib.rs" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/crates/axfs_crates/axfs_vfs/src/structs.rs" beforeDir="false" afterPath="$PROJECT_DIR$/crates/axfs_crates/axfs_vfs/src/structs.rs" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/crates/axmm_crates" beforeDir="false" afterPath="$PROJECT_DIR$/crates/axmm_crates" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/crates/lwext4_rust/Cargo.toml" beforeDir="false" afterPath="$PROJECT_DIR$/crates/lwext4_rust/Cargo.toml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/crates/lwext4_rust/src/file.rs" beforeDir="false" afterPath="$PROJECT_DIR$/crates/lwext4_rust/src/file.rs" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/crates/page_table_multiarch" beforeDir="false" afterPath="$PROJECT_DIR$/crates/page_table_multiarch" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/crates/lwext4_rust" beforeDir="false" afterPath="$PROJECT_DIR$/crates/lwext4_rust" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/crates/lwext4_rust/c/lwext4" beforeDir="false" afterPath="$PROJECT_DIR$/crates/lwext4_rust/c/lwext4" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/crates/lwext4_rust/c/lwext4/CMakeLists.txt" beforeDir="false" afterPath="$PROJECT_DIR$/crates/lwext4_rust/c/lwext4/CMakeLists.txt" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/crates/lwext4_rust/c/lwext4/Makefile" beforeDir="false" afterPath="$PROJECT_DIR$/crates/lwext4_rust/c/lwext4/Makefile" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/crates/lwext4_rust/c/lwext4/src/CMakeLists.txt" beforeDir="false" afterPath="$PROJECT_DIR$/crates/lwext4_rust/c/lwext4/src/CMakeLists.txt" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/modules/axdriver/Cargo.toml" beforeDir="false" afterPath="$PROJECT_DIR$/modules/axdriver/Cargo.toml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/modules/axfs/Cargo.toml" beforeDir="false" afterPath="$PROJECT_DIR$/modules/axfs/Cargo.toml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/modules/axfs/src/dev.rs" beforeDir="false" afterPath="$PROJECT_DIR$/modules/axfs/src/dev.rs" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/modules/axfs/src/fs/fatfs.rs" beforeDir="false" afterPath="$PROJECT_DIR$/modules/axfs/src/fs/fatfs.rs" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/modules/axfs/src/fs/lwext4_rust.rs" beforeDir="false" afterPath="$PROJECT_DIR$/modules/axfs/src/fs/lwext4_rust.rs" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/modules/axfs/src/lib.rs" beforeDir="false" afterPath="$PROJECT_DIR$/modules/axfs/src/lib.rs" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/modules/axfs/src/mounts.rs" beforeDir="false" afterPath="$PROJECT_DIR$/modules/axfs/src/mounts.rs" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/modules/axfs/src/root.rs" beforeDir="false" afterPath="$PROJECT_DIR$/modules/axfs/src/root.rs" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/modules/axsyscall/Cargo.toml" beforeDir="false" afterPath="$PROJECT_DIR$/modules/axsyscall/Cargo.toml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/modules/axsyscall/src/syscall_imp/fs.rs" beforeDir="false" afterPath="$PROJECT_DIR$/modules/axsyscall/src/syscall_imp/fs.rs" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/ulib/axmono/Cargo.toml" beforeDir="false" afterPath="$PROJECT_DIR$/ulib/axmono/Cargo.toml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/ulib/axmono/src/ctypes.rs" beforeDir="false" afterPath="$PROJECT_DIR$/ulib/axmono/src/ctypes.rs" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/ulib/axmono/src/lib.rs" beforeDir="false" afterPath="$PROJECT_DIR$/ulib/axmono/src/lib.rs" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/ulib/axmono/src/task/mod.rs" beforeDir="false" afterPath="$PROJECT_DIR$/ulib/axmono/src/task/mod.rs" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/ulib/axmono/src/task/signal.rs" beforeDir="false" afterPath="$PROJECT_DIR$/ulib/axmono/src/task/signal.rs" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -241,41 +320,44 @@
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent"><![CDATA[{
-  "keyToString": {
-    "Cargo.Test test::write (2).executor": "Run",
-    "Cargo.Test test::write (3).executor": "Run",
-    "Cargo.Test test::write.executor": "Run",
-    "ModuleVcsDetector.initialDetectionPerformed": "true",
-    "RunOnceActivity.ShowReadmeOnStart": "true",
-    "RunOnceActivity.git.unshallow": "true",
-    "RunOnceActivity.rust.reset.selective.auto.import": "true",
-    "Shell Script.RUN.executor": "Run",
-    "Shell Script.TRACE.executor": "Run",
-    "deletionFromPopupRequiresConfirmation": "false",
-    "git-widget-placeholder": "main",
-    "last_opened_file_path": "/root/App_oscomp",
-    "node.js.detected.package.eslint": "true",
-    "node.js.detected.package.tslint": "true",
-    "node.js.selected.package.eslint": "(autodetect)",
-    "node.js.selected.package.tslint": "(autodetect)",
-    "nodejs_package_manager_path": "npm",
-    "org.rust.cargo.project.model.PROJECT_DISCOVERY": "true",
-    "org.rust.cargo.project.model.impl.CargoExternalSystemProjectAware.subscribe.first.balloon": "",
-    "org.rust.disableDetachedFileInspection/root/AstrancE/modules/axsyscall/src/mod.rs": "true",
-    "org.rust.first.attach.projects": "true",
-    "org.rust.hideNoCargoProjectNotifications/root/AstrancE/crates/axfs_vfs/src/structs.rs": "true",
-    "run.code.analysis.last.selected.profile": "pProject Default",
-    "settings.editor.selected.configurable": "project.propVCSSupport.DirectoryMappings",
-    "vue.rearranger.settings.migration": "true"
+  <component name="PropertiesComponent">{
+  &quot;keyToString&quot;: {
+    &quot;Cargo.Test test::write (2).executor&quot;: &quot;Run&quot;,
+    &quot;Cargo.Test test::write (3).executor&quot;: &quot;Run&quot;,
+    &quot;Cargo.Test test::write.executor&quot;: &quot;Run&quot;,
+    &quot;ModuleVcsDetector.initialDetectionPerformed&quot;: &quot;true&quot;,
+    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
+    &quot;RunOnceActivity.git.unshallow&quot;: &quot;true&quot;,
+    &quot;RunOnceActivity.rust.reset.selective.auto.import&quot;: &quot;true&quot;,
+    &quot;Shell Script.RUN.executor&quot;: &quot;Run&quot;,
+    &quot;Shell Script.TRACE.executor&quot;: &quot;Run&quot;,
+    &quot;deletionFromPopupRequiresConfirmation&quot;: &quot;false&quot;,
+    &quot;git-widget-placeholder&quot;: &quot;main&quot;,
+    &quot;last_opened_file_path&quot;: &quot;/root/App_oscomp&quot;,
+    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
+    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
+    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
+    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
+    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,
+    &quot;org.rust.cargo.project.model.PROJECT_DISCOVERY&quot;: &quot;true&quot;,
+    &quot;org.rust.cargo.project.model.impl.CargoExternalSystemProjectAware.subscribe.first.balloon&quot;: &quot;&quot;,
+    &quot;org.rust.disableDetachedFileInspection/root/AstrancE/modules/axdevice/src/disk.rs&quot;: &quot;true&quot;,
+    &quot;org.rust.disableDetachedFileInspection/root/AstrancE/modules/axdevice/src/mod.rs&quot;: &quot;true&quot;,
+    &quot;org.rust.disableDetachedFileInspection/root/AstrancE/modules/axsyscall/src/mod.rs&quot;: &quot;true&quot;,
+    &quot;org.rust.first.attach.projects&quot;: &quot;true&quot;,
+    &quot;org.rust.hideNoCargoProjectNotifications/root/AstrancE/crates/axfs_vfs/src/structs.rs&quot;: &quot;true&quot;,
+    &quot;run.code.analysis.last.selected.profile&quot;: &quot;pProject Default&quot;,
+    &quot;settings.editor.selected.configurable&quot;: &quot;project.propVCSSupport.DirectoryMappings&quot;,
+    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
   }
-}]]></component>
+}</component>
   <component name="RdControllerToolWindowsLayoutState" isNewUi="true">
     <layout>
       <window_info id="Bookmarks" side_tool="true" />
       <window_info id="Merge Requests" />
+      <window_info id="Backup and Sync History" />
       <window_info id="Commit_Guest" show_stripe_button="false" />
-      <window_info content_ui="combo" id="Project" order="0" sideWeight="0.8772831" weight="0.21133502" />
+      <window_info active="true" content_ui="combo" id="Project" order="0" sideWeight="0.8772831" visible="true" weight="0.11660156" />
       <window_info id="Commit" order="1" weight="0.16425215" />
       <window_info id="Structure" order="2" sideWeight="0.122716896" side_tool="true" weight="0.16386719" />
       <window_info id="Pull Requests" order="3" weight="0.16425215" />
@@ -283,14 +365,14 @@
       <window_info anchor="bottom" id="TypeScript" />
       <window_info anchor="bottom" id="Debug" />
       <window_info anchor="bottom" id="File Transfer" />
-      <window_info anchor="bottom" id="Services" order="0" weight="0.28315586" />
-      <window_info anchor="bottom" id="Version Control" order="1" weight="0.43234444" />
+      <window_info anchor="bottom" id="Services" order="0" weight="0.1914524" />
+      <window_info anchor="bottom" id="Version Control" order="1" weight="0.18936762" />
       <window_info anchor="bottom" id="Problems" order="2" />
-      <window_info anchor="bottom" id="Problems View" order="3" weight="0.7528143" />
-      <window_info active="true" anchor="bottom" id="Terminal" order="4" visible="true" weight="0.34962407" />
-      <window_info anchor="bottom" id="Find" order="5" weight="0.32962245" />
-      <window_info anchor="bottom" id="Build" order="6" weight="0.4801013" />
-      <window_info anchor="bottom" id="Run" order="7" weight="0.47975707" />
+      <window_info anchor="bottom" id="Problems View" order="3" weight="0.38522887" />
+      <window_info active="true" anchor="bottom" id="Terminal" order="4" visible="true" weight="0.11889368" />
+      <window_info anchor="bottom" id="Find" order="5" weight="0.63685346" />
+      <window_info anchor="bottom" id="Build" order="6" weight="0.14474976" />
+      <window_info anchor="bottom" id="Run" order="7" weight="0.6487051" />
       <window_info anchor="bottom" id="Messages" order="8" weight="0.33113274" />
       <window_info anchor="bottom" id="TODO" order="9" weight="0.33113274" />
       <window_info anchor="right" id="Notifications" order="0" weight="0.32977617" />
@@ -299,17 +381,19 @@
       <window_info anchor="right" id="Gradle" order="3" weight="0.25" />
       <window_info anchor="right" id="Maven" order="4" weight="0.25" />
       <window_info anchor="right" id="Cargo" order="5" weight="0.2" />
-      <window_info anchor="right" id="RustCargo" order="6" weight="0.26191407" />
+      <window_info anchor="right" id="RustCargo" order="6" weight="0.33011132" />
       <window_info anchor="right" id="Coverage" order="7" side_tool="true" weight="0.32977617" />
       <window_info anchor="right" id="Hierarchy" order="8" weight="0.32977617" />
-      <window_info anchor="right" id="documentation.v2" order="9" side_tool="true" weight="0.32977617" />
+      <window_info anchor="right" id="documentation.v2" order="9" side_tool="true" weight="0.3298828" />
     </layout>
   </component>
   <component name="RecentsManager">
     <key name="MoveFile.RECENT_KEYS">
+      <recent name="$PROJECT_DIR$/modules/axfs/src" />
+      <recent name="$PROJECT_DIR$/crates/axfs_crates/axfs_devfs/src" />
+      <recent name="$PROJECT_DIR$/api/arceos_posix_api/src" />
       <recent name="$PROJECT_DIR$" />
       <recent name="$PROJECT_DIR$/modules/axsyscall" />
-      <recent name="$PROJECT_DIR$/modules" />
     </key>
   </component>
   <component name="RunManager" selected="Shell Script.RUN">
@@ -399,7 +483,25 @@
       <workItem from="1744866329946" duration="3523000" />
       <workItem from="1745133474584" duration="928000" />
       <workItem from="1745165234651" duration="656000" />
-      <workItem from="1745394975032" duration="9068000" />
+      <workItem from="1745394975032" duration="15419000" />
+      <workItem from="1745586725831" duration="8079000" />
+      <workItem from="1745595080321" duration="2501000" />
+      <workItem from="1745637522470" duration="12769000" />
+      <workItem from="1745852279644" duration="1546000" />
+      <workItem from="1745893986348" duration="37858000" />
+      <workItem from="1746618868692" duration="19170000" />
+      <workItem from="1746801754504" duration="550000" />
+      <workItem from="1746869176385" duration="12882000" />
+      <workItem from="1746937842847" duration="9580000" />
+      <workItem from="1746979302210" duration="7032000" />
+      <workItem from="1747019771770" duration="2879000" />
+      <workItem from="1747030262407" duration="14152000" />
+      <workItem from="1747124648681" duration="20899000" />
+      <workItem from="1747191044704" duration="5981000" />
+      <workItem from="1747219936598" duration="15391000" />
+      <workItem from="1747320391882" duration="8951000" />
+      <workItem from="1747407541046" duration="2370000" />
+      <workItem from="1747545113964" duration="1006000" />
     </task>
     <task id="LOCAL-00001" summary="Changes">
       <option name="closed" value="true" />
@@ -531,6 +633,11 @@
     <option featureType="com.intellij.fileTypeFactory" implementationName=".bashrc" />
   </component>
   <component name="Vcs.Log.Tabs.Properties">
+    <option name="OPEN_GENERIC_TABS">
+      <map>
+        <entry key="cf93c5cc-c414-48b7-8f92-b1d72b8352a5" value="TOOL_WINDOW" />
+      </map>
+    </option>
     <option name="RECENT_FILTERS">
       <map>
         <entry key="Branch">
@@ -566,13 +673,18 @@
                   <entry key="branch">
                     <value>
                       <list>
-                        <option value="main" />
+                        <option value="Qix/HEAD" />
                       </list>
                     </value>
                   </entry>
                 </map>
               </option>
             </State>
+          </value>
+        </entry>
+        <entry key="cf93c5cc-c414-48b7-8f92-b1d72b8352a5">
+          <value>
+            <State />
           </value>
         </entry>
       </map>
Index: modules/axdriver/Cargo.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[package]\nname = \"axdriver\"\nversion.workspace = true\nedition.workspace = true\nauthors = [\"Yuekai Jia <equation618@gmail.com>\", \"ChengXiang Qi <kuangjux@outlook.com>\"]\ndescription = \"ArceOS device drivers\"\nlicense.workspace = true\nhomepage.workspace = true\nrepository = \"https://github.com/arceos-org/arceos/tree/main/modules/axdriver\"\ndocumentation = \"https://arceos-org.github.io/arceos/axdriver/index.html\"\n\n[features]\ndyn = []\nbus-mmio = []\nbus-pci = [\"dep:axdriver_pci\", \"dep:axhal\", \"dep:axconfig\"]\nnet = [\"axdriver_net\"]\nblock = [\"axdriver_block\"]\ndisplay = [\"axdriver_display\"]\n\n# Enabled by features `virtio-*`\nvirtio = [\"axdriver_virtio\", \"dep:axalloc\", \"dep:axhal\", \"dep:axconfig\"]\n\n# various types of drivers\nvirtio-blk = [\"block\", \"virtio\", \"axdriver_virtio/block\"]\nvirtio-net = [\"net\", \"virtio\", \"axdriver_virtio/net\"]\nvirtio-gpu = [\"display\", \"virtio\", \"axdriver_virtio/gpu\"]\nramdisk = [\"block\", \"axdriver_block/ramdisk\"]\nbcm2835-sdhci = [\"block\", \"axdriver_block/bcm2835-sdhci\"]\nixgbe = [\"net\", \"axdriver_net/ixgbe\", \"dep:axalloc\", \"dep:axhal\", \"dep:axdma\"]\nfxmac = [\"net\", \"axdriver_net/fxmac\", \"dep:axalloc\", \"dep:axhal\", \"dep:axdma\"]\n# more devices example: e1000 = [\"net\", \"axdriver_net/e1000\"]\n\ndefault = [\"bus-pci\"]\n\n[dependencies]\nlog = \"=0.4.21\"\ncfg-if = \"1.0\"\ncrate_interface = \"0.1.4\"\naxdriver_base = { git = \"https://github.com/arceos-org/axdriver_crates.git\", tag = \"v0.1.2\" }\naxdriver_block = { git = \"https://github.com/arceos-org/axdriver_crates.git\", tag = \"v0.1.2\", optional = true }\naxdriver_net = { git = \"https://github.com/arceos-org/axdriver_crates.git\", tag = \"v0.1.2\", optional = true }\naxdriver_display = { git = \"https://github.com/arceos-org/axdriver_crates.git\", tag = \"v0.1.2\", optional = true }\naxdriver_pci = { git = \"https://github.com/arceos-org/axdriver_crates.git\", tag = \"v0.1.2\", optional = true }\naxdriver_virtio = { git = \"https://github.com/arceos-org/axdriver_crates.git\", tag = \"v0.1.2\", optional = true }\naxalloc = { workspace = true, optional = true }\naxhal = { workspace = true, optional = true }\naxconfig = { workspace = true, optional = true }\naxdma = { workspace = true, optional = true }\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/modules/axdriver/Cargo.toml b/modules/axdriver/Cargo.toml
--- a/modules/axdriver/Cargo.toml	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/modules/axdriver/Cargo.toml	(date 1747220749885)
@@ -36,12 +36,18 @@
 log = "=0.4.21"
 cfg-if = "1.0"
 crate_interface = "0.1.4"
-axdriver_base = { git = "https://github.com/arceos-org/axdriver_crates.git", tag = "v0.1.2" }
-axdriver_block = { git = "https://github.com/arceos-org/axdriver_crates.git", tag = "v0.1.2", optional = true }
-axdriver_net = { git = "https://github.com/arceos-org/axdriver_crates.git", tag = "v0.1.2", optional = true }
-axdriver_display = { git = "https://github.com/arceos-org/axdriver_crates.git", tag = "v0.1.2", optional = true }
-axdriver_pci = { git = "https://github.com/arceos-org/axdriver_crates.git", tag = "v0.1.2", optional = true }
-axdriver_virtio = { git = "https://github.com/arceos-org/axdriver_crates.git", tag = "v0.1.2", optional = true }
+#axdriver_base = { git = "https://github.com/arceos-org/axdriver_crates.git", tag = "v0.1.2" }
+#axdriver_block = { git = "https://github.com/arceos-org/axdriver_crates.git", tag = "v0.1.2", optional = true }
+#axdriver_net = { git = "https://github.com/arceos-org/axdriver_crates.git", tag = "v0.1.2", optional = true }
+#axdriver_display = { git = "https://github.com/arceos-org/axdriver_crates.git", tag = "v0.1.2", optional = true }
+#axdriver_pci = { git = "https://github.com/arceos-org/axdriver_crates.git", tag = "v0.1.2", optional = true }
+#axdriver_virtio = { git = "https://github.com/arceos-org/axdriver_crates.git", tag = "v0.1.2", optional = true }
+axdriver_base = { workspace = true, tag = "v0.1.2" }
+axdriver_block = { workspace = true, tag = "v0.1.2", optional = true }
+axdriver_net = { workspace = true, tag = "v0.1.2", optional = true }
+axdriver_display = { workspace = true, tag = "v0.1.2", optional = true }
+axdriver_pci = { workspace = true, tag = "v0.1.2", optional = true }
+axdriver_virtio = { workspace = true, tag = "v0.1.2", optional = true }
 axalloc = { workspace = true, optional = true }
 axhal = { workspace = true, optional = true }
 axconfig = { workspace = true, optional = true }
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"VcsDirectoryMappings\">\n    <mapping directory=\"$PROJECT_DIR$\" vcs=\"Git\" />\n    <mapping directory=\"$PROJECT_DIR$/crates/axfs_crates\" vcs=\"Git\" />\n    <mapping directory=\"$PROJECT_DIR$/crates/axfs_vfs\" vcs=\"Git\" />\n    <mapping directory=\"$PROJECT_DIR$/crates/axmm_crates\" vcs=\"Git\" />\n    <mapping directory=\"$PROJECT_DIR$/crates/lwext4_rust\" vcs=\"Git\" />\n    <mapping directory=\"$PROJECT_DIR$/crates/lwext4_rust/c/lwext4\" vcs=\"Git\" />\n    <mapping directory=\"$PROJECT_DIR$/crates/page_table_multiarch\" vcs=\"Git\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
--- a/.idea/vcs.xml	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/.idea/vcs.xml	(date 1746802283718)
@@ -2,8 +2,8 @@
 <project version="4">
   <component name="VcsDirectoryMappings">
     <mapping directory="$PROJECT_DIR$" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/crates/axdriver_crates" vcs="Git" />
     <mapping directory="$PROJECT_DIR$/crates/axfs_crates" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$/crates/axfs_vfs" vcs="Git" />
     <mapping directory="$PROJECT_DIR$/crates/axmm_crates" vcs="Git" />
     <mapping directory="$PROJECT_DIR$/crates/lwext4_rust" vcs="Git" />
     <mapping directory="$PROJECT_DIR$/crates/lwext4_rust/c/lwext4" vcs="Git" />
Index: modules/axfs/Cargo.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[package]\nname = \"axfs\"\nversion.workspace = true\nedition.workspace = true\nauthors = [\"Yuekai Jia <equation618@gmail.com>\"]\ndescription = \"ArceOS filesystem module\"\nlicense.workspace = true\nhomepage.workspace = true\nrepository = \"https://github.com/arceos-org/arceos/tree/main/modules/axfs\"\ndocumentation = \"https://arceos-org.github.io/arceos/axfs/index.html\"\n\n[features]\ndevfs = [\"dep:axfs_devfs\"]\nramfs = [\"dep:axfs_ramfs\"]\nprocfs = [\"dep:axfs_ramfs\"]\nsysfs = [\"dep:axfs_ramfs\"]\nlwext4_rs = [\"dep:lwext4_rust\"]\nfatfs = [\"dep:fatfs\"]\nmyfs = [\"dep:crate_interface\"]\nuse-ramdisk = []\n\ndefault = [\"devfs\", \"ramfs\", \"fatfs\", \"procfs\", \"sysfs\"]\n\n[dependencies]\nlog = \"=0.4.21\"\ncfg-if = \"1.0\"\nlazyinit = \"0.2\"\ncap_access = \"0.1\"\naxio = { version = \"0.1.1\", features = [\"alloc\"] }\naxerrno = \"0.1\"\naxfs_vfs = \"0.1\"\nspin = \"0.9\"\naxfs_devfs = { version = \"0.1\", optional = true }\naxfs_ramfs = { version = \"0.1\", optional = true }\ncrate_interface = { version = \"0.1\", optional = true }\naxsync = { workspace = true }\naxdriver = { workspace = true, features = [\"block\"] }\naxdriver_block = { git = \"https://github.com/arceos-org/axdriver_crates.git\", tag = \"v0.1.2\" }\nlwext4_rust = { git = \"https://github.com/Azure-stars/lwext4_rust.git\", default-features = false, optional = true ,rev = \"ee5131\"}\naxns = { workspace = true }\n\n[dependencies.fatfs]\ngit = \"https://github.com/rafalh/rust-fatfs\"\nrev = \"85f06e0\"\noptional = true\ndefault-features = false\nfeatures = [ # no std\n    \"alloc\",\n    \"lfn\",\n    \"log_level_trace\",\n    \"unicode\",\n]\n\n[dev-dependencies]\naxdriver = { workspace = true, features = [\"block\", \"ramdisk\"] }\naxdriver_block = { git = \"https://github.com/arceos-org/axdriver_crates.git\", tag = \"v0.1.2\", features = [\"ramdisk\"] }\naxsync = { workspace = true, features = [\"multitask\"] }\naxtask = { workspace = true, features = [\"test\"] }\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/modules/axfs/Cargo.toml b/modules/axfs/Cargo.toml
--- a/modules/axfs/Cargo.toml	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/modules/axfs/Cargo.toml	(date 1747330941278)
@@ -35,7 +35,8 @@
 crate_interface = { version = "0.1", optional = true }
 axsync = { workspace = true }
 axdriver = { workspace = true, features = ["block"] }
-axdriver_block = { git = "https://github.com/arceos-org/axdriver_crates.git", tag = "v0.1.2" }
+#axdriver_block = { git = "https://github.com/arceos-org/axdriver_crates.git", tag = "v0.1.2" }
+axdriver_block = { workspace = true, tag = "v0.1.2" }
 lwext4_rust = { git = "https://github.com/Azure-stars/lwext4_rust.git", default-features = false, optional = true ,rev = "ee5131"}
 axns = { workspace = true }
 
@@ -53,6 +54,7 @@
 
 [dev-dependencies]
 axdriver = { workspace = true, features = ["block", "ramdisk"] }
-axdriver_block = { git = "https://github.com/arceos-org/axdriver_crates.git", tag = "v0.1.2", features = ["ramdisk"] }
+#axdriver_block = { git = "https://github.com/arceos-org/axdriver_crates.git", tag = "v0.1.2", features = ["ramdisk"] }
+axdriver_block = { workspace = true, tag = "v0.1.2", features = ["ramdisk"]}
 axsync = { workspace = true, features = ["multitask"] }
 axtask = { workspace = true, features = ["test"] }
Index: modules/axfs/src/blkdev.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/modules/axfs/src/blkdev.rs b/modules/axfs/src/blkdev.rs
new file mode 100644
--- /dev/null	(date 1747329306400)
+++ b/modules/axfs/src/blkdev.rs	(date 1747329306400)
@@ -0,0 +1,46 @@
+// use core::any::Any;
+// use axfs_vfs::{VfsDirEntry, VfsNodeAttr, VfsNodeOps, VfsNodeRef, VfsNodeType};
+// use axfs_vfs::{VfsError, VfsResult};
+// use alloc::sync::{Arc, Weak};
+// use spin::Mutex;
+// use axdriver::prelude::*;
+// 
+// pub struct Blkdev {
+//     dev: AxBlockDevice,
+//     dev_t: (u32, u32),
+//     mount_n: usize,
+// }
+// 
+// impl Blkdev {
+//     pub fn new(dev: AxBlockDevice, major: u32, minor: u32) -> Self {
+//         Self{
+//             dev: dev,
+//             dev_t: (major, minor),
+//             mount_n: 0,
+//         }
+//     }
+//     pub fn inc_mount_n(&mut self) {
+//         self.mount_n += 1;
+//     }
+//     pub fn get_dev(self) -> AxBlockDevice {
+//        self.dev.clone()
+//     }
+//     pub fn dev_t(&self) -> (u32, u32) {self.dev_t}
+//     pub fn mount_n(&self) ->usize {self.mount_n}
+// 
+// }
+// 
+// impl VfsNodeOps for Blkdev {
+//     fn get_attr(&self) -> VfsResult<VfsNodeAttr> {
+//         //TODO:dev num
+//         Ok(VfsNodeAttr::new_file(4096, 1))
+//     }
+// 
+//     fn remove(&self, _path: &str) -> VfsResult {
+//         todo!()
+//     }
+// 
+//     fn as_any(&self) -> &dyn Any {
+//         todo!()
+//     }
+// }
Index: modules/axsyscall/src/syscall_imp/fs.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use crate::{SyscallResult, ToLinuxResult};\nuse arceos_posix_api::{self as api, char_ptr_to_str, ctypes};\nuse axfs::api::set_current_dir;\nuse core::ffi::{c_char, c_int};\n\n#[inline]\npub fn sys_openat(\n    dirfd: c_int,\n    filename: *const c_char,\n    flags: c_int,\n    mode: ctypes::mode_t,\n) -> SyscallResult {\n    api::sys_openat(dirfd, filename, flags, mode).to_linux_result()\n}\n\n#[inline]\npub fn sys_lseek(fd: c_int, offset: ctypes::off_t, whence: c_int) -> SyscallResult {\n    (api::sys_lseek(fd, offset, whence) as isize).to_linux_result()\n}\n\n#[inline]\npub unsafe fn sys_stat(path: *const c_char, buf: *mut ctypes::stat) -> SyscallResult {\n    api::sys_stat(path, buf).to_linux_result()\n}\n\n#[inline]\npub unsafe fn sys_fstat(fd: c_int, buf: *mut ctypes::stat) -> SyscallResult {\n    unsafe { api::sys_fstat(fd, buf) }.to_linux_result()\n}\n\n#[inline]\npub unsafe fn sys_fstatat(\n    dir_fd: c_int,\n    filename: *const c_char,\n    buf: *mut ctypes::stat,\n    flags: c_int,\n) -> SyscallResult {\n    unsafe { api::sys_fstatat(dir_fd, filename, buf, flags).map(|r| r as isize) }\n}\n\n#[inline]\npub unsafe fn sys_lstat(path: *const c_char, buf: *mut ctypes::stat) -> SyscallResult {\n    api::sys_lstat(path, buf).to_linux_result()\n}\n\n#[inline]\npub fn sys_getcwd(buf: *mut c_char, size: usize) -> SyscallResult {\n    (api::sys_getcwd(buf, size) as isize).to_linux_result()\n}\n\n#[inline]\npub fn sys_rename(old: *const c_char, new: *const c_char) -> SyscallResult {\n    api::sys_rename(old, new).to_linux_result()\n}\n\n#[inline]\npub fn sys_mkdirat(dir_fd: usize, dir_path: *const c_char, mode: usize) -> SyscallResult {\n    arceos_posix_api::sys_mkdirat(\n        dir_fd as c_int,\n        dir_path,\n        mode.try_into().unwrap(),\n    )\n    .to_linux_result()\n}\n\n#[inline]\npub fn sys_chdir(path: *const c_char) -> SyscallResult {\n    let ret = char_ptr_to_str(path).map(|chdir_path| set_current_dir(&chdir_path));\n    match ret {\n        Ok(_) => SyscallResult::Ok(0),\n        Err(e) => SyscallResult::Err(e.into()),\n    }\n}\n\n#[inline]\npub fn sys_getdents(fd: c_int, dirp: *mut ctypes::dirent, count: c_int) -> SyscallResult {\n    unsafe { api::sys_getdents(fd, dirp, count) }\n}\n\n#[inline]\npub fn sys_unlink(path: *const c_char) -> SyscallResult {\n    api::sys_unlink(path)\n}\n\n#[inline]\npub fn sys_unlinkat(dir_fd: c_int, path: *const c_char) -> SyscallResult {\n    api::sys_unlinkat(dir_fd, path)\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/modules/axsyscall/src/syscall_imp/fs.rs b/modules/axsyscall/src/syscall_imp/fs.rs
--- a/modules/axsyscall/src/syscall_imp/fs.rs	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/modules/axsyscall/src/syscall_imp/fs.rs	(date 1745916960256)
@@ -1,7 +1,55 @@
-use crate::{SyscallResult, ToLinuxResult};
+use crate::{result, SyscallResult, ToLinuxResult};
 use arceos_posix_api::{self as api, char_ptr_to_str, ctypes};
 use axfs::api::set_current_dir;
-use core::ffi::{c_char, c_int};
+use core::ffi::{c_char, c_int, c_long, c_longlong};
+use arceos_posix_api::ctypes::{blkcnt_t, blksize_t, dev_t, gid_t, ino_t, mode_t, nlink_t, off_t, time_t, timespec, uid_t};
+use axlog::debug;
+
+#[repr(C)]
+#[derive(Debug, Default, Copy, Clone)]
+pub struct test_stat {
+    pub st_dev: dev_t,
+    pub st_ino: ino_t,
+    pub st_mode: mode_t,
+    pub st_nlink: nlink_t,
+    pub st_uid: uid_t,
+    pub st_gid: gid_t,
+    pub st_rdev: dev_t,
+    pub st_size: off_t,
+    pub st_blksize: blksize_t,
+    pub __pad2: i32,
+    pub st_blocks: blkcnt_t,
+    pub st_atime_sec: c_long,
+    pub st_atime_nsec: c_long,
+    pub st_mtime_sec: c_long,
+    pub st_mtime_nsec: c_long,
+    pub st_ctime_sec: c_long,
+    pub st_ctime_nsec: c_long,
+}
+
+impl From<ctypes::stat> for test_stat {
+    fn from(original: ctypes::stat) -> test_stat {
+        test_stat {
+            st_dev: original.st_dev,
+            st_ino: original.st_ino,
+            st_mode: original.st_mode,
+            st_nlink: original.st_nlink,
+            st_uid: original.st_uid,
+            st_gid: original.st_gid,
+            st_rdev: original.st_rdev,
+            st_size: original.st_size,
+            st_blksize: original.st_blksize,
+            st_blocks: original.st_blocks,
+            st_atime_sec: original.st_atime.tv_sec as c_long,
+            st_mtime_sec: original.st_mtime.tv_sec as c_long,
+            st_ctime_sec: original.st_ctime.tv_sec as c_long,
+            st_atime_nsec: original.st_atime.tv_nsec as c_long,
+            st_mtime_nsec: original.st_mtime.tv_nsec as c_long,
+            st_ctime_nsec: original.st_ctime.tv_nsec as c_long,
+            ..Default::default()
+        }
+    }
+}
 
 #[inline]
 pub fn sys_openat(
@@ -24,10 +72,24 @@
 }
 
 #[inline]
-pub unsafe fn sys_fstat(fd: c_int, buf: *mut ctypes::stat) -> SyscallResult {
-    unsafe { api::sys_fstat(fd, buf) }.to_linux_result()
+pub unsafe fn sys_fstat(fd: c_int, buf: *mut test_stat) -> SyscallResult {
+    let mut stat_buf = ctypes::stat::default();
+    let result = unsafe { api::sys_fstat(fd, &mut stat_buf as *mut _) }.to_linux_result();
+    *buf = test_stat::from(stat_buf);
+    let stat = &*buf;
+    debug!{
+            "!!!atime: {:?}, ctime: {:?}, mtime: {:?}",
+            stat.st_atime_sec,
+            stat.st_ctime_sec,
+            stat.st_mtime_sec,
+        };
+    result
 }
 
+// #[inline]
+// pub unsafe fn sys_fstat(fd: c_int, buf: *mut ctypes::stat) -> SyscallResult {
+//      unsafe { api::sys_fstat(fd,buf) }.to_linux_result()
+// }
 #[inline]
 pub unsafe fn sys_fstatat(
     dir_fd: c_int,
Index: api/arceos_posix_api/src/imp/fs.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use alloc::string::{String, ToString};\nuse alloc::sync::Arc;\nuse axfs::CURRENT_DIR;\nuse axfs::api::{DirEntry, create_dir, read_dir, remove_file};\nuse axfs_vfs::{VfsDirEntry, VfsNodeAttr, VfsNodeType};\nuse core::ffi::{c_char, c_int, c_void};\nuse core::panic;\nuse static_assertions::assert_eq_size;\n\nuse axerrno::{LinuxError, LinuxResult};\nuse axfs::fops::OpenOptions;\nuse axio::{PollState, SeekFrom};\nuse axsync::Mutex;\n\nuse super::fd_ops::{FileLike, get_file_like};\nuse crate::AT_FDCWD;\nuse crate::ctypes::__IncompleteArrayField;\nuse crate::utils::str_to_cstr;\nuse crate::{ctypes, utils::char_ptr_to_str};\n\n/// File wrapper for `axfs::fops::File`.\npub struct File {\n    inner: Mutex<axfs::fops::File>,\n    path: String,\n}\n\nimpl File {\n    fn new(inner: axfs::fops::File, path: String) -> Self {\n        Self {\n            inner: Mutex::new(inner),\n            path,\n        }\n    }\n\n    fn add_to_fd_table(self) -> LinuxResult<c_int> {\n        super::fd_ops::add_file_like(Arc::new(self))\n    }\n\n    fn from_fd(fd: c_int) -> LinuxResult<Arc<Self>> {\n        let f = super::fd_ops::get_file_like(fd)?;\n        f.into_any()\n            .downcast::<Self>()\n            .map_err(|_| LinuxError::EINVAL)\n    }\n\n    /// Get the path of the file.\n    pub fn path(&self) -> &str {\n        &self.path\n    }\n\n    /// Get the inner node of the file.    \n    pub fn inner(&self) -> &Mutex<axfs::fops::File> {\n        &self.inner\n    }\n}\n\nimpl FileLike for File {\n    fn read(&self, buf: &mut [u8]) -> LinuxResult<usize> {\n        Ok(self.inner.lock().read(buf)?)\n    }\n\n    fn write(&self, buf: &[u8]) -> LinuxResult<usize> {\n        Ok(self.inner.lock().write(buf)?)\n    }\n\n    fn stat(&self) -> LinuxResult<ctypes::stat> {\n        let metadata = self.inner.lock().get_attr()?;\n        Ok(attr2stat(metadata))\n    }\n\n    fn into_any(self: Arc<Self>) -> Arc<dyn core::any::Any + Send + Sync> {\n        self\n    }\n\n    fn poll(&self) -> LinuxResult<PollState> {\n        Ok(PollState {\n            readable: true,\n            writable: true,\n        })\n    }\n\n    fn set_nonblocking(&self, _nonblocking: bool) -> LinuxResult {\n        Ok(())\n    }\n}\n\nfn attr2stat(metadata: VfsNodeAttr) -> ctypes::stat {\n    let ty = metadata.file_type() as u8;\n    let perm = metadata.perm().bits() as u32;\n    let st_mode = ((ty as u32) << 12) | perm;\n    ctypes::stat {\n        st_ino: 1,\n        st_nlink: 1,\n        st_mode,\n        st_uid: 1000,\n        st_gid: 1000,\n        st_size: metadata.size() as _,\n        st_blocks: metadata.blocks() as _,\n        st_blksize: 512,\n        ..Default::default()\n    }\n}\n\n/// Convert open flags to [`OpenOptions`].\nfn flags_to_options(flags: c_int, _mode: ctypes::mode_t) -> OpenOptions {\n    let flags = flags as u32;\n    let mut options = OpenOptions::new();\n    match flags & 0b11 {\n        ctypes::O_RDONLY => options.read(true),\n        ctypes::O_WRONLY => options.write(true),\n        _ => {\n            options.read(true);\n            options.write(true);\n        }\n    };\n    if flags & ctypes::O_APPEND != 0 {\n        options.append(true);\n    }\n    if flags & ctypes::O_TRUNC != 0 {\n        options.truncate(true);\n    }\n    if flags & ctypes::O_CREAT != 0 {\n        options.create(true);\n    }\n    if flags & ctypes::O_EXEC != 0 {\n        //options.create_new(true);\n        options.execute(true);\n    }\n    if flags & ctypes::O_DIRECTORY != 0 {\n        options.directory(true);\n    }\n    options\n}\n\n/// Open a file by `filename` and insert it into the file descriptor table.\n///\n/// Return its index in the file table (`fd`). Return `EMFILE` if it already\n/// has the maximum number of files open.\npub fn sys_open(filename: *const c_char, flags: c_int, mode: ctypes::mode_t) -> c_int {\n    let filename = char_ptr_to_str(filename);\n    debug!(\"sys_open <= {:?} {:#o} {:#o}\", filename, flags, mode);\n    syscall_body!(sys_open, {\n        add_file_or_directory_fd(\n            axfs::fops::File::open,\n            axfs::fops::Directory::open_dir,\n            filename?,\n            &flags_to_options(flags, mode),\n        )\n    })\n}\n\n/// Open or create a file.\n/// fd: file descriptor\n/// filename: file path to be opened or created\n/// flags: open flags\n/// mode: see man 7 inode\n/// return new file descriptor if succeed, or return -1.\npub fn sys_openat(\n    dirfd: c_int,\n    filename: *const c_char,\n    flags: c_int,\n    mode: ctypes::mode_t,\n) -> c_int {\n    let filename = match char_ptr_to_str(filename) {\n        Ok(s) => s,\n        Err(_) => return LinuxError::EFAULT as c_int,\n    };\n\n    debug!(\n        \"sys_openat <= {} {:?} {:#o} {:#o}\",\n        dirfd, filename, flags, mode\n    );\n\n    if filename.starts_with('/') || dirfd == AT_FDCWD as _ {\n        return sys_open(filename.as_ptr() as _, flags, mode);\n    }\n\n    Directory::from_fd(dirfd)\n        .and_then(|dir| {\n            add_file_or_directory_fd(\n                |filename, options| dir.inner.lock().open_file_at(filename, options),\n                |filename, options| dir.inner.lock().open_dir_at(filename, options),\n                filename,\n                &flags_to_options(flags, mode),\n            )\n        })\n        .unwrap_or_else(|e| {\n            debug!(\"sys_openat => {}\", e);\n            -1\n        })\n}\n\n/// Create a directory by `dirname` relatively to `dirfd`.\n/// TODO: handle `mode`\npub fn sys_mkdirat(dirfd: c_int, dirname: *const c_char, mode: ctypes::mode_t) -> c_int {\n    let dirname = match char_ptr_to_str(dirname) {\n        Ok(s) => s,\n        Err(_) => return -1,\n    };\n\n    debug!(\"sys_mkdirat <= {} {:?} {:#o}\", dirfd, dirname, mode);\n\n    if dirname.starts_with('/') || dirfd == AT_FDCWD as _ {\n        return create_dir(dirname).and(Ok(0)).unwrap_or_else(|e| {\n            debug!(\"sys_mkdirat => {}\", e);\n            -1\n        });\n    }\n\n    Directory::from_fd(dirfd)\n        .and_then(|dir| {\n            dir.inner.lock().create_dir(dirname);\n            Ok(0)\n        })\n        .unwrap_or_else(|e| {\n            debug!(\"sys_mkdirat => {}\", e);\n            -1\n        })\n}\n\n/// Create a directory by `dirname` relatively to `dirfd`.\n/// TODO: handle `mode`\npub unsafe fn sys_fstatat(\n    dirfd: c_int,\n    pathname_p: *const c_char,\n    statbuf: *mut ctypes::stat,\n    flags: c_int,\n) -> LinuxResult<c_int> {\n    let pathname = char_ptr_to_str(pathname_p)?;\n\n    debug!(\n        \"sys_fstatat <= {} {pathname_p:p} {:?} {:#o}\",\n        dirfd, pathname, flags\n    );\n    debug!(\"{:?}\", unsafe {\n        core::slice::from_raw_parts(pathname_p, 20)\n    });\n    static mut IDX: usize = 0;\n    unsafe {\n        if IDX == 7 {\n            //panic!()\n        }\n        IDX += 1;\n    }\n\n    if pathname.starts_with('/') || dirfd == AT_FDCWD as _ {\n        let dir = CURRENT_DIR.lock().clone();\n        let file = dir.lookup(pathname)?;\n        let stat = attr2stat(file.get_attr()?);\n        unsafe { *statbuf = stat };\n        return Ok(0);\n    }\n\n    let dir: Arc<Directory> = Directory::from_fd(dirfd)?;\n    // FIXME: correct path; flags\n    let file: File = File::new(\n        dir.inner\n            .lock()\n            .open_file_at(pathname, &flags_to_options(flags, 0))?,\n        pathname.into(),\n    );\n    let stat = file.stat()?;\n    unsafe { *statbuf = stat };\n    Ok(0)\n}\n\n/// Use the function to open file or directory, then add into file descriptor table.\n/// First try opening files, if fails, try directory.\nfn add_file_or_directory_fd<F, D, E>(\n    open_file: F,\n    open_dir: D,\n    filename: &str,\n    options: &OpenOptions,\n) -> LinuxResult<c_int>\nwhere\n    E: Into<LinuxError>,\n    F: FnOnce(&str, &OpenOptions) -> Result<axfs::fops::File, E>,\n    D: FnOnce(&str, &OpenOptions) -> Result<axfs::fops::Directory, E>,\n{\n    if !options.has_directory() {\n        match open_file(filename, options)\n            .map_err(Into::into)\n            .and_then(|f| File::new(f, filename.into()).add_to_fd_table())\n        {\n            Err(LinuxError::EISDIR) => {}\n            r => return r,\n        }\n    }\n\n    Directory::new(\n        open_dir(filename, options).map_err(Into::into)?,\n        filename.to_string(),\n    )\n    .add_to_fd_table()\n}\n\n/// Set the position of the file indicated by `fd`.\n///\n/// Return its position after seek.\npub fn sys_lseek(fd: c_int, offset: ctypes::off_t, whence: c_int) -> ctypes::off_t {\n    debug!(\"sys_lseek <= {} {} {}\", fd, offset, whence);\n    syscall_body!(sys_lseek, {\n        let pos = match whence {\n            0 => SeekFrom::Start(offset as _),\n            1 => SeekFrom::Current(offset as _),\n            2 => SeekFrom::End(offset as _),\n            _ => return Err(LinuxError::EINVAL),\n        };\n        let off = File::from_fd(fd)?.inner.lock().seek(pos)?;\n        Ok(off)\n    })\n}\n\n/// Get the file metadata by `path` and write into `buf`.\n///\n/// Return 0 if success.\npub unsafe fn sys_stat(path: *const c_char, buf: *mut ctypes::stat) -> c_int {\n    let path = char_ptr_to_str(path);\n    debug!(\"sys_stat <= {:?} {:#x}\", path, buf as usize);\n    syscall_body!(sys_stat, {\n        if buf.is_null() {\n            return Err(LinuxError::EFAULT);\n        }\n        let mut options = OpenOptions::new();\n        options.read(true);\n        let file = axfs::fops::File::open(path?, &options)?;\n        let st = File::new(file, path?.to_string()).stat()?;\n        unsafe { *buf = st };\n        Ok(0)\n    })\n}\n\n/// Get file metadata by `fd` and write into `buf`.\n///\n/// Return 0 if success.\npub unsafe fn sys_fstat(fd: c_int, buf: *mut ctypes::stat) -> c_int {\n    debug!(\"sys_fstat <= {} {:#x}\", fd, buf as usize);\n    syscall_body!(sys_fstat, {\n        if buf.is_null() {\n            return Err(LinuxError::EFAULT);\n        }\n\n        unsafe { *buf = get_file_like(fd)?.stat()? };\n        Ok(0)\n    })\n}\n\n/// Get the metadata of the symbolic link and write into `buf`.\n///\n/// Return 0 if success.\npub unsafe fn sys_lstat(path: *const c_char, buf: *mut ctypes::stat) -> ctypes::ssize_t {\n    let path = char_ptr_to_str(path);\n    debug!(\"sys_lstat <= {:?} {:#x}\", path, buf as usize);\n    syscall_body!(sys_lstat, {\n        if buf.is_null() {\n            return Err(LinuxError::EFAULT);\n        }\n        unsafe { *buf = Default::default() }; // TODO\n        Ok(0)\n    })\n}\n\n/// Get the path of the current directory.\npub fn sys_getcwd(buf: *mut c_char, size: usize) -> *mut c_char {\n    debug!(\"sys_getcwd <= {:#x} {}\", buf as usize, size);\n    syscall_body!(sys_getcwd, {\n        if buf.is_null() {\n            return Ok(core::ptr::null::<c_char>() as _);\n        }\n        let dst = unsafe { core::slice::from_raw_parts_mut(buf as *mut u8, size as _) };\n        let cwd = axfs::api::current_dir()?;\n        let cwd = cwd.as_bytes();\n        if cwd.len() < size {\n            dst[..cwd.len()].copy_from_slice(cwd);\n            dst[cwd.len()] = 0;\n            Ok(buf)\n        } else {\n            Err(LinuxError::ERANGE)\n        }\n    })\n}\n\n/// Rename `old` to `new`\n/// If new exists, it is first removed.\n///\n/// Return 0 if the operation succeeds, otherwise return -1.\npub fn sys_rename(old: *const c_char, new: *const c_char) -> c_int {\n    syscall_body!(sys_rename, {\n        let old_path = char_ptr_to_str(old)?;\n        let new_path = char_ptr_to_str(new)?;\n        debug!(\"sys_rename <= old: {:?}, new: {:?}\", old_path, new_path);\n        axfs::api::rename(old_path, new_path)?;\n        Ok(0)\n    })\n}\n\n/// Directory wrapper for `axfs::fops::Directory`.\npub struct Directory {\n    inner: Mutex<axfs::fops::Directory>,\n    path: String,\n}\n\nimpl Directory {\n    fn new(inner: axfs::fops::Directory, path: String) -> Self {\n        Self {\n            inner: Mutex::new(inner),\n            path,\n        }\n    }\n\n    fn add_to_fd_table(self) -> LinuxResult<c_int> {\n        super::fd_ops::add_file_like(Arc::new(self))\n    }\n\n    /// Open a directory by `fd`.\n    pub fn from_fd(fd: c_int) -> LinuxResult<Arc<Self>> {\n        let f = super::fd_ops::get_file_like(fd)?;\n        f.into_any()\n            .downcast::<Self>()\n            .map_err(|_| LinuxError::EINVAL)\n    }\n\n    /// Get the path of the directory.\n    pub fn path(&self) -> &str {\n        &self.path\n    }\n}\n\nimpl FileLike for Directory {\n    fn read(&self, _buf: &mut [u8]) -> LinuxResult<usize> {\n        Err(LinuxError::EBADF)\n    }\n\n    fn write(&self, _buf: &[u8]) -> LinuxResult<usize> {\n        Err(LinuxError::EBADF)\n    }\n\n    /*\n     *fn stat(&self) -> LinuxResult<ctypes::stat> {\n     *    Err(LinuxError::EBADF)\n     *}\n     */\n\n    fn stat(&self) -> LinuxResult<ctypes::stat> {\n        let metadata = self.inner.lock().get_attr()?;\n        let ty = metadata.file_type() as u8;\n        let perm = metadata.perm().bits() as u32;\n        let st_mode = ((ty as u32) << 12) | perm;\n        Ok(ctypes::stat {\n            st_ino: 1,\n            st_nlink: 2,\n            st_mode,\n            st_uid: 1000,\n            st_gid: 1000,\n            st_size: metadata.size() as _,\n            //st_blocks: metadata.blocks() as _,\n            st_blocks: 1,\n            st_blksize: 512,\n            ..Default::default()\n        })\n    }\n\n    fn into_any(self: Arc<Self>) -> Arc<dyn core::any::Any + Send + Sync> {\n        self\n    }\n\n    fn poll(&self) -> LinuxResult<PollState> {\n        Ok(PollState {\n            readable: true,\n            writable: false,\n        })\n    }\n\n    fn set_nonblocking(&self, _nonblocking: bool) -> LinuxResult {\n        Ok(())\n    }\n}\n\n/*\n *pub unsafe fn sys_getdents(\n *    dir_fd: i32,\n *    buf: *mut ctypes::dirent,\n *    count: c_int,\n *) -> LinuxResult<isize> {\n *    let dir: Arc<Directory> = Directory::from_fd(dir_fd)?;\n *    let mut curr_dent = buf;\n *    let count = count.try_into().map_err(|_| LinuxError::EINVAL)?;\n *    let mut inner = dir.inner.lock();\n *    let end = (buf as *const u8).wrapping_add(count);\n *    let dirent_size = core::mem::size_of::<ctypes::dirent>();\n *    // TODO: support file name longer than 64 bytes\n *    // 64 : sizeof [char; 64];\n *    let mut nread = 0;\n *    while (curr_dent as *const u8).wrapping_add(dirent_size + 64) < end {\n *        let mut dirent_buf = [VfsDirEntry::default()];\n *        match inner.read_dir(&mut dirent_buf) {\n *            Ok(n) if n == 0 => break,\n *            Ok(n) => nread += n,\n *            Err(_) => break,\n *        }\n *        let name = dirent_buf[0].name_as_bytes();\n *        let name = unsafe { String::from_utf8_lossy(name) };\n *        assert!(name.len() < 64);\n *        let d_reclen = core::mem::size_of::<ctypes::dirent>() + name.len() + 1;\n *        unsafe {\n *            *curr_dent = ctypes::dirent {\n *                d_ino: 1,\n *                d_off: 0,\n *                d_reclen: d_reclen as u16,\n *                d_type: dirent_buf[0].entry_type() as u8,\n *                d_name: __IncompleteArrayField::<c_char>::new(),\n *            };\n *            let mut name_ptr = (curr_dent as *mut c_char).wrapping_add(19); // offset of d_name in dirent\n *            let str_len = str_to_cstr(&name, name_ptr);\n *            // FIXME: align struct??\n *            curr_dent = name_ptr.wrapping_add(str_len) as *mut _;\n *        };\n *        // cut off d_name at `\\0`\n *    }\n *\n *    return Ok(nread as isize);\n *}\n */\npub unsafe fn sys_getdents(\n    dir_fd: i32,\n    buf: *mut ctypes::dirent,\n    count: c_int,\n) -> LinuxResult<isize> {\n    const MAX_NAME_LEN: usize = 255; // Linux NAME_MAX\n    const DIRENT_MIN_SIZE: usize = core::mem::size_of::<ctypes::dirent>();\n\n    let dir = Directory::from_fd(dir_fd)?;\n    let mut inner = dir.inner.lock();\n\n    let buf_start = buf as *const u8;\n    let buf_end = buf_start.wrapping_add(count as usize);\n    let mut curr_ptr = buf as *mut u8;\n    let mut entries_written = 0;\n\n    // Temporary buffer for directory entries\n    let mut dirent_buf = [VfsDirEntry::default(); 1];\n\n    loop {\n        // Check remaining space (need space for struct + name + null terminator)\n        let remaining = buf_end as usize - curr_ptr as usize;\n        if remaining < DIRENT_MIN_SIZE + MAX_NAME_LEN + 1 {\n            break;\n        }\n\n        // Read next directory entry\n        match inner.read_dir(&mut dirent_buf) {\n            Ok(0) => break, // No more entries\n            Ok(_) => (),\n            Err(e) => {\n                if entries_written == 0 {\n                    return Err(e.into());\n                }\n                break;\n            }\n        }\n\n        let entry = &dirent_buf[0];\n        let name = entry.name_as_bytes();\n        let name_len = name.len().min(MAX_NAME_LEN);\n\n        // Calculate required space\n        let reclen = core::mem::align_of::<ctypes::dirent>()\n            .max(8)\n            .max(DIRENT_MIN_SIZE + name_len + 1);\n\n        if (curr_ptr as usize + reclen) > buf_end as usize {\n            break;\n        }\n\n        // Fill dirent structure\n        let dirent = curr_ptr as *mut ctypes::dirent;\n        unsafe {\n            (*dirent).d_ino = 1;\n            (*dirent).d_off = 0;\n            (*dirent).d_reclen = reclen as u16;\n            (*dirent).d_type = entry.entry_type() as u8;\n\n            // Copy name (including null terminator)\n            let name_dst = (*dirent).d_name.as_mut_ptr();\n            core::ptr::copy_nonoverlapping(name.as_ptr(), name_dst, name_len);\n            *name_dst.add(name_len) = 0;\n\n            curr_ptr = curr_ptr.add(reclen);\n        }\n        entries_written += 1;\n    }\n\n    Ok(if entries_written > 0 {\n        (curr_ptr as usize - buf_start as usize) as isize\n    } else {\n        0\n    })\n}\n\npub fn sys_unlink(path: *const c_char) -> LinuxResult<isize> {\n    let path = char_ptr_to_str(path).map_err(|_| LinuxError::EFAULT)?;\n    warn!(\"sys_unlink <= {:?}\", path);\n    remove_file(path)?;\n    warn!(\"sys_unlink <= {:?}\", path);\n    Ok(0)\n}\npub fn sys_unlinkat(dir_fd: i32, path: *const c_char) -> LinuxResult<isize> {\n    if dir_fd < 0 {\n        return sys_unlink(path);\n    }\n    let dir: Arc<Directory> = Directory::from_fd(dir_fd)?;\n    let path = char_ptr_to_str(path).map_err(|_| LinuxError::EFAULT)?;\n    dir.inner.lock().remove_file(path)?;\n    Ok(0)\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/api/arceos_posix_api/src/imp/fs.rs b/api/arceos_posix_api/src/imp/fs.rs
--- a/api/arceos_posix_api/src/imp/fs.rs	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/api/arceos_posix_api/src/imp/fs.rs	(date 1746628390702)
@@ -3,7 +3,7 @@
 use axfs::CURRENT_DIR;
 use axfs::api::{DirEntry, create_dir, read_dir, remove_file};
 use axfs_vfs::{VfsDirEntry, VfsNodeAttr, VfsNodeType};
-use core::ffi::{c_char, c_int, c_void};
+use core::ffi::{c_char, c_int, c_uint, c_void};
 use core::panic;
 use static_assertions::assert_eq_size;
 
@@ -14,7 +14,8 @@
 
 use super::fd_ops::{FileLike, get_file_like};
 use crate::AT_FDCWD;
-use crate::ctypes::__IncompleteArrayField;
+use crate::ctypes::{__IncompleteArrayField, time_t, timespec};
+// use crate::ctypes::{__IncompleteArrayField, time_t};
 use crate::utils::str_to_cstr;
 use crate::{ctypes, utils::char_ptr_to_str};
 
@@ -88,15 +89,35 @@
     let ty = metadata.file_type() as u8;
     let perm = metadata.perm().bits() as u32;
     let st_mode = ((ty as u32) << 12) | perm;
+    debug!("!!!!mode is {}",st_mode);
     ctypes::stat {
-        st_ino: 1,
-        st_nlink: 1,
+        st_dev: metadata.dev() as _,
+        st_ino: metadata.st_ino() as _,
         st_mode,
-        st_uid: 1000,
-        st_gid: 1000,
+        st_nlink: metadata.nlink() as _,
+        st_uid: metadata.uid() as _,
+        st_gid: metadata.gid() as _,
         st_size: metadata.size() as _,
-        st_blocks: metadata.blocks() as _,
         st_blksize: 512,
+        st_blocks: metadata.blocks() as _,
+        // st_atime_sec: metadata.atime() as core::ffi::c_long,
+        // st_atime_nsec: metadata.atime_nse() as core::ffi::c_long,
+        // st_mtime_sec: metadata.mtime() as core::ffi::c_long,
+        // st_mtime_nsec: metadata.mtime_nse() as core::ffi::c_long,
+        // st_ctime_sec: metadata.ctime() as core::ffi::c_long,
+        // st_ctime_nsec: metadata.ctime_nse() as core::ffi::c_long,
+        st_atime:timespec{
+            tv_sec: metadata.atime() as time_t,
+            tv_nsec: metadata.atime_nse() as core::ffi::c_long
+        },
+        st_ctime:timespec{
+            tv_sec: metadata.ctime() as time_t,
+            tv_nsec: metadata.ctime_nse() as core::ffi::c_long
+        },
+        st_mtime:timespec{
+            tv_sec: metadata.mtime() as time_t,
+            tv_nsec: metadata.mtime_nse() as core::ffi::c_long
+        },
         ..Default::default()
     }
 }
@@ -339,7 +360,6 @@
         if buf.is_null() {
             return Err(LinuxError::EFAULT);
         }
-
         unsafe { *buf = get_file_like(fd)?.stat()? };
         Ok(0)
     })
@@ -447,14 +467,14 @@
         let perm = metadata.perm().bits() as u32;
         let st_mode = ((ty as u32) << 12) | perm;
         Ok(ctypes::stat {
-            st_ino: 1,
-            st_nlink: 2,
+            st_ino: metadata.st_ino() as u64,
+            st_nlink: metadata.nlink(),
             st_mode,
-            st_uid: 1000,
-            st_gid: 1000,
+            st_uid: metadata.uid() as c_uint,
+            st_gid: metadata.gid() as c_uint,
             st_size: metadata.size() as _,
             //st_blocks: metadata.blocks() as _,
-            st_blocks: 1,
+            st_blocks: metadata.blocks() as _,
             st_blksize: 512,
             ..Default::default()
         })
Index: modules/axfs/src/fs/fatfs.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use alloc::sync::Arc;\nuse core::cell::UnsafeCell;\n\nuse axfs_vfs::{VfsDirEntry, VfsError, VfsNodePerm, VfsResult};\nuse axfs_vfs::{VfsNodeAttr, VfsNodeOps, VfsNodeRef, VfsNodeType, VfsOps};\nuse axsync::Mutex;\nuse fatfs::{Dir, File, LossyOemCpConverter, NullTimeProvider, Read, Seek, SeekFrom, Write};\n\nuse crate::dev::Disk;\n\nconst BLOCK_SIZE: usize = 512;\n\npub struct FatFileSystem {\n    inner: fatfs::FileSystem<Disk, NullTimeProvider, LossyOemCpConverter>,\n    root_dir: UnsafeCell<Option<VfsNodeRef>>,\n}\n\npub struct FileWrapper<'a, IO: IoTrait>(Mutex<File<'a, IO, NullTimeProvider, LossyOemCpConverter>>);\npub struct DirWrapper<'a, IO: IoTrait>(Dir<'a, IO, NullTimeProvider, LossyOemCpConverter>);\n\npub trait IoTrait: Read + Write + Seek {}\n\nunsafe impl Sync for FatFileSystem {}\nunsafe impl Send for FatFileSystem {}\nunsafe impl<'a, IO: IoTrait> Send for FileWrapper<'a, IO> {}\nunsafe impl<'a, IO: IoTrait> Sync for FileWrapper<'a, IO> {}\nunsafe impl<'a, IO: IoTrait> Send for DirWrapper<'a, IO> {}\nunsafe impl<'a, IO: IoTrait> Sync for DirWrapper<'a, IO> {}\n\nimpl FatFileSystem {\n    #[cfg(feature = \"use-ramdisk\")]\n    pub fn new(mut disk: Disk) -> Self {\n        let opts = fatfs::FormatVolumeOptions::new();\n        fatfs::format_volume(&mut disk, opts).expect(\"failed to format volume\");\n        let inner = fatfs::FileSystem::new(disk, fatfs::FsOptions::new())\n            .expect(\"failed to initialize FAT filesystem\");\n        Self {\n            inner,\n            root_dir: UnsafeCell::new(None),\n        }\n    }\n\n    #[cfg(not(feature = \"use-ramdisk\"))]\n    pub fn new(disk: Disk) -> Self {\n        let inner = fatfs::FileSystem::new(disk, fatfs::FsOptions::new())\n            .expect(\"failed to initialize FAT filesystem\");\n        Self {\n            inner,\n            root_dir: UnsafeCell::new(None),\n        }\n    }\n\n    pub fn init(&'static self) {\n        // must be called before later operations\n        unsafe { *self.root_dir.get() = Some(Self::new_dir(self.inner.root_dir())) }\n    }\n\n    fn new_file<IO: IoTrait>(\n        file: File<'_, IO, NullTimeProvider, LossyOemCpConverter>,\n    ) -> Arc<FileWrapper<IO>> {\n        Arc::new(FileWrapper(Mutex::new(file)))\n    }\n\n    fn new_dir<IO: IoTrait>(\n        dir: Dir<'_, IO, NullTimeProvider, LossyOemCpConverter>,\n    ) -> Arc<DirWrapper<IO>> {\n        Arc::new(DirWrapper(dir))\n    }\n}\n\nimpl<IO: IoTrait> VfsNodeOps for FileWrapper<'static, IO> {\n    axfs_vfs::impl_vfs_non_dir_default! {}\n\n    fn get_attr(&self) -> VfsResult<VfsNodeAttr> {\n        let size = self.0.lock().seek(SeekFrom::End(0)).map_err(as_vfs_err)?;\n        let blocks = (size + BLOCK_SIZE as u64 - 1) / BLOCK_SIZE as u64;\n        // FAT fs doesn't support permissions, we just set everything to 755\n        let perm = VfsNodePerm::from_bits_truncate(0o755);\n        Ok(VfsNodeAttr::new(perm, VfsNodeType::File, size, blocks))\n    }\n\n    fn read_at(&self, offset: u64, buf: &mut [u8]) -> VfsResult<usize> {\n        let mut file = self.0.lock();\n        file.seek(SeekFrom::Start(offset)).map_err(as_vfs_err)?; // TODO: more efficient\n        file.read(buf).map_err(as_vfs_err)\n    }\n\n    fn write_at(&self, offset: u64, buf: &[u8]) -> VfsResult<usize> {\n        let mut file = self.0.lock();\n        file.seek(SeekFrom::Start(offset)).map_err(as_vfs_err)?; // TODO: more efficient\n        file.write(buf).map_err(as_vfs_err)\n    }\n\n    fn truncate(&self, size: u64) -> VfsResult {\n        let mut file = self.0.lock();\n        file.seek(SeekFrom::Start(size)).map_err(as_vfs_err)?; // TODO: more efficient\n        file.truncate().map_err(as_vfs_err)\n    }\n}\n\nimpl<IO: IoTrait> VfsNodeOps for DirWrapper<'static, IO> {\n    axfs_vfs::impl_vfs_dir_default! {}\n\n    fn get_attr(&self) -> VfsResult<VfsNodeAttr> {\n        // FAT fs doesn't support permissions, we just set everything to 755\n        Ok(VfsNodeAttr::new(\n            VfsNodePerm::from_bits_truncate(0o755),\n            VfsNodeType::Dir,\n            BLOCK_SIZE as u64,\n            1,\n        ))\n    }\n\n    fn parent(&self) -> Option<VfsNodeRef> {\n        self.0\n            .open_dir(\"..\")\n            .map_or(None, |dir| Some(FatFileSystem::new_dir(dir)))\n    }\n\n    fn lookup(self: Arc<Self>, path: &str) -> VfsResult<VfsNodeRef> {\n        debug!(\"lookup at fatfs: {}\", path);\n        let path = path.trim_matches('/');\n        if path.is_empty() || path == \".\" {\n            return Ok(self.clone());\n        }\n        if let Some(rest) = path.strip_prefix(\"./\") {\n            return self.lookup(rest);\n        }\n\n        // TODO: use `fatfs::Dir::find_entry`, but it's not public.\n        if let Ok(file) = self.0.open_file(path) {\n            Ok(FatFileSystem::new_file(file))\n        } else if let Ok(dir) = self.0.open_dir(path) {\n            Ok(FatFileSystem::new_dir(dir))\n        } else {\n            Err(VfsError::NotFound)\n        }\n    }\n\n    fn create(&self, path: &str, ty: VfsNodeType) -> VfsResult {\n        debug!(\"create {:?} at fatfs: {}\", ty, path);\n        let path = path.trim_matches('/');\n        if path.is_empty() || path == \".\" {\n            return Ok(());\n        }\n        if let Some(rest) = path.strip_prefix(\"./\") {\n            return self.create(rest, ty);\n        }\n\n        match ty {\n            VfsNodeType::File => {\n                self.0.create_file(path).map_err(as_vfs_err)?;\n                Ok(())\n            }\n            VfsNodeType::Dir => {\n                self.0.create_dir(path).map_err(as_vfs_err)?;\n                Ok(())\n            }\n            _ => Err(VfsError::Unsupported),\n        }\n    }\n\n    fn remove(&self, path: &str) -> VfsResult {\n        debug!(\"remove at fatfs: {}\", path);\n        let path = path.trim_matches('/');\n        assert!(!path.is_empty()); // already check at `root.rs`\n        if let Some(rest) = path.strip_prefix(\"./\") {\n            return self.remove(rest);\n        }\n        self.0.remove(path).map_err(as_vfs_err)\n    }\n\n    fn read_dir(&self, start_idx: usize, dirents: &mut [VfsDirEntry]) -> VfsResult<usize> {\n        let mut iter = self.0.iter().skip(start_idx);\n        for (i, out_entry) in dirents.iter_mut().enumerate() {\n            let x = iter.next();\n            match x {\n                Some(Ok(entry)) => {\n                    let ty = if entry.is_dir() {\n                        VfsNodeType::Dir\n                    } else if entry.is_file() {\n                        VfsNodeType::File\n                    } else {\n                        unreachable!()\n                    };\n                    *out_entry = VfsDirEntry::new(&entry.file_name(), ty);\n                }\n                _ => return Ok(i),\n            }\n        }\n        Ok(dirents.len())\n    }\n\n    fn rename(&self, src_path: &str, dst_path: &str) -> VfsResult {\n        // `src_path` and `dst_path` should in the same mounted fs\n        debug!(\n            \"rename at fatfs, src_path: {}, dst_path: {}\",\n            src_path, dst_path\n        );\n\n        self.0\n            .rename(src_path, &self.0, dst_path)\n            .map_err(as_vfs_err)\n    }\n}\n\nimpl VfsOps for FatFileSystem {\n    fn root_dir(&self) -> VfsNodeRef {\n        let root_dir = unsafe { (*self.root_dir.get()).as_ref().unwrap() };\n        root_dir.clone()\n    }\n}\n\nimpl fatfs::IoBase for Disk {\n    type Error = ();\n}\n\nimpl IoTrait for Disk {}\n\nimpl Read for Disk {\n    fn read(&mut self, mut buf: &mut [u8]) -> Result<usize, Self::Error> {\n        let mut read_len = 0;\n        while !buf.is_empty() {\n            match self.read_one(buf) {\n                Ok(0) => break,\n                Ok(n) => {\n                    let tmp = buf;\n                    buf = &mut tmp[n..];\n                    read_len += n;\n                }\n                Err(_) => return Err(()),\n            }\n        }\n        Ok(read_len)\n    }\n}\n\nimpl Write for Disk {\n    fn write(&mut self, mut buf: &[u8]) -> Result<usize, Self::Error> {\n        let mut write_len = 0;\n        while !buf.is_empty() {\n            match self.write_one(buf) {\n                Ok(0) => break,\n                Ok(n) => {\n                    buf = &buf[n..];\n                    write_len += n;\n                }\n                Err(_) => return Err(()),\n            }\n        }\n        Ok(write_len)\n    }\n    fn flush(&mut self) -> Result<(), Self::Error> {\n        Ok(())\n    }\n}\n\nimpl Seek for Disk {\n    fn seek(&mut self, pos: SeekFrom) -> Result<u64, Self::Error> {\n        let size = self.size();\n        let new_pos = match pos {\n            SeekFrom::Start(pos) => Some(pos),\n            SeekFrom::Current(off) => self.position().checked_add_signed(off),\n            SeekFrom::End(off) => size.checked_add_signed(off),\n        }\n        .ok_or(())?;\n        if new_pos > size {\n            warn!(\"Seek beyond the end of the block device\");\n        }\n        self.set_position(new_pos);\n        Ok(new_pos)\n    }\n}\n\nfn as_vfs_err<E>(err: fatfs::Error<E>) -> VfsError {\n    use fatfs::Error::*;\n    match err {\n        AlreadyExists => VfsError::AlreadyExists,\n        CorruptedFileSystem => VfsError::InvalidData,\n        DirectoryIsNotEmpty => VfsError::DirectoryNotEmpty,\n        InvalidInput | InvalidFileNameLength | UnsupportedFileNameCharacter => {\n            VfsError::InvalidInput\n        }\n        NotEnoughSpace => VfsError::StorageFull,\n        NotFound => VfsError::NotFound,\n        UnexpectedEof => VfsError::UnexpectedEof,\n        WriteZero => VfsError::WriteZero,\n        Io(_) => VfsError::Io,\n        _ => VfsError::Io,\n    }\n}\n\nimpl Clone for FileWrapper<'static, Disk> {\n    fn clone(&self) -> Self {\n        let file = self.0.lock();\n        let cloned_file = file.clone();\n        Self(Mutex::new(cloned_file))\n    }\n}\n\npub struct FatFileSystemFromFile {\n    inner: fatfs::FileSystem<FileWrapper<'static, Disk>, NullTimeProvider, LossyOemCpConverter>,\n    root_dir: UnsafeCell<Option<VfsNodeRef>>,\n}\n\nunsafe impl Sync for FatFileSystemFromFile {}\nunsafe impl Send for FatFileSystemFromFile {}\n\n#[allow(unused)]\nimpl FatFileSystemFromFile {\n    pub fn new(file: FileWrapper<'static, Disk>) -> Self {\n        let inner = fatfs::FileSystem::new(file, fatfs::FsOptions::new())\n            .expect(\"failed to initialize FAT filesystem\");\n        Self {\n            inner,\n            root_dir: UnsafeCell::new(None),\n        }\n    }\n\n    pub fn init(&'static self) {\n        // must be called before later operations\n        unsafe { *self.root_dir.get() = Some(FatFileSystem::new_dir(self.inner.root_dir())) }\n    }\n}\n\nimpl VfsOps for FatFileSystemFromFile {\n    fn root_dir(&self) -> VfsNodeRef {\n        let root_dir = unsafe { (*self.root_dir.get()).as_ref().unwrap() };\n        root_dir.clone()\n    }\n}\n\nimpl<'a> fatfs::IoBase for FileWrapper<'a, Disk> {\n    type Error = ();\n}\n\nimpl<'a> IoTrait for FileWrapper<'a, Disk> {}\n\nimpl<'a> fatfs::Read for FileWrapper<'a, Disk> {\n    fn read(&mut self, buf: &mut [u8]) -> Result<usize, Self::Error> {\n        let mut file = self.0.lock();\n        file.read(buf)\n            .inspect_err(|e| error!(\"read error: {e:?}\"))\n            .map_err(|_| ())\n    }\n}\n\nimpl<'a> fatfs::Write for FileWrapper<'a, Disk> {\n    fn write(&mut self, buf: &[u8]) -> Result<usize, Self::Error> {\n        let mut file = self.0.lock();\n        file.write(buf)\n            .inspect_err(|e| error!(\"write error: {e:?}\"))\n            .map_err(|_| ())\n    }\n\n    fn flush(&mut self) -> Result<(), Self::Error> {\n        let mut file = self.0.lock();\n        file.flush()\n            .inspect_err(|e| error!(\"flush error: {e:?}\"))\n            .map_err(|_| ())\n    }\n}\n\nimpl<'a> fatfs::Seek for FileWrapper<'a, Disk> {\n    fn seek(&mut self, pos: fatfs::SeekFrom) -> Result<u64, Self::Error> {\n        let mut file = self.0.lock();\n        file.seek(pos)\n            .inspect_err(|e| error!(\"seek error: {e:?}\"))\n            .map_err(|_| ())\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/modules/axfs/src/fs/fatfs.rs b/modules/axfs/src/fs/fatfs.rs
--- a/modules/axfs/src/fs/fatfs.rs	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/modules/axfs/src/fs/fatfs.rs	(date 1746626254289)
@@ -76,7 +76,7 @@
         let blocks = (size + BLOCK_SIZE as u64 - 1) / BLOCK_SIZE as u64;
         // FAT fs doesn't support permissions, we just set everything to 755
         let perm = VfsNodePerm::from_bits_truncate(0o755);
-        Ok(VfsNodeAttr::new(perm, VfsNodeType::File, size, blocks))
+        Ok(VfsNodeAttr::new(22,perm, VfsNodeType::File, size, blocks, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0))
     }
 
     fn read_at(&self, offset: u64, buf: &mut [u8]) -> VfsResult<usize> {
@@ -100,14 +100,27 @@
 
 impl<IO: IoTrait> VfsNodeOps for DirWrapper<'static, IO> {
     axfs_vfs::impl_vfs_dir_default! {}
-
+    
+    ///TODO fix fata inode
     fn get_attr(&self) -> VfsResult<VfsNodeAttr> {
         // FAT fs doesn't support permissions, we just set everything to 755
         Ok(VfsNodeAttr::new(
+            0,
             VfsNodePerm::from_bits_truncate(0o755),
             VfsNodeType::Dir,
             BLOCK_SIZE as u64,
             1,
+            0,
+            0,
+            0,
+            0,
+            0,
+            0,
+            0,
+            0,
+            0,
+            0,
+            0,
         ))
     }
 
Index: ulib/axmono/Cargo.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[package]\nname = \"axmono\"\nversion.workspace = true\nedition.workspace = true\nauthors.workspace = true\nlicense.workspace = true\nhomepage.workspace = true\ndocumentation.workspace = true\nrepository.workspace = true\nkeywords.workspace = true\ncategories.workspace = true\n\n[features]\ndefault = [\"process\", \"mm\", \"syscalls\", \"mmap\", \"heap\", \"sig\"]\nprocess = [\"axns\", \"axtask\", \"axfeat/multitask\"]\nmm = [\"axmm\"]\nCOW = [\"axmm/COW\", \"page_table_entry/COW\"]\nirq = [\"axfeat/irq\", \"axtask?/sched_rr\"]\nsyscalls = [\"dep:syscalls\"]\nheap = [\"axmm/heap\"]\nmmap = [\"axmm/mmap\"]\nsig = []\n[dependencies]\npage_table_entry = { workspace = true }\npage_table_multiarch = { workspace = true }\naxfeat = { workspace = true, features = [\"tls\"]}\naxconfig = { workspace = true }\naxhal = { workspace = true }\naxlog = { workspace = true }\narceos_posix_api = { workspace = true, features = [\"uspace\"] }\naxfs = { workspace = true }\naxmm = { workspace = true, optional = true }\naxtask = { workspace = true, optional = true }\naxsync = { workspace = true }\naxns = { workspace = true, optional = true }\naxsyscall = { workspace = true, features = [\n  \"fd\",\n  \"fs\",\n  \"pipe\",\n  \"multitask\",\n] }\n\naxerrno = \"0.1\"\nmemory_addr = \"0.3.2\"\nbitflags = \"2.9.0\"\ncrate_interface = \"0.1.4\"\nxmas-elf = \"0.9.1\"\nkernel-elf-parser = \"0.3.2\"\nlinkme = \"0.3.32\"\nnumeric-enum-macro = { git = \"https://github.com/mexus/numeric-enum-macro\" }\nsyscalls = { workspace = true, optional = true }\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ulib/axmono/Cargo.toml b/ulib/axmono/Cargo.toml
--- a/ulib/axmono/Cargo.toml	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/ulib/axmono/Cargo.toml	(date 1745660511141)
@@ -11,7 +11,7 @@
 categories.workspace = true
 
 [features]
-default = ["process", "mm", "syscalls", "mmap", "heap", "sig"]
+default = ["process", "mm", "syscalls", "mmap", "heap","sig"]
 process = ["axns", "axtask", "axfeat/multitask"]
 mm = ["axmm"]
 COW = ["axmm/COW", "page_table_entry/COW"]
@@ -20,6 +20,7 @@
 heap = ["axmm/heap"]
 mmap = ["axmm/mmap"]
 sig = []
+
 [dependencies]
 page_table_entry = { workspace = true }
 page_table_multiarch = { workspace = true }
Index: ulib/axmono/src/lib.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*!\nAstrancE lib for building a monolithic kernel\nThis library mainly provides a set of functions for userspace applications to interact with the kernel.\nAlthough AstrancE is designed to be a unikernel, some may want to use user mode codes.\n*/\n#![no_std]\n#![feature(stmt_expr_attributes)]\nextern crate alloc;\n#[macro_use]\nextern crate axlog;\n\nextern crate axsyscall;\npub mod ctypes;\nuse core::clone;\n\nuse axerrno::AxResult;\nuse axhal::arch::TrapFrame;\nuse axhal::trap::{SYSCALL, register_trap_handler};\nuse axmm::kernel_aspace;\nuse axtask::{current, yield_now};\nuse ctypes::{CloneFlags, WaitStatus};\nuse task::wait_pid;\n\npub mod elf;\npub mod loader;\n#[cfg(feature = \"syscalls\")]\nmod syscall;\n\n#[cfg(feature = \"process\")]\npub mod task;\n\n#[cfg(feature = \"mm\")]\npub mod mm;\n\n#[cfg(any(feature = \"mm\", feature = \"process\"))]\n/// If the target architecture requires it, the kernel portion of the address\n/// space will be copied to the user address space.\n/// TODO: unsafe. using trampoline instead\npub fn copy_from_kernel(aspace: &mut axmm::AddrSpace) -> AxResult {\n    use axmm::kernel_aspace;\n\n    if !cfg!(target_arch = \"aarch64\") && !cfg!(target_arch = \"loongarch64\") {\n        // ARMv8 (aarch64) and LoongArch64 use separate page tables for user space\n        // (aarch64: TTBR0_EL1, LoongArch64: PGDL), so there is no need to copy the\n        // kernel portion to the user page table.\n        aspace.copy_mappings_from(&kernel_aspace().lock(), false)?;\n    }\n\n    Ok(())\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ulib/axmono/src/lib.rs b/ulib/axmono/src/lib.rs
--- a/ulib/axmono/src/lib.rs	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/ulib/axmono/src/lib.rs	(date 1746881482635)
@@ -32,6 +32,7 @@
 #[cfg(feature = "mm")]
 pub mod mm;
 
+
 #[cfg(any(feature = "mm", feature = "process"))]
 /// If the target architecture requires it, the kernel portion of the address
 /// space will be copied to the user address space.
Index: modules/axfs/src/fs/lwext4_rust.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use crate::alloc::string::String;\nuse alloc::sync::Arc;\nuse axerrno::AxError;\nuse axfs_vfs::{VfsDirEntry, VfsError, VfsNodePerm, VfsResult};\nuse axfs_vfs::{VfsNodeAttr, VfsNodeOps, VfsNodeRef, VfsNodeType, VfsOps};\nuse axsync::Mutex;\nuse lwext4_rust::bindings::{\n    O_CREAT, O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY, SEEK_CUR, SEEK_END, SEEK_SET,\n};\nuse lwext4_rust::{Ext4BlockWrapper, Ext4File, InodeTypes, KernelDevOp};\n\nuse crate::dev::Disk;\npub const BLOCK_SIZE: usize = 512;\n\n#[allow(dead_code)]\npub struct Ext4FileSystem<T: KernelDevOp<DevType = T>> {\n    inner: Ext4BlockWrapper<T>,\n    root: VfsNodeRef,\n}\n\nunsafe impl<T: KernelDevOp<DevType = T>> Sync for Ext4FileSystem<T> {}\nunsafe impl<T: KernelDevOp<DevType = T>> Send for Ext4FileSystem<T> {}\n/*\n *unsafe impl Sync for Ext4FileSystem<Disk> {}\n *unsafe impl Send for Ext4FileSystem<Disk> {}\n */\n\nimpl<T: KernelDevOp<DevType = T>> Ext4FileSystem<T> {\n    #[cfg(feature = \"use-ramdisk\")]\n    pub fn new(mut disk: Disk) -> Self {\n        unimplemented!()\n    }\n\n    /*\n     *#[cfg(not(feature = \"use-ramdisk\"))]\n     *pub fn new(disk: Disk) -> Self {\n     *    info!(\n     *        \"Got Disk size:{}, position:{}\",\n     *        disk.size(),\n     *        disk.position()\n     *    );\n     *    let inner =\n     *        Ext4BlockWrapper::<Disk>::new(disk).expect(\"failed to initialize EXT4 filesystem\");\n     *    let root = Arc::new(FileWrapper::new(\"/\", InodeTypes::EXT4_DE_DIR));\n     *    Self { inner, root }\n     *}\n     */\n    //#[cfg(not(feature = \"use-ramdisk\"))]\n    pub fn new(block_dev: T) -> Self {\n        /*\n         *info!(\n         *    \"Got Disk size:{}, position:{}\",\n         *    disk.size(),\n         *    disk.position()\n         *);\n         */\n        let inner =\n            Ext4BlockWrapper::<T>::new(block_dev).expect(\"failed to initialize EXT4 filesystem\");\n        info!(\"new block device\");\n        let root = Arc::new(FileWrapper::new(\"/\", InodeTypes::EXT4_DE_DIR));\n        info!(\"new block device\");\n        Self { inner, root }\n    }\n}\n\n/// The [`VfsOps`] trait provides operations on a filesystem.\nimpl<T: KernelDevOp<DevType = T>> VfsOps for Ext4FileSystem<T> {\n    // mount()\n\n    fn root_dir(&self) -> VfsNodeRef {\n        trace!(\"Get root_dir\");\n        //let root_dir = unsafe { (*self.root.get()).as_ref().unwrap() };\n        Arc::clone(&self.root)\n    }\n}\n\npub struct FileWrapper(Mutex<Ext4File>);\n\nunsafe impl Send for FileWrapper {}\nunsafe impl Sync for FileWrapper {}\n\nimpl FileWrapper {\n    fn new(path: &str, types: InodeTypes) -> Self {\n        info!(\"FileWrapper new {:?} {}\", types, path);\n        //file.file_read_test(\"/test/test.txt\", &mut buf);\n\n        Self(Mutex::new(Ext4File::new(path, types)))\n    }\n\n    fn path_deal_with(&self, path: &str) -> String {\n        if path.starts_with('/') {\n            warn!(\"path_deal_with: {}\", path);\n        }\n        let p = path.trim_matches('/'); // 首尾去除\n        if p.is_empty() || p == \".\" {\n            return String::new();\n        }\n\n        if let Some(rest) = p.strip_prefix(\"./\") {\n            //if starts with \"./\"\n            return self.path_deal_with(rest);\n        }\n        let rest_p = p.replace(\"//\", \"/\");\n        if p != rest_p {\n            return self.path_deal_with(&rest_p);\n        }\n\n        //Todo ? ../\n        //注：lwext4创建文件必须提供文件path的绝对路径\n        let file = self.0.lock();\n        let path = file.get_path();\n        let fpath = String::from(path.to_str().unwrap().trim_end_matches('/')) + \"/\" + p;\n        info!(\"dealt with full path: {}\", fpath.as_str());\n        fpath\n    }\n}\n\n/// The [`VfsNodeOps`] trait provides operations on a file or a directory.\nimpl VfsNodeOps for FileWrapper {\n    fn get_attr(&self) -> VfsResult<VfsNodeAttr> {\n        let mut file = self.0.lock();\n\n        let perm = file.file_mode_get().unwrap_or(0o755);\n        let perm = VfsNodePerm::from_bits_truncate((perm as u16) & 0o777);\n\n        let vtype = file.file_type_get();\n        let vtype = match vtype {\n            InodeTypes::EXT4_INODE_MODE_FIFO => VfsNodeType::Fifo,\n            InodeTypes::EXT4_INODE_MODE_CHARDEV => VfsNodeType::CharDevice,\n            InodeTypes::EXT4_INODE_MODE_DIRECTORY => VfsNodeType::Dir,\n            InodeTypes::EXT4_INODE_MODE_BLOCKDEV => VfsNodeType::BlockDevice,\n            InodeTypes::EXT4_INODE_MODE_FILE => VfsNodeType::File,\n            InodeTypes::EXT4_INODE_MODE_SOFTLINK => VfsNodeType::SymLink,\n            InodeTypes::EXT4_INODE_MODE_SOCKET => VfsNodeType::Socket,\n            _ => {\n                warn!(\"unknown file type: {:?}\", vtype);\n                VfsNodeType::File\n            }\n        };\n\n        let size = if vtype == VfsNodeType::File {\n            let path = file.get_path();\n            let path = path.to_str().unwrap();\n            file.file_open(path, O_RDONLY)\n                .map_err(|e| <i32 as TryInto<AxError>>::try_into(e).unwrap())?;\n            let fsize = file.file_size();\n            let _ = file.file_close();\n            fsize\n        } else {\n            0 // DIR size ?\n        };\n        let blocks = (size + (BLOCK_SIZE as u64 - 1)) / BLOCK_SIZE as u64;\n\n        let inode = file.get_inode().unwrap();\n        info!(\n            \"get_attr of {:?} {:?}, size: {}, blocks: {}\",\n            vtype,\n            file.get_path(),\n            size,\n            blocks,\n        );\n\n        Ok(VfsNodeAttr::new(perm, vtype, size, blocks, inode.st_ino(), inode.nlink(), inode.uid(), inode.gid(), inode.nblk_lo()))\n    }\n\n    fn create(&self, path: &str, ty: VfsNodeType) -> VfsResult {\n        info!(\"create {:?} on Ext4fs: {}\", ty, path);\n        let fpath = self.path_deal_with(path);\n        let fpath = fpath.as_str();\n        if fpath.is_empty() {\n            return Ok(());\n        }\n\n        let types = match ty {\n            VfsNodeType::Fifo => InodeTypes::EXT4_DE_FIFO,\n            VfsNodeType::CharDevice => InodeTypes::EXT4_DE_CHRDEV,\n            VfsNodeType::Dir => InodeTypes::EXT4_DE_DIR,\n            VfsNodeType::BlockDevice => InodeTypes::EXT4_DE_BLKDEV,\n            VfsNodeType::File => InodeTypes::EXT4_DE_REG_FILE,\n            VfsNodeType::SymLink => InodeTypes::EXT4_DE_SYMLINK,\n            VfsNodeType::Socket => InodeTypes::EXT4_DE_SOCK,\n        };\n\n        let mut file = self.0.lock();\n        if file.check_inode_exist(fpath, types.clone()) {\n            Ok(())\n        } else {\n            if types == InodeTypes::EXT4_DE_DIR {\n                file.dir_mk(fpath)\n                    .map(|_v| ())\n                    .map_err(|e| e.try_into().unwrap())\n            } else {\n                file.file_open(fpath, O_WRONLY | O_CREAT | O_TRUNC)\n                    .expect(\"create file failed\");\n                file.file_close()\n                    .map(|_v| ())\n                    .map_err(|e| e.try_into().unwrap())\n            }\n        }\n    }\n\n    fn remove(&self, path: &str) -> VfsResult {\n        info!(\"remove ext4fs: {}\", path);\n        let fpath = self.path_deal_with(path);\n        let fpath = fpath.as_str();\n\n        assert!(!fpath.is_empty()); // already check at `root.rs`\n\n        let mut file = self.0.lock();\n        if file.check_inode_exist(fpath, InodeTypes::EXT4_DE_DIR) {\n            // Recursive directory remove\n            file.dir_rm(fpath)\n                .map(|_v| ())\n                .map_err(|e| e.try_into().unwrap())\n        } else {\n            file.file_remove(fpath)\n                .map(|_v| ())\n                .map_err(|e| e.try_into().unwrap())\n        }\n    }\n\n    /// Get the parent directory of this directory.\n    /// Return `None` if the node is a file.\n    fn parent(&self) -> Option<VfsNodeRef> {\n        let file = self.0.lock();\n        if file.get_type() == InodeTypes::EXT4_DE_DIR {\n            let path = file.get_path();\n            let path = path.to_str().unwrap();\n            info!(\"Get the parent dir of {}\", path);\n            let path = path.trim_end_matches('/').trim_end_matches(|c| c != '/');\n            if !path.is_empty() {\n                return Some(Arc::new(Self::new(path, InodeTypes::EXT4_DE_DIR)));\n            }\n        }\n        None\n    }\n\n    /// Read directory entries into `dirents`, starting from `start_idx`.\n    fn read_dir(&self, start_idx: usize, dirents: &mut [VfsDirEntry]) -> VfsResult<usize> {\n        let file = self.0.lock();\n        let (name, inode_type) = file.lwext4_dir_entries().unwrap();\n\n        let mut name_iter = name.iter().skip(start_idx);\n        let mut inode_type_iter = inode_type.iter().skip(start_idx);\n\n        for (i, out_entry) in dirents.iter_mut().enumerate() {\n            let iname = name_iter.next();\n            let itypes = inode_type_iter.next();\n\n            match itypes {\n                Some(t) => {\n                    let ty = if *t == InodeTypes::EXT4_DE_DIR {\n                        VfsNodeType::Dir\n                    } else if *t == InodeTypes::EXT4_DE_REG_FILE {\n                        VfsNodeType::File\n                    } else if *t == InodeTypes::EXT4_DE_SYMLINK {\n                        VfsNodeType::SymLink\n                    } else {\n                        error!(\"unknown file type: {:?}\", itypes);\n                        unreachable!()\n                    };\n\n                    *out_entry =\n                        VfsDirEntry::new(core::str::from_utf8(iname.unwrap()).unwrap(), ty);\n                }\n                _ => return Ok(i),\n            }\n        }\n\n        Ok(dirents.len())\n    }\n\n    /// Lookup the node with given `path` in the directory.\n    /// Return the node if found.\n    fn lookup(self: Arc<Self>, path: &str) -> VfsResult<VfsNodeRef> {\n        trace!(\"lookup ext4fs: {:?}, {}\", self.0.lock().get_path(), path);\n\n        let fpath = self.path_deal_with(path);\n        let fpath = fpath.as_str();\n        if fpath.is_empty() {\n            return Ok(self.clone());\n        }\n\n        /////////\n        let mut file = self.0.lock();\n        if file.check_inode_exist(fpath, InodeTypes::EXT4_DE_DIR) {\n            trace!(\"lookup new DIR FileWrapper\");\n            Ok(Arc::new(Self::new(fpath, InodeTypes::EXT4_DE_DIR)))\n        } else if file.check_inode_exist(fpath, InodeTypes::EXT4_DE_REG_FILE) {\n            trace!(\"lookup new FILE FileWrapper\");\n            Ok(Arc::new(Self::new(fpath, InodeTypes::EXT4_DE_REG_FILE)))\n        } else {\n            Err(VfsError::NotFound)\n        }\n    }\n\n    fn read_at(&self, offset: u64, buf: &mut [u8]) -> VfsResult<usize> {\n        let mut file = self.0.lock();\n        let path = file.get_path();\n        let path = path.to_str().unwrap();\n        file.file_open(path, O_RDONLY)\n            .map_err(|e| <i32 as TryInto<AxError>>::try_into(e).unwrap())?;\n\n        file.file_seek(offset as i64, SEEK_SET)\n            .map_err(|e| <i32 as TryInto<AxError>>::try_into(e).unwrap())?;\n        let r = file.file_read(buf);\n\n        let _ = file.file_close();\n        r.map_err(|e| e.try_into().unwrap())\n    }\n\n    fn write_at(&self, offset: u64, buf: &[u8]) -> VfsResult<usize> {\n        let mut file = self.0.lock();\n        let path = file.get_path();\n        let path = path.to_str().unwrap();\n        file.file_open(path, O_RDWR)\n            .map_err(|e| <i32 as TryInto<AxError>>::try_into(e).unwrap())?;\n\n        file.file_seek(offset as i64, SEEK_SET)\n            .map_err(|e| <i32 as TryInto<AxError>>::try_into(e).unwrap())?;\n        let r = file.file_write(buf);\n\n        let _ = file.file_close();\n        r.map_err(|e| e.try_into().unwrap())\n    }\n\n    fn truncate(&self, size: u64) -> VfsResult {\n        let mut file = self.0.lock();\n        let path = file.get_path();\n        let path = path.to_str().unwrap();\n        file.file_open(path, O_RDWR | O_CREAT | O_TRUNC)\n            .map_err(|e| <i32 as TryInto<AxError>>::try_into(e).unwrap())?;\n\n        let t = file.file_truncate(size);\n\n        let _ = file.file_close();\n        t.map(|_v| ()).map_err(|e| e.try_into().unwrap())\n    }\n\n    fn rename(&self, src_path: &str, dst_path: &str) -> VfsResult {\n        let mut file = self.0.lock();\n        file.file_rename(src_path, dst_path)\n            .map(|_v| ())\n            .map_err(|e| e.try_into().unwrap())\n    }\n\n    fn as_any(&self) -> &dyn core::any::Any {\n        self as &dyn core::any::Any\n    }\n}\n\nimpl Drop for FileWrapper {\n    fn drop(&mut self) {\n        let mut file = self.0.lock();\n        trace!(\"Drop struct FileWrapper {:?}\", file.get_path());\n        file.file_close().expect(\"failed to close fd\");\n        drop(file); // todo\n    }\n}\n\nimpl KernelDevOp for Disk {\n    //type DevType = Box<Disk>;\n    type DevType = Disk;\n\n    fn read(dev: &mut Disk, mut buf: &mut [u8]) -> Result<usize, i32> {\n        trace!(\"READ block device buf={}\", buf.len());\n        let mut read_len = 0;\n        while !buf.is_empty() {\n            match dev.read_one(buf) {\n                Ok(0) => break,\n                Ok(n) => {\n                    let tmp = buf;\n                    buf = &mut tmp[n..];\n                    read_len += n;\n                }\n                Err(_e) => return Err(-1),\n            }\n        }\n        trace!(\"READ rt len={}\", read_len);\n        Ok(read_len)\n    }\n    fn write(dev: &mut Self::DevType, mut buf: &[u8]) -> Result<usize, i32> {\n        trace!(\"WRITE block device buf={}\", buf.len());\n        let mut write_len = 0;\n        while !buf.is_empty() {\n            match dev.write_one(buf) {\n                Ok(0) => break,\n                Ok(n) => {\n                    buf = &buf[n..];\n                    write_len += n;\n                }\n                Err(_e) => return Err(-1),\n            }\n        }\n        trace!(\"WRITE rt len={}\", write_len);\n        Ok(write_len)\n    }\n    fn flush(_dev: &mut Self::DevType) -> Result<usize, i32> {\n        Ok(0)\n    }\n    fn seek(dev: &mut Disk, off: i64, whence: i32) -> Result<i64, i32> {\n        let size = dev.size();\n        trace!(\n            \"SEEK block device size:{}, pos:{}, offset={}, whence={}\",\n            size,\n            &dev.position(),\n            off,\n            whence\n        );\n        let new_pos = match whence as u32 {\n            SEEK_SET => Some(off),\n            SEEK_CUR => dev.position().checked_add_signed(off).map(|v| v as i64),\n            SEEK_END => size.checked_add_signed(off).map(|v| v as i64),\n            _ => {\n                error!(\"invalid seek() whence: {}\", whence);\n                Some(off)\n            }\n        }\n        .ok_or(-1)?;\n\n        if new_pos as u64 > size {\n            warn!(\"Seek beyond the end of the block device\");\n        }\n        dev.set_position(new_pos as u64);\n        Ok(new_pos)\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/modules/axfs/src/fs/lwext4_rust.rs b/modules/axfs/src/fs/lwext4_rust.rs
--- a/modules/axfs/src/fs/lwext4_rust.rs	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/modules/axfs/src/fs/lwext4_rust.rs	(date 1747236769524)
@@ -1,5 +1,6 @@
 use crate::alloc::string::String;
 use alloc::sync::Arc;
+use core::ops::DerefMut;
 use axerrno::AxError;
 use axfs_vfs::{VfsDirEntry, VfsError, VfsNodePerm, VfsResult};
 use axfs_vfs::{VfsNodeAttr, VfsNodeOps, VfsNodeRef, VfsNodeType, VfsOps};
@@ -152,15 +153,25 @@
         let blocks = (size + (BLOCK_SIZE as u64 - 1)) / BLOCK_SIZE as u64;
 
         let inode = file.get_inode().unwrap();
-        info!(
-            "get_attr of {:?} {:?}, size: {}, blocks: {}",
-            vtype,
-            file.get_path(),
-            size,
-            blocks,
-        );
-
-        Ok(VfsNodeAttr::new(perm, vtype, size, blocks, inode.st_ino(), inode.nlink(), inode.uid(), inode.gid(), inode.nblk_lo()))
+
+        Ok(VfsNodeAttr::new(
+            inode.dev(),
+            perm, 
+            vtype, 
+            size, 
+            blocks, 
+            inode.st_ino(), 
+            inode.nlink(), 
+            inode.uid(), 
+            inode.gid(), 
+            inode.nblk_lo(),
+            inode.atime(),
+            inode.ctime(),
+            inode.mtime(),
+            inode.atime_ex(),
+            inode.ctime_ex(),
+            inode.mtime_ex(),
+        ))
     }
 
     fn create(&self, path: &str, ty: VfsNodeType) -> VfsResult {
Index: api/arceos_posix_api/src/lib.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//! POSIX-compatible APIs for [ArceOS] modules\n//!\n//! [ArceOS]: https://github.com/arceos-org/arceos\n\n#![cfg_attr(all(not(test), not(doc)), no_std)]\n#![feature(doc_cfg)]\n#![feature(doc_auto_cfg)]\n#![allow(clippy::missing_safety_doc)]\n\n#[macro_use]\nextern crate axlog;\nextern crate axruntime;\n\n#[cfg(feature = \"alloc\")]\nextern crate alloc;\n\n#[macro_use]\nmod utils;\n\nmod imp;\npub use utils::{char_ptr_to_str, str_vec_ptr_to_str};\n\n/// Platform-specific constants and parameters.\npub mod config {\n    pub use axconfig::*;\n}\n\n/// POSIX C types.\n#[rustfmt::skip]\n#[path = \"./ctypes_gen.rs\"]\n#[allow(dead_code, non_snake_case, non_camel_case_types, non_upper_case_globals, clippy::upper_case_acronyms, missing_docs)]\npub mod ctypes;\n\npub use imp::io::{sys_read, sys_write, sys_writev};\n#[cfg(feature = \"fs\")]\npub use imp::path_link::{AT_FDCWD, FilePath, HARDLINK_MANAGER, handle_file_path};\npub use imp::resources::{sys_getrlimit, sys_setrlimit};\npub use imp::sys::{UtsName, sys_sysconf, sys_uname};\npub use imp::task::{sys_exit, sys_getpid, sys_sched_yield};\npub use imp::time::{sys_clock_gettime, sys_get_time_of_day, sys_nanosleep};\n\n#[cfg(feature = \"fd\")]\npub use imp::fd_ops::{\n    FD_TABLE, add_file_like, get_file_like, sys_close, sys_dup, sys_dup2, sys_fcntl,\n};\n#[cfg(feature = \"fs\")]\npub use imp::fs::{\n    Directory, File, sys_fstat, sys_fstatat, sys_getcwd, sys_getdents, sys_lseek, sys_lstat,\n    sys_mkdirat, sys_open, sys_openat, sys_rename, sys_stat, sys_unlink, sys_unlinkat,\n};\n#[cfg(feature = \"select\")]\npub use imp::io_mpx::sys_select;\n#[cfg(feature = \"epoll\")]\npub use imp::io_mpx::{sys_epoll_create, sys_epoll_ctl, sys_epoll_wait};\n#[cfg(feature = \"net\")]\npub use imp::net::{\n    sys_accept, sys_bind, sys_connect, sys_freeaddrinfo, sys_getaddrinfo, sys_getpeername,\n    sys_getsockname, sys_listen, sys_recv, sys_recvfrom, sys_send, sys_sendto, sys_shutdown,\n    sys_socket,\n};\n#[cfg(feature = \"pipe\")]\npub use imp::pipe::sys_pipe;\n#[cfg(feature = \"multitask\")]\npub use imp::pthread::mutex::{\n    sys_pthread_mutex_init, sys_pthread_mutex_lock, sys_pthread_mutex_unlock,\n};\n#[cfg(feature = \"multitask\")]\npub use imp::pthread::{sys_pthread_create, sys_pthread_exit, sys_pthread_join, sys_pthread_self};\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/api/arceos_posix_api/src/lib.rs b/api/arceos_posix_api/src/lib.rs
--- a/api/arceos_posix_api/src/lib.rs	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/api/arceos_posix_api/src/lib.rs	(date 1745904340930)
@@ -31,22 +31,23 @@
 #[allow(dead_code, non_snake_case, non_camel_case_types, non_upper_case_globals, clippy::upper_case_acronyms, missing_docs)]
 pub mod ctypes;
 
+
 pub use imp::io::{sys_read, sys_write, sys_writev};
 #[cfg(feature = "fs")]
-pub use imp::path_link::{AT_FDCWD, FilePath, HARDLINK_MANAGER, handle_file_path};
+pub use imp::path_link::{handle_file_path, FilePath, AT_FDCWD, HARDLINK_MANAGER};
 pub use imp::resources::{sys_getrlimit, sys_setrlimit};
-pub use imp::sys::{UtsName, sys_sysconf, sys_uname};
+pub use imp::sys::{sys_sysconf, sys_uname, UtsName};
 pub use imp::task::{sys_exit, sys_getpid, sys_sched_yield};
 pub use imp::time::{sys_clock_gettime, sys_get_time_of_day, sys_nanosleep};
 
 #[cfg(feature = "fd")]
 pub use imp::fd_ops::{
-    FD_TABLE, add_file_like, get_file_like, sys_close, sys_dup, sys_dup2, sys_fcntl,
+    add_file_like, get_file_like, sys_close, sys_dup, sys_dup2, sys_fcntl, FD_TABLE,
 };
 #[cfg(feature = "fs")]
 pub use imp::fs::{
-    Directory, File, sys_fstat, sys_fstatat, sys_getcwd, sys_getdents, sys_lseek, sys_lstat,
-    sys_mkdirat, sys_open, sys_openat, sys_rename, sys_stat, sys_unlink, sys_unlinkat,
+    sys_fstat, sys_fstatat, sys_getcwd, sys_getdents, sys_lseek, sys_lstat, sys_mkdirat, sys_open,
+    sys_openat, sys_rename, sys_stat, sys_unlink, sys_unlinkat, Directory, File,
 };
 #[cfg(feature = "select")]
 pub use imp::io_mpx::sys_select;
Index: modules/axdevice/src/disk_file.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/modules/axdevice/src/disk_file.rs b/modules/axdevice/src/disk_file.rs
new file mode 100644
--- /dev/null	(date 1746937966258)
+++ b/modules/axdevice/src/disk_file.rs	(date 1746937966258)
@@ -0,0 +1,35 @@
+use crate::disk::Disk;
+use alloc::sync::Arc;
+use spin::Mutex;
+use axfs_vfs::{VfsNodeOps, VfsResult,  VfsNodeRef};
+use axfs_vfs::io::{Result as IOResult, ErrorKind, Error};
+use devfs::DeviceFile;
+
+pub struct DiskFile {
+    inner: Mutex<Disk>,
+}
+
+impl DiskFile {
+    pub fn new(dev: axdriver::prelude::AxBlockDevice) -> Self {
+        Self { inner: Mutex::new(Disk::new(dev)) }
+    }
+}
+
+impl DeviceFile for DiskFile {
+    fn read(&self, pos: usize, buf: &mut [u8]) -> IOResult<usize> {
+        let mut disk = self.inner.lock();
+        disk.set_position(pos as u64);
+        disk.read_one(buf).map_err(|_| Error::new(ErrorKind::Other, "dev read failed"))
+    }
+
+    fn write(&self, pos: usize, buf: &[u8]) -> IOResult<usize> {
+        let mut disk = self.inner.lock();
+        disk.set_position(pos as u64);
+        disk.write_one(buf).map_err(|_| Error::new(ErrorKind::Other, "dev write failed"))
+    }
+}
+
+// 通过 wrapper Node 暴露为 devfs 的节点
+pub fn make_disk_dev_node(file: Arc<dyn DeviceFile>) -> VfsNodeRef {
+    Arc::new(devfs::DeviceNode::new(file))
+}
Index: modules/axdevice/src/disk.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/modules/axdevice/src/disk.rs b/modules/axdevice/src/disk.rs
new file mode 100644
--- /dev/null	(date 1746879913759)
+++ b/modules/axdevice/src/disk.rs	(date 1746879913759)
@@ -0,0 +1,122 @@
+use axdriver::prelude::*;
+
+const BLOCK_SIZE: usize = 512;
+
+/// A disk device with a cursor.
+pub struct Disk {
+    block_id: u64,
+    offset: usize,
+    dev: AxBlockDevice,
+}
+
+impl Disk {
+    /// Create a new disk.
+    pub fn new(dev: AxBlockDevice) -> Self {
+        assert_eq!(BLOCK_SIZE, dev.block_size());
+        Self {
+            block_id: 0,
+            offset: 0,
+            dev,
+        }
+    }
+
+    /// Get the size of the disk.
+    pub fn size(&self) -> u64 {
+        self.dev.num_blocks() * BLOCK_SIZE as u64
+    }
+
+    /// Get the position of the cursor.
+    pub fn position(&self) -> u64 {
+        self.block_id * BLOCK_SIZE as u64 + self.offset as u64
+    }
+
+    /// Set the position of the cursor.
+    pub fn set_position(&mut self, pos: u64) {
+        self.block_id = pos / BLOCK_SIZE as u64;
+        self.offset = pos as usize % BLOCK_SIZE;
+    }
+
+    /// Read within one block, returns the number of bytes read.
+    pub fn read_one(&mut self, buf: &mut [u8]) -> DevResult<usize> {
+        let read_size = if self.offset == 0 && buf.len() >= BLOCK_SIZE {
+            // whole block
+            let mut data = [0u8; BLOCK_SIZE];
+            self.dev.read_block(self.block_id, &mut data)?;
+            buf[0..BLOCK_SIZE].copy_from_slice(&data);
+            // self.dev
+            //     .read_block(self.block_id, &mut buf[0..BLOCK_SIZE])?;
+            self.block_id += 1;
+            BLOCK_SIZE
+        } else {
+            // partial block
+            let mut data = [0u8; BLOCK_SIZE];
+            let start = self.offset;
+            let count = buf.len().min(BLOCK_SIZE - self.offset);
+
+            self.dev.read_block(self.block_id, &mut data)?;
+            buf[..count].copy_from_slice(&data[start..start + count]);
+
+            self.offset += count;
+            if self.offset >= BLOCK_SIZE {
+                self.block_id += 1;
+                self.offset -= BLOCK_SIZE;
+            }
+            count
+        };
+        Ok(read_size)
+    }
+
+    /// Write within one block, returns the number of bytes written.
+    pub fn write_one(&mut self, buf: &[u8]) -> DevResult<usize> {
+        let write_size = if self.offset == 0 && buf.len() >= BLOCK_SIZE {
+            // whole block
+            self.dev.write_block(self.block_id, &buf[0..BLOCK_SIZE])?;
+            self.block_id += 1;
+            BLOCK_SIZE
+        } else {
+            // partial block
+            let mut data = [0u8; BLOCK_SIZE];
+            let start = self.offset;
+            let count = buf.len().min(BLOCK_SIZE - self.offset);
+
+            self.dev.read_block(self.block_id, &mut data)?;
+            data[start..start + count].copy_from_slice(&buf[..count]);
+            self.dev.write_block(self.block_id, &data)?;
+
+            self.offset += count;
+            if self.offset >= BLOCK_SIZE {
+                self.block_id += 1;
+                self.offset -= BLOCK_SIZE;
+            }
+            count
+        };
+        Ok(write_size)
+    }
+
+    /// Read a single block starting from the specified offset.
+    #[allow(unused)]
+    pub fn read_offset(&mut self, offset: usize) -> [u8; BLOCK_SIZE] {
+        let block_id = offset / BLOCK_SIZE;
+        let mut block_data = [0u8; BLOCK_SIZE];
+        self.dev
+            .read_block(block_id as u64, &mut block_data)
+            .unwrap();
+        block_data
+    }
+
+    /// Write single block starting from the specified offset.
+    #[allow(unused)]
+    pub fn write_offset(&mut self, offset: usize, buf: &[u8]) -> DevResult<usize> {
+        assert!(
+            buf.len() == BLOCK_SIZE,
+            "Buffer length must be equal to BLOCK_SIZE"
+        );
+        assert!(offset % BLOCK_SIZE == 0);
+        let block_id = offset / BLOCK_SIZE;
+        self.dev.write_block(block_id as u64, buf).unwrap();
+        Ok(buf.len())
+    }
+}
+
+unsafe impl Send for Disk {}
+unsafe impl Sync for Disk {}
Index: .gitmodules
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[submodule \"crates/axmm_crates\"]\n\tpath = crates/axmm_crates\n\turl = git@github.com:AstranciA/axmm_crates.git\n[submodule \"crates/page_table_multiarch\"]\n\tpath = crates/page_table_multiarch\n\turl = git@github.com:AstranciA/page_table_multiarch.git\n\n[submodule \"crates/axfs_crates\"]\n\tpath = crates/axfs_crates\n\turl = https://github.com/MukioXun/axfs_crates.git\n[submodule \"crates/lwext4_rust\"]\n\tpath = crates/lwext4_rust\n\turl = https://github.com/MukioXun/lwext4_rust.git\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.gitmodules b/.gitmodules
--- a/.gitmodules	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/.gitmodules	(date 1746637255014)
@@ -11,3 +11,6 @@
 [submodule "crates/lwext4_rust"]
 	path = crates/lwext4_rust
 	url = https://github.com/MukioXun/lwext4_rust.git
+[submodule "crates/axdriver_crates"]
+	path = crates/axdriver_crates
+	url = https://github.com/MukioXun/axdriver_crates.git
Index: Cargo.lock
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\nversion = 4\n\n[[package]]\nname = \"aarch64-cpu\"\nversion = \"9.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ac42a04a61c19fc8196dd728022a784baecc5d63d7e256c01ad1b3fbfab26287\"\ndependencies = [\n \"tock-registers 0.8.1\",\n]\n\n[[package]]\nname = \"aarch64-cpu\"\nversion = \"10.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6a21cd0131c25c438e19cd6a774adf7e3f64f7f4d723022882facc2dee0f8bc9\"\ndependencies = [\n \"tock-registers 0.9.0\",\n]\n\n[[package]]\nname = \"aho-corasick\"\nversion = \"1.1.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916\"\ndependencies = [\n \"memchr\",\n]\n\n[[package]]\nname = \"allocator\"\nversion = \"0.1.1\"\nsource = \"git+https://github.com/arceos-org/allocator.git?tag=v0.1.1#1d5b7a1b4fd8db4c9c9cea4e6012d15d42e2bf40\"\ndependencies = [\n \"bitmap-allocator\",\n \"buddy_system_allocator\",\n \"cfg-if\",\n \"rlsf\",\n \"slab_allocator\",\n]\n\n[[package]]\nname = \"android-tzdata\"\nversion = \"0.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0\"\n\n[[package]]\nname = \"android_system_properties\"\nversion = \"0.1.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"anstream\"\nversion = \"0.6.18\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8acc5369981196006228e28809f761875c0327210a891e941f4c683b3a99529b\"\ndependencies = [\n \"anstyle\",\n \"anstyle-parse\",\n \"anstyle-query\",\n \"anstyle-wincon\",\n \"colorchoice\",\n \"is_terminal_polyfill\",\n \"utf8parse\",\n]\n\n[[package]]\nname = \"anstyle\"\nversion = \"1.0.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"55cc3b69f167a1ef2e161439aa98aed94e6028e5f9a59be9a6ffb47aef1651f9\"\n\n[[package]]\nname = \"anstyle-parse\"\nversion = \"0.2.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3b2d16507662817a6a20a9ea92df6652ee4f94f914589377d69f3b21bc5798a9\"\ndependencies = [\n \"utf8parse\",\n]\n\n[[package]]\nname = \"anstyle-query\"\nversion = \"1.1.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"79947af37f4177cfead1110013d678905c37501914fba0efea834c3fe9a8d60c\"\ndependencies = [\n \"windows-sys\",\n]\n\n[[package]]\nname = \"anstyle-wincon\"\nversion = \"3.0.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ca3534e77181a9cc07539ad51f2141fe32f6c3ffd4df76db8ad92346b003ae4e\"\ndependencies = [\n \"anstyle\",\n \"once_cell\",\n \"windows-sys\",\n]\n\n[[package]]\nname = \"arceos-helloworld\"\nversion = \"0.1.0\"\ndependencies = [\n \"axstd\",\n \"axsyscall\",\n]\n\n[[package]]\nname = \"arceos-httpclient\"\nversion = \"0.1.0\"\ndependencies = [\n \"axstd\",\n]\n\n[[package]]\nname = \"arceos-httpserver\"\nversion = \"0.1.0\"\ndependencies = [\n \"axstd\",\n]\n\n[[package]]\nname = \"arceos-shell\"\nversion = \"0.1.0\"\ndependencies = [\n \"axfs_ramfs\",\n \"axfs_vfs\",\n \"axstd\",\n \"crate_interface\",\n]\n\n[[package]]\nname = \"arceos_api\"\nversion = \"0.1.0\"\ndependencies = [\n \"axalloc\",\n \"axconfig\",\n \"axdisplay\",\n \"axdma\",\n \"axdriver\",\n \"axerrno\",\n \"axfeat\",\n \"axfs\",\n \"axhal\",\n \"axio\",\n \"axlog\",\n \"axmm\",\n \"axnet\",\n \"axruntime\",\n \"axsync\",\n \"axtask\",\n]\n\n[[package]]\nname = \"arceos_posix_api\"\nversion = \"0.1.0\"\ndependencies = [\n \"axalloc\",\n \"axconfig\",\n \"axerrno\",\n \"axfeat\",\n \"axfs\",\n \"axfs_vfs\",\n \"axhal\",\n \"axio\",\n \"axlog\",\n \"axnet\",\n \"axns\",\n \"axruntime\",\n \"axsync\",\n \"axtask\",\n \"bindgen\",\n \"ctor_bare\",\n \"flatten_objects\",\n \"lazy_static\",\n \"spin\",\n \"static_assertions\",\n]\n\n[[package]]\nname = \"arm_gicv2\"\nversion = \"0.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"47d25e73c949c69f75d1b9dba39c5475523403b31eb8c2fdc99da4dc33bc1aca\"\ndependencies = [\n \"tock-registers 0.8.1\",\n]\n\n[[package]]\nname = \"arm_pl011\"\nversion = \"0.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"efcf6afca4502993a737ba1e00952d1321078689da92bf7aab27d4e5756c0bec\"\ndependencies = [\n \"tock-registers 0.8.1\",\n]\n\n[[package]]\nname = \"arm_pl031\"\nversion = \"0.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"13696b1c2b59992f4223e0ae5bb173c81c63039367ca90eee845346ad2a13421\"\ndependencies = [\n \"chrono\",\n]\n\n[[package]]\nname = \"atomic-polyfill\"\nversion = \"1.0.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8cf2bce30dfe09ef0bfaef228b9d414faaf7e563035494d7fe092dba54b300f4\"\ndependencies = [\n \"critical-section\",\n]\n\n[[package]]\nname = \"autocfg\"\nversion = \"1.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26\"\n\n[[package]]\nname = \"axalloc\"\nversion = \"0.1.0\"\ndependencies = [\n \"allocator\",\n \"axerrno\",\n \"cfg-if\",\n \"kspin\",\n \"log\",\n \"memory_addr 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n]\n\n[[package]]\nname = \"axconfig\"\nversion = \"0.1.0\"\ndependencies = [\n \"axconfig-gen-macros\",\n]\n\n[[package]]\nname = \"axconfig-gen\"\nversion = \"0.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9ffa518605969ff8f4ebce2cdc3b6090345152c14987ec540601335effbf36d5\"\ndependencies = [\n \"clap\",\n \"toml_edit\",\n]\n\n[[package]]\nname = \"axconfig-gen-macros\"\nversion = \"0.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"92110c7e7a5633d7fb8a402393c91c326ad6d19710bb9cfa5ab4095e63c25948\"\ndependencies = [\n \"axconfig-gen\",\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.100\",\n]\n\n[[package]]\nname = \"axdisplay\"\nversion = \"0.1.0\"\ndependencies = [\n \"axdriver\",\n \"axdriver_display\",\n \"axsync\",\n \"lazyinit\",\n \"log\",\n]\n\n[[package]]\nname = \"axdma\"\nversion = \"0.1.0\"\ndependencies = [\n \"allocator\",\n \"axalloc\",\n \"axconfig\",\n \"axerrno\",\n \"axhal\",\n \"axmm\",\n \"kspin\",\n \"log\",\n \"memory_addr 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n]\n\n[[package]]\nname = \"axdriver\"\nversion = \"0.1.0\"\ndependencies = [\n \"axalloc\",\n \"axconfig\",\n \"axdma\",\n \"axdriver_base\",\n \"axdriver_block\",\n \"axdriver_display\",\n \"axdriver_net\",\n \"axdriver_pci\",\n \"axdriver_virtio\",\n \"axhal\",\n \"cfg-if\",\n \"crate_interface\",\n \"log\",\n]\n\n[[package]]\nname = \"axdriver_base\"\nversion = \"0.1.2\"\nsource = \"git+https://github.com/arceos-org/axdriver_crates.git?tag=v0.1.2#84eb2170f865e6fa29b78995a86f4fcdcede63df\"\n\n[[package]]\nname = \"axdriver_block\"\nversion = \"0.1.2\"\nsource = \"git+https://github.com/arceos-org/axdriver_crates.git?tag=v0.1.2#84eb2170f865e6fa29b78995a86f4fcdcede63df\"\ndependencies = [\n \"axdriver_base\",\n \"bcm2835-sdhci\",\n \"log\",\n]\n\n[[package]]\nname = \"axdriver_display\"\nversion = \"0.1.2\"\nsource = \"git+https://github.com/arceos-org/axdriver_crates.git?tag=v0.1.2#84eb2170f865e6fa29b78995a86f4fcdcede63df\"\ndependencies = [\n \"axdriver_base\",\n]\n\n[[package]]\nname = \"axdriver_net\"\nversion = \"0.1.2\"\nsource = \"git+https://github.com/arceos-org/axdriver_crates.git?tag=v0.1.2#84eb2170f865e6fa29b78995a86f4fcdcede63df\"\ndependencies = [\n \"axdriver_base\",\n \"fxmac_rs\",\n \"ixgbe-driver\",\n \"log\",\n \"spin\",\n]\n\n[[package]]\nname = \"axdriver_pci\"\nversion = \"0.1.2\"\nsource = \"git+https://github.com/arceos-org/axdriver_crates.git?tag=v0.1.2#84eb2170f865e6fa29b78995a86f4fcdcede63df\"\ndependencies = [\n \"virtio-drivers\",\n]\n\n[[package]]\nname = \"axdriver_virtio\"\nversion = \"0.1.2\"\nsource = \"git+https://github.com/arceos-org/axdriver_crates.git?tag=v0.1.2#84eb2170f865e6fa29b78995a86f4fcdcede63df\"\ndependencies = [\n \"axdriver_base\",\n \"axdriver_block\",\n \"axdriver_display\",\n \"axdriver_net\",\n \"virtio-drivers\",\n]\n\n[[package]]\nname = \"axerrno\"\nversion = \"0.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"66ccd41dd4ef364e2385901a5c2a3adea974a41eccb2529c1f24e4c8bc93d834\"\ndependencies = [\n \"log\",\n]\n\n[[package]]\nname = \"axfeat\"\nversion = \"0.1.0\"\ndependencies = [\n \"axalloc\",\n \"axdisplay\",\n \"axdriver\",\n \"axfs\",\n \"axhal\",\n \"axlog\",\n \"axnet\",\n \"axruntime\",\n \"axsync\",\n \"axtask\",\n \"kspin\",\n]\n\n[[package]]\nname = \"axfs\"\nversion = \"0.1.0\"\ndependencies = [\n \"axdriver\",\n \"axdriver_block\",\n \"axerrno\",\n \"axfs_devfs\",\n \"axfs_ramfs\",\n \"axfs_vfs\",\n \"axio\",\n \"axns\",\n \"axsync\",\n \"axtask\",\n \"cap_access\",\n \"cfg-if\",\n \"crate_interface\",\n \"fatfs\",\n \"lazyinit\",\n \"log\",\n \"lwext4_rust\",\n \"spin\",\n]\n\n[[package]]\nname = \"axfs_devfs\"\nversion = \"0.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d62eff0490e10cd2c2a74be2979820f0293fa5ebe00ee8bfd87b88ac7dd7d235\"\ndependencies = [\n \"axfs_vfs\",\n \"log\",\n \"spin\",\n]\n\n[[package]]\nname = \"axfs_ramfs\"\nversion = \"0.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"db46c6dae25a123579d5fdcdcc502d0dc2a8af86646106004c8a9181433271b1\"\ndependencies = [\n \"axfs_vfs\",\n \"log\",\n \"spin\",\n]\n\n[[package]]\nname = \"axfs_vfs\"\nversion = \"0.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2314ebe07a2fef7b1c1a7d15ab817941cd306ace651bb50024b5a8b3e8485359\"\ndependencies = [\n \"axerrno\",\n \"bitflags 2.9.0\",\n \"log\",\n]\n\n[[package]]\nname = \"axhal\"\nversion = \"0.1.0\"\ndependencies = [\n \"aarch64-cpu 10.0.0\",\n \"arm_gicv2\",\n \"arm_pl011\",\n \"arm_pl031\",\n \"axalloc\",\n \"axconfig\",\n \"axlog\",\n \"bitflags 2.9.0\",\n \"cfg-if\",\n \"dw_apb_uart\",\n \"handler_table\",\n \"int_ratio\",\n \"kernel_guard\",\n \"kspin\",\n \"lazyinit\",\n \"linkme\",\n \"log\",\n \"loongArch64\",\n \"memory_addr 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"ns16550a\",\n \"page_table_entry 0.5.4\",\n \"page_table_multiarch 0.5.4\",\n \"percpu\",\n \"raw-cpuid 11.5.0\",\n \"riscv\",\n \"riscv_goldfish\",\n \"sbi-rt\",\n \"static_assertions\",\n \"tock-registers 0.9.0\",\n \"x2apic\",\n \"x86\",\n \"x86_64 0.15.2\",\n \"x86_rtc\",\n]\n\n[[package]]\nname = \"axio\"\nversion = \"0.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"30aa258a37c25c5e9d3ff45ec80e728ff7c499586e3e40719daf7908f10fd5bd\"\ndependencies = [\n \"axerrno\",\n]\n\n[[package]]\nname = \"axlibc\"\nversion = \"0.1.0\"\ndependencies = [\n \"arceos_posix_api\",\n \"axerrno\",\n \"axfeat\",\n \"axio\",\n \"bindgen\",\n]\n\n[[package]]\nname = \"axlog\"\nversion = \"0.1.0\"\ndependencies = [\n \"axlog\",\n \"cfg-if\",\n \"chrono\",\n \"crate_interface\",\n \"kspin\",\n \"log\",\n]\n\n[[package]]\nname = \"axmm\"\nversion = \"0.1.0\"\ndependencies = [\n \"axalloc\",\n \"axconfig\",\n \"axerrno\",\n \"axhal\",\n \"bitflags 2.9.0\",\n \"kspin\",\n \"lazyinit\",\n \"log\",\n \"memory_addr 0.3.2\",\n \"memory_set\",\n \"page_table_multiarch 0.5.3\",\n]\n\n[[package]]\nname = \"axmono\"\nversion = \"0.1.0\"\ndependencies = [\n \"arceos_posix_api\",\n \"axconfig\",\n \"axerrno\",\n \"axfeat\",\n \"axfs\",\n \"axhal\",\n \"axlog\",\n \"axmm\",\n \"axns\",\n \"axsync\",\n \"axsyscall\",\n \"axtask\",\n \"bitflags 2.9.0\",\n \"crate_interface\",\n \"kernel-elf-parser\",\n \"linkme\",\n \"memory_addr 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"numeric-enum-macro\",\n \"page_table_entry 0.5.4\",\n \"page_table_multiarch 0.5.4\",\n \"syscalls\",\n \"xmas-elf\",\n]\n\n[[package]]\nname = \"axnet\"\nversion = \"0.1.0\"\ndependencies = [\n \"axdriver\",\n \"axdriver_net\",\n \"axerrno\",\n \"axhal\",\n \"axio\",\n \"axsync\",\n \"axtask\",\n \"cfg-if\",\n \"lazyinit\",\n \"log\",\n \"smoltcp\",\n \"spin\",\n]\n\n[[package]]\nname = \"axns\"\nversion = \"0.1.0\"\ndependencies = [\n \"axns\",\n \"crate_interface\",\n \"lazyinit\",\n]\n\n[[package]]\nname = \"axruntime\"\nversion = \"0.1.0\"\ndependencies = [\n \"axalloc\",\n \"axconfig\",\n \"axdisplay\",\n \"axdriver\",\n \"axfs\",\n \"axhal\",\n \"axlog\",\n \"axmm\",\n \"axnet\",\n \"axtask\",\n \"chrono\",\n \"crate_interface\",\n \"ctor_bare\",\n \"kernel_guard\",\n \"percpu\",\n]\n\n[[package]]\nname = \"axstd\"\nversion = \"0.1.0\"\ndependencies = [\n \"arceos_api\",\n \"axerrno\",\n \"axfeat\",\n \"axio\",\n \"kspin\",\n]\n\n[[package]]\nname = \"axsync\"\nversion = \"0.1.0\"\ndependencies = [\n \"axsync\",\n \"axtask\",\n \"kspin\",\n \"rand\",\n]\n\n[[package]]\nname = \"axsyscall\"\nversion = \"0.1.0\"\ndependencies = [\n \"arceos_posix_api\",\n \"axconfig\",\n \"axerrno\",\n \"axfs\",\n \"axhal\",\n \"axlog\",\n \"axmm\",\n \"axtask\",\n \"linkme\",\n \"syscalls\",\n]\n\n[[package]]\nname = \"axtask\"\nversion = \"0.1.0\"\ndependencies = [\n \"axconfig\",\n \"axhal\",\n \"axtask\",\n \"cfg-if\",\n \"cpumask\",\n \"crate_interface\",\n \"kernel_guard\",\n \"kspin\",\n \"lazyinit\",\n \"log\",\n \"memory_addr 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"percpu\",\n \"rand\",\n \"scheduler\",\n \"timer_list\",\n]\n\n[[package]]\nname = \"base64\"\nversion = \"0.13.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9e1b586273c5702936fe7b7d6896644d8be71e6314cfe09d3167c95f712589e8\"\n\n[[package]]\nname = \"bcm2835-sdhci\"\nversion = \"0.1.0\"\nsource = \"git+https://github.com/lhw2002426/bcm2835-sdhci.git?rev=e974f16#e974f168efa72b470a01f61bdef32240c66f54fc\"\ndependencies = [\n \"aarch64-cpu 9.4.0\",\n \"log\",\n \"tock-registers 0.8.1\",\n \"volatile 0.2.7\",\n]\n\n[[package]]\nname = \"bindgen\"\nversion = \"0.69.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"271383c67ccabffb7381723dea0672a673f292304fcb45c01cc648c7a8d58088\"\ndependencies = [\n \"bitflags 2.9.0\",\n \"cexpr\",\n \"clang-sys\",\n \"itertools\",\n \"lazy_static\",\n \"lazycell\",\n \"log\",\n \"prettyplease\",\n \"proc-macro2\",\n \"quote\",\n \"regex\",\n \"rustc-hash\",\n \"shlex\",\n \"syn 2.0.100\",\n \"which\",\n]\n\n[[package]]\nname = \"bit\"\nversion = \"0.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2b645c5c09a7d4035949cfce1a915785aaad6f17800c35fda8a8c311c491f284\"\n\n[[package]]\nname = \"bit_field\"\nversion = \"0.10.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dc827186963e592360843fb5ba4b973e145841266c1357f7180c43526f2e5b61\"\n\n[[package]]\nname = \"bitflags\"\nversion = \"1.3.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n\n[[package]]\nname = \"bitflags\"\nversion = \"2.9.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5c8214115b7bf84099f1309324e63141d4c5d7cc26862f97a0a857dbefe165bd\"\n\n[[package]]\nname = \"bitmap-allocator\"\nversion = \"0.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5553d824a3564e1c242975cfc962d15e6299bfa4a90c44c14208673c16df51f3\"\ndependencies = [\n \"bit_field\",\n]\n\n[[package]]\nname = \"bitmaps\"\nversion = \"3.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a1d084b0137aaa901caf9f1e8b21daa6aa24d41cd806e111335541eff9683bd6\"\n\n[[package]]\nname = \"buddy_system_allocator\"\nversion = \"0.10.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a7913f22349ffcfc6ca0ca9a656ec26cfbba538ed49c31a273dff2c5d1ea83d9\"\n\n[[package]]\nname = \"bumpalo\"\nversion = \"3.17.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1628fb46dfa0b37568d12e5edd512553eccf6a22a78e8bde00bb4aed84d5bdbf\"\n\n[[package]]\nname = \"byteorder\"\nversion = \"1.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b\"\n\n[[package]]\nname = \"cap_access\"\nversion = \"0.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c9b24894fa5f73bbf9c72196e7f495a1f81d6218a548280a09ada4a937157692\"\ndependencies = [\n \"bitflags 2.9.0\",\n]\n\n[[package]]\nname = \"cc\"\nversion = \"1.2.17\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1fcb57c740ae1daf453ae85f16e37396f672b039e00d9d866e07ddb24e328e3a\"\ndependencies = [\n \"shlex\",\n]\n\n[[package]]\nname = \"cexpr\"\nversion = \"0.6.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766\"\ndependencies = [\n \"nom\",\n]\n\n[[package]]\nname = \"cfg-if\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n\n[[package]]\nname = \"chrono\"\nversion = \"0.4.40\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1a7964611d71df112cb1730f2ee67324fcf4d0fc6606acbbe9bfe06df124637c\"\ndependencies = [\n \"android-tzdata\",\n \"iana-time-zone\",\n \"js-sys\",\n \"num-traits\",\n \"wasm-bindgen\",\n \"windows-link\",\n]\n\n[[package]]\nname = \"clang-sys\"\nversion = \"1.8.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0b023947811758c97c59bf9d1c188fd619ad4718dcaa767947df1cadb14f39f4\"\ndependencies = [\n \"glob\",\n \"libc\",\n \"libloading\",\n]\n\n[[package]]\nname = \"clap\"\nversion = \"4.5.34\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e958897981290da2a852763fe9cdb89cd36977a5d729023127095fa94d95e2ff\"\ndependencies = [\n \"clap_builder\",\n \"clap_derive\",\n]\n\n[[package]]\nname = \"clap_builder\"\nversion = \"4.5.34\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"83b0f35019843db2160b5bb19ae09b4e6411ac33fc6a712003c33e03090e2489\"\ndependencies = [\n \"anstream\",\n \"anstyle\",\n \"clap_lex\",\n \"strsim\",\n]\n\n[[package]]\nname = \"clap_derive\"\nversion = \"4.5.32\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"09176aae279615badda0765c0c0b3f6ed53f4709118af73cf4655d85d1530cd7\"\ndependencies = [\n \"heck\",\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.100\",\n]\n\n[[package]]\nname = \"clap_lex\"\nversion = \"0.7.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f46ad14479a25103f283c0f10005961cf086d8dc42205bb44c46ac563475dca6\"\n\n[[package]]\nname = \"colorchoice\"\nversion = \"1.0.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5b63caa9aa9397e2d9480a9b13673856c78d8ac123288526c37d7839f2a86990\"\n\n[[package]]\nname = \"const-default\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0b396d1f76d455557e1218ec8066ae14bba60b4b36ecd55577ba979f5db7ecaa\"\n\n[[package]]\nname = \"core-foundation-sys\"\nversion = \"0.8.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b\"\n\n[[package]]\nname = \"core_detect\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7f8f80099a98041a3d1622845c271458a2d73e688351bf3cb999266764b81d48\"\n\n[[package]]\nname = \"cpumask\"\nversion = \"0.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fe4266f1bd910c087ff8c7848882217b2b079742877b21d29614c11c16087d70\"\ndependencies = [\n \"bitmaps\",\n]\n\n[[package]]\nname = \"crate_interface\"\nversion = \"0.1.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"70272a03a2cef15589bac05d3d15c023752f5f8f2da8be977d983a9d9e6250fb\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.100\",\n]\n\n[[package]]\nname = \"critical-section\"\nversion = \"1.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"790eea4361631c5e7d22598ecd5723ff611904e3344ce8720784c93e3d83d40b\"\n\n[[package]]\nname = \"ctor_bare\"\nversion = \"0.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e4e5ae3c454dc1efb0e5821dc17344539849391b2de18c89596ea563f1909f93\"\ndependencies = [\n \"ctor_bare_macros\",\n]\n\n[[package]]\nname = \"ctor_bare_macros\"\nversion = \"0.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9a49d5cd78b1c748184d41407b14a58af8403c13328ff2b9f49b0a418c24e3ff\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.100\",\n]\n\n[[package]]\nname = \"defmt\"\nversion = \"0.3.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"86f6162c53f659f65d00619fe31f14556a6e9f8752ccc4a41bd177ffcf3d6130\"\ndependencies = [\n \"bitflags 1.3.2\",\n \"defmt-macros\",\n]\n\n[[package]]\nname = \"defmt-macros\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9d135dd939bad62d7490b0002602d35b358dce5fd9233a709d3c1ef467d4bde6\"\ndependencies = [\n \"defmt-parser\",\n \"proc-macro-error2\",\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.100\",\n]\n\n[[package]]\nname = \"defmt-parser\"\nversion = \"0.4.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3983b127f13995e68c1e29071e5d115cd96f215ccb5e6812e3728cd6f92653b3\"\ndependencies = [\n \"thiserror\",\n]\n\n[[package]]\nname = \"dw_apb_uart\"\nversion = \"0.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f93d496c8faa9dc676ebfa225432e1e3b57645c9268ead889286546f6d39356d\"\ndependencies = [\n \"tock-registers 0.8.1\",\n]\n\n[[package]]\nname = \"either\"\nversion = \"1.15.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719\"\n\n[[package]]\nname = \"embedded-hal\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"361a90feb7004eca4019fb28352a9465666b24f840f5c3cddf0ff13920590b89\"\n\n[[package]]\nname = \"equivalent\"\nversion = \"1.0.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f\"\n\n[[package]]\nname = \"errno\"\nversion = \"0.3.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"33d852cb9b869c2a9b3df2f71a3074817f01e1844f839a144f5fcef059a4eb5d\"\ndependencies = [\n \"libc\",\n \"windows-sys\",\n]\n\n[[package]]\nname = \"fatfs\"\nversion = \"0.4.0\"\nsource = \"git+https://github.com/rafalh/rust-fatfs?rev=85f06e0#85f06e08edbd3368e1b0562f2fc1b6d178bf7b8a\"\ndependencies = [\n \"bitflags 2.9.0\",\n \"log\",\n]\n\n[[package]]\nname = \"flatten_objects\"\nversion = \"0.2.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e362dae0b64fc12551b655a09484a643461a283a078fb8a9686d1f58fa46df9a\"\ndependencies = [\n \"bitmaps\",\n]\n\n[[package]]\nname = \"fxmac_rs\"\nversion = \"0.2.0\"\nsource = \"git+https://github.com/elliott10/fxmac_rs.git?rev=0dbc3916#0dbc3916d5d5a0086916deda0c4c2dd8651c69ce\"\ndependencies = [\n \"aarch64-cpu 10.0.0\",\n \"crate_interface\",\n \"log\",\n]\n\n[[package]]\nname = \"getrandom\"\nversion = \"0.2.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7\"\ndependencies = [\n \"cfg-if\",\n \"libc\",\n \"wasi\",\n]\n\n[[package]]\nname = \"glob\"\nversion = \"0.3.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a8d1add55171497b4705a648c6b583acafb01d58050a51727785f0b2c8e0a2b2\"\n\n[[package]]\nname = \"handler_table\"\nversion = \"0.1.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"702cb690200d6303c1e1992bc648f3f3bf9c1d6a27fcf50551c513d61f339c99\"\n\n[[package]]\nname = \"hash32\"\nversion = \"0.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b0c35f58762feb77d74ebe43bdbc3210f09be9fe6742234d573bacc26ed92b67\"\ndependencies = [\n \"byteorder\",\n]\n\n[[package]]\nname = \"hashbrown\"\nversion = \"0.15.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bf151400ff0baff5465007dd2f3e717f3fe502074ca563069ce3a6629d07b289\"\n\n[[package]]\nname = \"heapless\"\nversion = \"0.7.17\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"cdc6457c0eb62c71aac4bc17216026d8410337c4126773b9c5daba343f17964f\"\ndependencies = [\n \"atomic-polyfill\",\n \"hash32\",\n \"rustc_version\",\n \"spin\",\n \"stable_deref_trait\",\n]\n\n[[package]]\nname = \"heck\"\nversion = \"0.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea\"\n\n[[package]]\nname = \"home\"\nversion = \"0.5.11\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"589533453244b0995c858700322199b2becb13b627df2851f64a2775d024abcf\"\ndependencies = [\n \"windows-sys\",\n]\n\n[[package]]\nname = \"iana-time-zone\"\nversion = \"0.1.62\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b2fd658b06e56721792c5df4475705b6cda790e9298d19d2f8af083457bcd127\"\ndependencies = [\n \"android_system_properties\",\n \"core-foundation-sys\",\n \"iana-time-zone-haiku\",\n \"js-sys\",\n \"log\",\n \"wasm-bindgen\",\n \"windows-core\",\n]\n\n[[package]]\nname = \"iana-time-zone-haiku\"\nversion = \"0.1.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f\"\ndependencies = [\n \"cc\",\n]\n\n[[package]]\nname = \"indexmap\"\nversion = \"2.8.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3954d50fe15b02142bf25d3b8bdadb634ec3948f103d04ffe3031bc8fe9d7058\"\ndependencies = [\n \"equivalent\",\n \"hashbrown\",\n]\n\n[[package]]\nname = \"int_ratio\"\nversion = \"0.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bd361c344145620f0c02e56200ca3e3a45203121447376519a9070e546b2916f\"\n\n[[package]]\nname = \"is_terminal_polyfill\"\nversion = \"1.70.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf\"\n\n[[package]]\nname = \"itertools\"\nversion = \"0.12.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ba291022dbbd398a455acf126c1e341954079855bc60dfdda641363bd6922569\"\ndependencies = [\n \"either\",\n]\n\n[[package]]\nname = \"ixgbe-driver\"\nversion = \"0.1.0\"\nsource = \"git+https://github.com/KuangjuX/ixgbe-driver.git?rev=8e5eb74#8e5eb741299d7d95c373ec745e39a1473fe84563\"\ndependencies = [\n \"bit_field\",\n \"core_detect\",\n \"log\",\n \"smoltcp\",\n \"volatile 0.3.0\",\n]\n\n[[package]]\nname = \"js-sys\"\nversion = \"0.3.77\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f\"\ndependencies = [\n \"once_cell\",\n \"wasm-bindgen\",\n]\n\n[[package]]\nname = \"kernel-elf-parser\"\nversion = \"0.3.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"102999b07d80f34c1dca0d9e8f24adaa8028708842d39a3e5b98f4f085755627\"\ndependencies = [\n \"axerrno\",\n \"cfg-if\",\n \"log\",\n \"memory_addr 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"page_table_entry 0.5.3\",\n \"xmas-elf\",\n]\n\n[[package]]\nname = \"kernel_guard\"\nversion = \"0.1.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"307e6be468f3d6b6d895e191f63c11602e4e76575ecca68325d8c8dbebe2870e\"\ndependencies = [\n \"cfg-if\",\n \"crate_interface\",\n]\n\n[[package]]\nname = \"kspin\"\nversion = \"0.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"51954c939251c5899b6e953aa0ed8903c5c0d1140fc7ce3a8fd60c931d694f6e\"\ndependencies = [\n \"cfg-if\",\n \"kernel_guard\",\n]\n\n[[package]]\nname = \"lazy_static\"\nversion = \"1.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe\"\ndependencies = [\n \"spin\",\n]\n\n[[package]]\nname = \"lazycell\"\nversion = \"1.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n\n[[package]]\nname = \"lazyinit\"\nversion = \"0.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3861aac8febbb038673bf945ee47ac67940ca741b94d1bb3ff6066af2a181338\"\n\n[[package]]\nname = \"libc\"\nversion = \"0.2.171\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c19937216e9d3aa9956d9bb8dfc0b0c8beb6058fc4f7a4dc4d850edf86a237d6\"\n\n[[package]]\nname = \"libloading\"\nversion = \"0.8.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fc2f4eb4bc735547cfed7c0a4922cbd04a4655978c09b54f1f7b228750664c34\"\ndependencies = [\n \"cfg-if\",\n \"windows-targets\",\n]\n\n[[package]]\nname = \"linked_list\"\nversion = \"0.1.0\"\nsource = \"git+https://github.com/arceos-org/linked_list.git?tag=v0.1.0#34c8db301882cecfeb56df0f7c89978dbc62f49a\"\n\n[[package]]\nname = \"linkme\"\nversion = \"0.3.32\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"22d227772b5999ddc0690e733f734f95ca05387e329c4084fe65678c51198ffe\"\ndependencies = [\n \"linkme-impl\",\n]\n\n[[package]]\nname = \"linkme-impl\"\nversion = \"0.3.32\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"71a98813fa0073a317ed6a8055dcd4722a49d9b862af828ee68449adb799b6be\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.100\",\n]\n\n[[package]]\nname = \"linux-raw-sys\"\nversion = \"0.4.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d26c52dbd32dccf2d10cac7725f8eae5296885fb5703b261f7d0a0739ec807ab\"\n\n[[package]]\nname = \"lock_api\"\nversion = \"0.4.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17\"\ndependencies = [\n \"autocfg\",\n \"scopeguard\",\n]\n\n[[package]]\nname = \"log\"\nversion = \"0.4.21\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"90ed8c1e510134f979dbc4f070f87d4313098b704861a105fe34231c70a3901c\"\n\n[[package]]\nname = \"loongArch64\"\nversion = \"0.2.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dd48200d465466664e4e899b204b77b5447d60b1ababdad3a2c49ae85417b552\"\ndependencies = [\n \"bit_field\",\n \"bitflags 1.3.2\",\n]\n\n[[package]]\nname = \"lwext4_rust\"\nversion = \"0.2.0\"\nsource = \"git+https://github.com/Azure-stars/lwext4_rust.git?rev=ee5131#ee5131ca3fbb03f39ea0878431aadb521d191122\"\ndependencies = [\n \"byteorder\",\n \"log\",\n]\n\n[[package]]\nname = \"managed\"\nversion = \"0.8.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0ca88d725a0a943b096803bd34e73a4437208b6077654cc4ecb2947a5f91618d\"\n\n[[package]]\nname = \"memchr\"\nversion = \"2.7.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3\"\n\n[[package]]\nname = \"memory_addr\"\nversion = \"0.3.2\"\n\n[[package]]\nname = \"memory_addr\"\nversion = \"0.3.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5438b8df0f13e16e1f46140de247695a95952a5a4479e47197a8711bf1063373\"\n\n[[package]]\nname = \"memory_set\"\nversion = \"0.3.2\"\ndependencies = [\n \"memory_addr 0.3.2\",\n]\n\n[[package]]\nname = \"minimal-lexical\"\nversion = \"0.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a\"\n\n[[package]]\nname = \"nom\"\nversion = \"7.1.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a\"\ndependencies = [\n \"memchr\",\n \"minimal-lexical\",\n]\n\n[[package]]\nname = \"ns16550a\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"667fbdfccff4775918606516ff6ca51b898ac0842c4bc41c960a55a9832545a6\"\n\n[[package]]\nname = \"num-traits\"\nversion = \"0.2.19\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841\"\ndependencies = [\n \"autocfg\",\n]\n\n[[package]]\nname = \"numeric-enum-macro\"\nversion = \"0.2.0\"\nsource = \"git+https://github.com/mexus/numeric-enum-macro#20aef288b2ecd2381ab6627c2a6c9e0436d8c8ff\"\n\n[[package]]\nname = \"once_cell\"\nversion = \"1.21.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d\"\n\n[[package]]\nname = \"page_table_entry\"\nversion = \"0.5.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c097d641745a066856a26eed6e486d4430bb3e32c94f1203ea09c63239b360a0\"\ndependencies = [\n \"aarch64-cpu 10.0.0\",\n \"bitflags 2.9.0\",\n \"memory_addr 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"x86_64 0.15.2\",\n]\n\n[[package]]\nname = \"page_table_entry\"\nversion = \"0.5.4\"\ndependencies = [\n \"aarch64-cpu 10.0.0\",\n \"bitflags 2.9.0\",\n \"memory_addr 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"x86_64 0.15.2\",\n]\n\n[[package]]\nname = \"page_table_multiarch\"\nversion = \"0.5.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4647889585d29762d747be0916d6d28db72967a697d142be86f187a6b496832a\"\ndependencies = [\n \"log\",\n \"memory_addr 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"page_table_entry 0.5.3\",\n \"riscv\",\n \"x86\",\n]\n\n[[package]]\nname = \"page_table_multiarch\"\nversion = \"0.5.4\"\ndependencies = [\n \"log\",\n \"memory_addr 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n \"page_table_entry 0.5.4\",\n \"riscv\",\n \"x86\",\n]\n\n[[package]]\nname = \"paste\"\nversion = \"1.0.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"57c0d7b74b563b49d38dae00a0c37d4d6de9b432382b2892f0574ddcae73fd0a\"\n\n[[package]]\nname = \"percpu\"\nversion = \"0.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"01e56c0c558952222967b592899f98765b48590e7bd7403bfd7075f73afc6ed6\"\ndependencies = [\n \"cfg-if\",\n \"kernel_guard\",\n \"percpu_macros\",\n \"spin\",\n \"x86\",\n]\n\n[[package]]\nname = \"percpu_macros\"\nversion = \"0.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8a9f4cc54a2e471ff72f1499461ba381ad4eae9cbd60d29c258545b995e406e0\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.100\",\n]\n\n[[package]]\nname = \"ppv-lite86\"\nversion = \"0.2.21\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"85eae3c4ed2f50dcfe72643da4befc30deadb458a9b590d720cde2f2b1e97da9\"\ndependencies = [\n \"zerocopy 0.8.24\",\n]\n\n[[package]]\nname = \"prettyplease\"\nversion = \"0.2.31\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5316f57387668042f561aae71480de936257848f9c43ce528e311d89a07cadeb\"\ndependencies = [\n \"proc-macro2\",\n \"syn 2.0.100\",\n]\n\n[[package]]\nname = \"proc-macro-error-attr2\"\nversion = \"2.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"96de42df36bb9bba5542fe9f1a054b8cc87e172759a1868aa05c1f3acc89dfc5\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n]\n\n[[package]]\nname = \"proc-macro-error2\"\nversion = \"2.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"11ec05c52be0a07b08061f7dd003e7d7092e0472bc731b4af7bb1ef876109802\"\ndependencies = [\n \"proc-macro-error-attr2\",\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.100\",\n]\n\n[[package]]\nname = \"proc-macro2\"\nversion = \"1.0.94\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a31971752e70b8b2686d7e46ec17fb38dad4051d94024c88df49b667caea9c84\"\ndependencies = [\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"quote\"\nversion = \"1.0.40\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d\"\ndependencies = [\n \"proc-macro2\",\n]\n\n[[package]]\nname = \"rand\"\nversion = \"0.8.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404\"\ndependencies = [\n \"libc\",\n \"rand_chacha\",\n \"rand_core\",\n]\n\n[[package]]\nname = \"rand_chacha\"\nversion = \"0.3.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88\"\ndependencies = [\n \"ppv-lite86\",\n \"rand_core\",\n]\n\n[[package]]\nname = \"rand_core\"\nversion = \"0.6.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c\"\ndependencies = [\n \"getrandom\",\n]\n\n[[package]]\nname = \"raw-cpuid\"\nversion = \"10.7.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6c297679cb867470fa8c9f67dbba74a78d78e3e98d7cf2b08d6d71540f797332\"\ndependencies = [\n \"bitflags 1.3.2\",\n]\n\n[[package]]\nname = \"raw-cpuid\"\nversion = \"11.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c6df7ab838ed27997ba19a4664507e6f82b41fe6e20be42929332156e5e85146\"\ndependencies = [\n \"bitflags 2.9.0\",\n]\n\n[[package]]\nname = \"regex\"\nversion = \"1.11.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191\"\ndependencies = [\n \"aho-corasick\",\n \"memchr\",\n \"regex-automata\",\n \"regex-syntax\",\n]\n\n[[package]]\nname = \"regex-automata\"\nversion = \"0.4.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908\"\ndependencies = [\n \"aho-corasick\",\n \"memchr\",\n \"regex-syntax\",\n]\n\n[[package]]\nname = \"regex-syntax\"\nversion = \"0.8.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c\"\n\n[[package]]\nname = \"riscv\"\nversion = \"0.12.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5ea8ff73d3720bdd0a97925f0bf79ad2744b6da8ff36be3840c48ac81191d7a7\"\ndependencies = [\n \"critical-section\",\n \"embedded-hal\",\n \"paste\",\n \"riscv-macros\",\n \"riscv-pac\",\n]\n\n[[package]]\nname = \"riscv-macros\"\nversion = \"0.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f265be5d634272320a7de94cea15c22a3bfdd4eb42eb43edc528415f066a1f25\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.100\",\n]\n\n[[package]]\nname = \"riscv-pac\"\nversion = \"0.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8188909339ccc0c68cfb5a04648313f09621e8b87dc03095454f1a11f6c5d436\"\n\n[[package]]\nname = \"riscv_goldfish\"\nversion = \"0.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"07aac72f95e774476db82916d79f2d303191310393830573c1ab5c821b21660a\"\n\n[[package]]\nname = \"rlsf\"\nversion = \"0.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"222fb240c3286247ecdee6fa5341e7cdad0ffdf8e7e401d9937f2d58482a20bf\"\ndependencies = [\n \"cfg-if\",\n \"const-default\",\n \"libc\",\n \"svgbobdoc\",\n]\n\n[[package]]\nname = \"rustc-hash\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n\n[[package]]\nname = \"rustc_version\"\nversion = \"0.4.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"cfcb3a22ef46e85b45de6ee7e79d063319ebb6594faafcf1c225ea92ab6e9b92\"\ndependencies = [\n \"semver\",\n]\n\n[[package]]\nname = \"rustix\"\nversion = \"0.38.44\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fdb5bc1ae2baa591800df16c9ca78619bf65c0488b41b96ccec5d11220d8c154\"\ndependencies = [\n \"bitflags 2.9.0\",\n \"errno\",\n \"libc\",\n \"linux-raw-sys\",\n \"windows-sys\",\n]\n\n[[package]]\nname = \"rustversion\"\nversion = \"1.0.20\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"eded382c5f5f786b989652c49544c4877d9f015cc22e145a5ea8ea66c2921cd2\"\n\n[[package]]\nname = \"sbi-rt\"\nversion = \"0.0.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7fbaa69be1eedc61c426e6d489b2260482e928b465360576900d52d496a58bd0\"\ndependencies = [\n \"sbi-spec\",\n]\n\n[[package]]\nname = \"sbi-spec\"\nversion = \"0.0.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e6e36312fb5ddc10d08ecdc65187402baba4ac34585cb9d1b78522ae2358d890\"\n\n[[package]]\nname = \"scheduler\"\nversion = \"0.1.0\"\nsource = \"git+https://github.com/arceos-org/scheduler.git?tag=v0.1.0#c8d25d9aed146dca28dc8987afd229b52c20361a\"\ndependencies = [\n \"linked_list\",\n]\n\n[[package]]\nname = \"scopeguard\"\nversion = \"1.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49\"\n\n[[package]]\nname = \"semver\"\nversion = \"1.0.26\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"56e6fa9c48d24d85fb3de5ad847117517440f6beceb7798af16b4a87d616b8d0\"\n\n[[package]]\nname = \"shlex\"\nversion = \"1.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64\"\n\n[[package]]\nname = \"slab_allocator\"\nversion = \"0.3.1\"\nsource = \"git+https://github.com/arceos-org/slab_allocator.git?tag=v0.3.1#3c13499d664ccd36f66786985b753340aea57f5a\"\ndependencies = [\n \"buddy_system_allocator\",\n]\n\n[[package]]\nname = \"smoltcp\"\nversion = \"0.10.0\"\nsource = \"git+https://github.com/rcore-os/smoltcp.git?rev=2ade274#2ade2747abc4d779d0836154b0413d13ce16cd5b\"\ndependencies = [\n \"bitflags 1.3.2\",\n \"byteorder\",\n \"cfg-if\",\n \"defmt\",\n \"heapless\",\n \"log\",\n \"managed\",\n]\n\n[[package]]\nname = \"spin\"\nversion = \"0.9.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6980e8d7511241f8acf4aebddbb1ff938df5eebe98691418c4468d0b72a96a67\"\ndependencies = [\n \"lock_api\",\n]\n\n[[package]]\nname = \"stable_deref_trait\"\nversion = \"1.2.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3\"\n\n[[package]]\nname = \"static_assertions\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f\"\n\n[[package]]\nname = \"strsim\"\nversion = \"0.11.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f\"\n\n[[package]]\nname = \"svgbobdoc\"\nversion = \"0.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f2c04b93fc15d79b39c63218f15e3fdffaa4c227830686e3b7c5f41244eb3e50\"\ndependencies = [\n \"base64\",\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n \"unicode-width\",\n]\n\n[[package]]\nname = \"syn\"\nversion = \"1.0.109\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"syn\"\nversion = \"2.0.100\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b09a44accad81e1ba1cd74a32461ba89dee89095ba17b32f5d03683b1b1fc2a0\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"syscalls\"\nversion = \"0.6.18\"\nsource = \"git+https://github.com/jasonwhite/syscalls.git#92624de3dee33427fde46da083809d7e86a721ec\"\n\n[[package]]\nname = \"thiserror\"\nversion = \"2.0.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"567b8a2dae586314f7be2a752ec7474332959c6460e02bde30d702a66d488708\"\ndependencies = [\n \"thiserror-impl\",\n]\n\n[[package]]\nname = \"thiserror-impl\"\nversion = \"2.0.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7f7cf42b4507d8ea322120659672cf1b9dbb93f8f2d4ecfd6e51350ff5b17a1d\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.100\",\n]\n\n[[package]]\nname = \"timer_list\"\nversion = \"0.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"158b52ace9609dd94f4af338f4828ff23b600d9160def8c001f2c73885521936\"\n\n[[package]]\nname = \"tock-registers\"\nversion = \"0.8.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"696941a0aee7e276a165a978b37918fd5d22c55c3d6bda197813070ca9c0f21c\"\n\n[[package]]\nname = \"tock-registers\"\nversion = \"0.9.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2b9e2fdb3a1e862c0661768b7ed25390811df1947a8acbfbefe09b47078d93c4\"\n\n[[package]]\nname = \"toml_datetime\"\nversion = \"0.6.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0dd7358ecb8fc2f8d014bf86f6f638ce72ba252a2c3a2572f2a795f1d23efb41\"\n\n[[package]]\nname = \"toml_edit\"\nversion = \"0.22.24\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"17b4795ff5edd201c7cd6dca065ae59972ce77d1b80fa0a84d94950ece7d1474\"\ndependencies = [\n \"indexmap\",\n \"toml_datetime\",\n \"winnow\",\n]\n\n[[package]]\nname = \"unicode-ident\"\nversion = \"1.0.18\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512\"\n\n[[package]]\nname = \"unicode-width\"\nversion = \"0.1.14\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7dd6e30e90baa6f72411720665d41d89b9a3d039dc45b8faea1ddd07f617f6af\"\n\n[[package]]\nname = \"utf8parse\"\nversion = \"0.2.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821\"\n\n[[package]]\nname = \"virtio-drivers\"\nversion = \"0.7.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"aa40e09453618c7a927c08c5a990497a2954da7c2aaa6c65e0d4f0fc975f6114\"\ndependencies = [\n \"bitflags 2.9.0\",\n \"log\",\n \"zerocopy 0.7.35\",\n]\n\n[[package]]\nname = \"volatile\"\nversion = \"0.2.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f6b06ad3ed06fef1713569d547cdbdb439eafed76341820fb0e0344f29a41945\"\n\n[[package]]\nname = \"volatile\"\nversion = \"0.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f8e76fae08f03f96e166d2dfda232190638c10e0383841252416f9cfe2ae60e6\"\n\n[[package]]\nname = \"volatile\"\nversion = \"0.4.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"442887c63f2c839b346c192d047a7c87e73d0689c9157b00b53dcc27dd5ea793\"\n\n[[package]]\nname = \"wasi\"\nversion = \"0.11.0+wasi-snapshot-preview1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n\n[[package]]\nname = \"wasm-bindgen\"\nversion = \"0.2.100\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5\"\ndependencies = [\n \"cfg-if\",\n \"once_cell\",\n \"rustversion\",\n \"wasm-bindgen-macro\",\n]\n\n[[package]]\nname = \"wasm-bindgen-backend\"\nversion = \"0.2.100\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6\"\ndependencies = [\n \"bumpalo\",\n \"log\",\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.100\",\n \"wasm-bindgen-shared\",\n]\n\n[[package]]\nname = \"wasm-bindgen-macro\"\nversion = \"0.2.100\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407\"\ndependencies = [\n \"quote\",\n \"wasm-bindgen-macro-support\",\n]\n\n[[package]]\nname = \"wasm-bindgen-macro-support\"\nversion = \"0.2.100\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.100\",\n \"wasm-bindgen-backend\",\n \"wasm-bindgen-shared\",\n]\n\n[[package]]\nname = \"wasm-bindgen-shared\"\nversion = \"0.2.100\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d\"\ndependencies = [\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"which\"\nversion = \"4.4.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"87ba24419a2078cd2b0f2ede2691b6c66d8e47836da3b6db8265ebad47afbfc7\"\ndependencies = [\n \"either\",\n \"home\",\n \"once_cell\",\n \"rustix\",\n]\n\n[[package]]\nname = \"windows-core\"\nversion = \"0.52.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9\"\ndependencies = [\n \"windows-targets\",\n]\n\n[[package]]\nname = \"windows-link\"\nversion = \"0.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"76840935b766e1b0a05c0066835fb9ec80071d4c09a16f6bd5f7e655e3c14c38\"\n\n[[package]]\nname = \"windows-sys\"\nversion = \"0.59.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b\"\ndependencies = [\n \"windows-targets\",\n]\n\n[[package]]\nname = \"windows-targets\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973\"\ndependencies = [\n \"windows_aarch64_gnullvm\",\n \"windows_aarch64_msvc\",\n \"windows_i686_gnu\",\n \"windows_i686_gnullvm\",\n \"windows_i686_msvc\",\n \"windows_x86_64_gnu\",\n \"windows_x86_64_gnullvm\",\n \"windows_x86_64_msvc\",\n]\n\n[[package]]\nname = \"windows_aarch64_gnullvm\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3\"\n\n[[package]]\nname = \"windows_aarch64_msvc\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469\"\n\n[[package]]\nname = \"windows_i686_gnu\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b\"\n\n[[package]]\nname = \"windows_i686_gnullvm\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66\"\n\n[[package]]\nname = \"windows_i686_msvc\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66\"\n\n[[package]]\nname = \"windows_x86_64_gnu\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78\"\n\n[[package]]\nname = \"windows_x86_64_gnullvm\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d\"\n\n[[package]]\nname = \"windows_x86_64_msvc\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec\"\n\n[[package]]\nname = \"winnow\"\nversion = \"0.7.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0e97b544156e9bebe1a0ffbc03484fc1ffe3100cbce3ffb17eac35f7cdd7ab36\"\ndependencies = [\n \"memchr\",\n]\n\n[[package]]\nname = \"x2apic\"\nversion = \"0.4.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"cbcd582541cbb8ef1dfc24a3c849a64ff074b1b512af723ad90056558d424602\"\ndependencies = [\n \"bit\",\n \"bitflags 1.3.2\",\n \"paste\",\n \"raw-cpuid 10.7.0\",\n \"x86_64 0.14.13\",\n]\n\n[[package]]\nname = \"x86\"\nversion = \"0.52.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2781db97787217ad2a2845c396a5efe286f87467a5810836db6d74926e94a385\"\ndependencies = [\n \"bit_field\",\n \"bitflags 1.3.2\",\n \"raw-cpuid 10.7.0\",\n]\n\n[[package]]\nname = \"x86_64\"\nversion = \"0.14.13\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c101112411baafbb4bf8d33e4c4a80ab5b02d74d2612331c61e8192fc9710491\"\ndependencies = [\n \"bit_field\",\n \"bitflags 2.9.0\",\n \"rustversion\",\n \"volatile 0.4.6\",\n]\n\n[[package]]\nname = \"x86_64\"\nversion = \"0.15.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0f042214de98141e9c8706e8192b73f56494087cc55ebec28ce10f26c5c364ae\"\ndependencies = [\n \"bit_field\",\n \"bitflags 2.9.0\",\n \"rustversion\",\n \"volatile 0.4.6\",\n]\n\n[[package]]\nname = \"x86_rtc\"\nversion = \"0.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d1a42420da20c01d82e5d42231570efa3b9e16a5515eaaf9ee4e964f49cc1313\"\ndependencies = [\n \"cfg-if\",\n \"x86_64 0.15.2\",\n]\n\n[[package]]\nname = \"xmas-elf\"\nversion = \"0.9.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"42c49817e78342f7f30a181573d82ff55b88a35f86ccaf07fc64b3008f56d1c6\"\ndependencies = [\n \"zero\",\n]\n\n[[package]]\nname = \"zero\"\nversion = \"0.1.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2fe21bcc34ca7fe6dd56cc2cb1261ea59d6b93620215aefb5ea6032265527784\"\n\n[[package]]\nname = \"zerocopy\"\nversion = \"0.7.35\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1b9b4fd18abc82b8136838da5d50bae7bdea537c574d8dc1a34ed098d6c166f0\"\ndependencies = [\n \"byteorder\",\n \"zerocopy-derive 0.7.35\",\n]\n\n[[package]]\nname = \"zerocopy\"\nversion = \"0.8.24\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2586fea28e186957ef732a5f8b3be2da217d65c5969d4b1e17f973ebbe876879\"\ndependencies = [\n \"zerocopy-derive 0.8.24\",\n]\n\n[[package]]\nname = \"zerocopy-derive\"\nversion = \"0.7.35\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fa4f8080344d4671fb4e831a13ad1e68092748387dfc4f55e356242fae12ce3e\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.100\",\n]\n\n[[package]]\nname = \"zerocopy-derive\"\nversion = \"0.8.24\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a996a8f63c5c4448cd959ac1bab0aaa3306ccfd060472f85943ee0750f0169be\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.100\",\n]\n\n[[patch.unused]]\nname = \"axfs_devfs\"\nversion = \"0.1.0\"\n\n[[patch.unused]]\nname = \"axfs_ramfs\"\nversion = \"0.1.0\"\n\n[[patch.unused]]\nname = \"axfs_vfs\"\nversion = \"0.1.0\"\n\n[[patch.unused]]\nname = \"lwext4_rust\"\nversion = \"0.2.0\"\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Cargo.lock b/Cargo.lock
--- a/Cargo.lock	(revision efb43336559eebb72ca2eea3a3d43538837cb9b1)
+++ b/Cargo.lock	(date 1747330923483)
@@ -269,12 +269,24 @@
  "syn 2.0.100",
 ]
 
+[[package]]
+name = "axdevice"
+version = "0.1.0"
+dependencies = [
+ "axdriver",
+ "axdriver_block 0.1.2",
+ "axfs_vfs",
+ "axns",
+ "axsync",
+ "spin",
+]
+
 [[package]]
 name = "axdisplay"
 version = "0.1.0"
 dependencies = [
  "axdriver",
- "axdriver_display",
+ "axdriver_display 0.1.2",
  "axsync",
  "lazyinit",
  "log",
@@ -302,10 +314,10 @@
  "axalloc",
  "axconfig",
  "axdma",
- "axdriver_base",
- "axdriver_block",
- "axdriver_display",
- "axdriver_net",
+ "axdriver_base 0.1.0",
+ "axdriver_block 0.1.0",
+ "axdriver_display 0.1.0",
+ "axdriver_net 0.1.0",
  "axdriver_pci",
  "axdriver_virtio",
  "axhal",
@@ -314,35 +326,53 @@
  "log",
 ]
 
+[[package]]
+name = "axdriver_base"
+version = "0.1.0"
+
 [[package]]
 name = "axdriver_base"
 version = "0.1.2"
 source = "git+https://github.com/arceos-org/axdriver_crates.git?tag=v0.1.2#84eb2170f865e6fa29b78995a86f4fcdcede63df"
 
+[[package]]
+name = "axdriver_block"
+version = "0.1.0"
+dependencies = [
+ "axdriver_base 0.1.0",
+ "bcm2835-sdhci",
+ "log",
+]
+
 [[package]]
 name = "axdriver_block"
 version = "0.1.2"
 source = "git+https://github.com/arceos-org/axdriver_crates.git?tag=v0.1.2#84eb2170f865e6fa29b78995a86f4fcdcede63df"
 dependencies = [
- "axdriver_base",
- "bcm2835-sdhci",
+ "axdriver_base 0.1.2",
  "log",
 ]
 
+[[package]]
+name = "axdriver_display"
+version = "0.1.0"
+dependencies = [
+ "axdriver_base 0.1.0",
+]
+
 [[package]]
 name = "axdriver_display"
 version = "0.1.2"
 source = "git+https://github.com/arceos-org/axdriver_crates.git?tag=v0.1.2#84eb2170f865e6fa29b78995a86f4fcdcede63df"
 dependencies = [
- "axdriver_base",
+ "axdriver_base 0.1.2",
 ]
 
 [[package]]
 name = "axdriver_net"
-version = "0.1.2"
-source = "git+https://github.com/arceos-org/axdriver_crates.git?tag=v0.1.2#84eb2170f865e6fa29b78995a86f4fcdcede63df"
+version = "0.1.0"
 dependencies = [
- "axdriver_base",
+ "axdriver_base 0.1.0",
  "fxmac_rs",
  "ixgbe-driver",
  "log",
@@ -350,22 +380,30 @@
 ]
 
 [[package]]
-name = "axdriver_pci"
+name = "axdriver_net"
 version = "0.1.2"
 source = "git+https://github.com/arceos-org/axdriver_crates.git?tag=v0.1.2#84eb2170f865e6fa29b78995a86f4fcdcede63df"
 dependencies = [
+ "axdriver_base 0.1.2",
+ "log",
+ "spin",
+]
+
+[[package]]
+name = "axdriver_pci"
+version = "0.1.0"
+dependencies = [
  "virtio-drivers",
 ]
 
 [[package]]
 name = "axdriver_virtio"
-version = "0.1.2"
-source = "git+https://github.com/arceos-org/axdriver_crates.git?tag=v0.1.2#84eb2170f865e6fa29b78995a86f4fcdcede63df"
+version = "0.1.0"
 dependencies = [
- "axdriver_base",
- "axdriver_block",
- "axdriver_display",
- "axdriver_net",
+ "axdriver_base 0.1.0",
+ "axdriver_block 0.1.0",
+ "axdriver_display 0.1.0",
+ "axdriver_net 0.1.0",
  "virtio-drivers",
 ]
 
@@ -400,7 +438,7 @@
 version = "0.1.0"
 dependencies = [
  "axdriver",
- "axdriver_block",
+ "axdriver_block 0.1.0",
  "axerrno",
  "axfs_devfs",
  "axfs_ramfs",
@@ -421,9 +459,7 @@
 
 [[package]]
 name = "axfs_devfs"
-version = "0.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d62eff0490e10cd2c2a74be2979820f0293fa5ebe00ee8bfd87b88ac7dd7d235"
+version = "0.1.0"
 dependencies = [
  "axfs_vfs",
  "log",
@@ -432,9 +468,7 @@
 
 [[package]]
 name = "axfs_ramfs"
-version = "0.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "db46c6dae25a123579d5fdcdcc502d0dc2a8af86646106004c8a9181433271b1"
+version = "0.1.0"
 dependencies = [
  "axfs_vfs",
  "log",
@@ -443,9 +477,7 @@
 
 [[package]]
 name = "axfs_vfs"
-version = "0.1.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2314ebe07a2fef7b1c1a7d15ab817941cd306ace651bb50024b5a8b3e8485359"
+version = "0.1.0"
 dependencies = [
  "axerrno",
  "bitflags 2.9.0",
@@ -476,8 +508,8 @@
  "loongArch64",
  "memory_addr 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "ns16550a",
- "page_table_entry 0.5.4",
- "page_table_multiarch 0.5.4",
+ "page_table_entry",
+ "page_table_multiarch",
  "percpu",
  "raw-cpuid 11.5.0",
  "riscv",
@@ -537,7 +569,7 @@
  "log",
  "memory_addr 0.3.2",
  "memory_set",
- "page_table_multiarch 0.5.3",
+ "page_table_multiarch",
 ]
 
 [[package]]
@@ -562,8 +594,8 @@
  "linkme",
  "memory_addr 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "numeric-enum-macro",
- "page_table_entry 0.5.4",
- "page_table_multiarch 0.5.4",
+ "page_table_entry",
+ "page_table_multiarch",
  "syscalls",
  "xmas-elf",
 ]
@@ -573,7 +605,7 @@
 version = "0.1.0"
 dependencies = [
  "axdriver",
- "axdriver_net",
+ "axdriver_net 0.1.2",
  "axerrno",
  "axhal",
  "axio",
@@ -782,9 +814,9 @@
 
 [[package]]
 name = "cc"
-version = "1.2.17"
+version = "1.2.20"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1fcb57c740ae1daf453ae85f16e37396f672b039e00d9d866e07ddb24e328e3a"
+checksum = "04da6a0d40b948dfc4fa8f5bbf402b0fc1a64a28dbf7d12ffd683550f2c1b63a"
 dependencies = [
  "shlex",
 ]
@@ -831,9 +863,9 @@
 
 [[package]]
 name = "clap"
-version = "4.5.34"
+version = "4.5.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e958897981290da2a852763fe9cdb89cd36977a5d729023127095fa94d95e2ff"
+checksum = "eccb054f56cbd38340b380d4a8e69ef1f02f1af43db2f0cc817a4774d80ae071"
 dependencies = [
  "clap_builder",
  "clap_derive",
@@ -841,9 +873,9 @@
 
 [[package]]
 name = "clap_builder"
-version = "4.5.34"
+version = "4.5.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "83b0f35019843db2160b5bb19ae09b4e6411ac33fc6a712003c33e03090e2489"
+checksum = "efd9466fac8543255d3b1fcad4762c5e116ffe808c8a3043d4263cd4fd4862a2"
 dependencies = [
  "anstream",
  "anstyle",
@@ -941,9 +973,18 @@
 
 [[package]]
 name = "defmt"
-version = "0.3.10"
+version = "0.3.100"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "86f6162c53f659f65d00619fe31f14556a6e9f8752ccc4a41bd177ffcf3d6130"
+checksum = "f0963443817029b2024136fc4dd07a5107eb8f977eaf18fcd1fdeb11306b64ad"
+dependencies = [
+ "defmt 1.0.1",
+]
+
+[[package]]
+name = "defmt"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "548d977b6da32fa1d1fda2876453da1e7df63ad0304c8b3dae4dbe7b96f39b78"
 dependencies = [
  "bitflags 1.3.2",
  "defmt-macros",
@@ -951,9 +992,9 @@
 
 [[package]]
 name = "defmt-macros"
-version = "0.4.0"
+version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9d135dd939bad62d7490b0002602d35b358dce5fd9233a709d3c1ef467d4bde6"
+checksum = "3d4fc12a85bcf441cfe44344c4b72d58493178ce635338a3f3b78943aceb258e"
 dependencies = [
  "defmt-parser",
  "proc-macro-error2",
@@ -964,9 +1005,9 @@
 
 [[package]]
 name = "defmt-parser"
-version = "0.4.1"
+version = "1.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3983b127f13995e68c1e29071e5d115cd96f215ccb5e6812e3728cd6f92653b3"
+checksum = "10d60334b3b2e7c9d91ef8150abfb6fa4c1c39ebbcf4a81c2e346aad939fee3e"
 dependencies = [
  "thiserror",
 ]
@@ -1000,9 +1041,9 @@
 
 [[package]]
 name = "errno"
-version = "0.3.10"
+version = "0.3.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "33d852cb9b869c2a9b3df2f71a3074817f01e1844f839a144f5fcef059a4eb5d"
+checksum = "976dd42dc7e85965fe702eb8164f21f450704bdde31faefd6471dba214cb594e"
 dependencies = [
  "libc",
  "windows-sys",
@@ -1038,9 +1079,9 @@
 
 [[package]]
 name = "getrandom"
-version = "0.2.15"
+version = "0.2.16"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
+checksum = "335ff9f135e4384c8150d6f27c6daed433577f86b4750418338c01a1a2528592"
 dependencies = [
  "cfg-if",
  "libc",
@@ -1104,9 +1145,9 @@
 
 [[package]]
 name = "iana-time-zone"
-version = "0.1.62"
+version = "0.1.63"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b2fd658b06e56721792c5df4475705b6cda790e9298d19d2f8af083457bcd127"
+checksum = "b0c919e5debc312ad217002b8048a17b7d83f80703865bbfcfebb0458b0b27d8"
 dependencies = [
  "android_system_properties",
  "core-foundation-sys",
@@ -1128,9 +1169,9 @@
 
 [[package]]
 name = "indexmap"
-version = "2.8.0"
+version = "2.9.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3954d50fe15b02142bf25d3b8bdadb634ec3948f103d04ffe3031bc8fe9d7058"
+checksum = "cea70ddb795996207ad57735b50c5982d8844f38ba9ee5f1aedcfb708a2aa11e"
 dependencies = [
  "equivalent",
  "hashbrown",
@@ -1189,7 +1230,7 @@
  "cfg-if",
  "log",
  "memory_addr 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "page_table_entry 0.5.3",
+ "page_table_entry",
  "xmas-elf",
 ]
 
@@ -1236,9 +1277,9 @@
 
 [[package]]
 name = "libc"
-version = "0.2.171"
+version = "0.2.172"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c19937216e9d3aa9956d9bb8dfc0b0c8beb6058fc4f7a4dc4d850edf86a237d6"
+checksum = "d750af042f7ef4f724306de029d18836c26c1765a54a6a3f094cbd23a7267ffa"
 
 [[package]]
 name = "libloading"
@@ -1299,18 +1340,17 @@
 
 [[package]]
 name = "loongArch64"
-version = "0.2.4"
+version = "0.2.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dd48200d465466664e4e899b204b77b5447d60b1ababdad3a2c49ae85417b552"
+checksum = "7c9f0d275c70310e2a9d2fc23250c5ac826a73fa828a5f256401f85c5c554283"
 dependencies = [
  "bit_field",
- "bitflags 1.3.2",
+ "bitflags 2.9.0",
 ]
 
 [[package]]
 name = "lwext4_rust"
 version = "0.2.0"
-source = "git+https://github.com/Azure-stars/lwext4_rust.git?rev=ee5131#ee5131ca3fbb03f39ea0878431aadb521d191122"
 dependencies = [
  "byteorder",
  "log",
@@ -1387,18 +1427,6 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
 
-[[package]]
-name = "page_table_entry"
-version = "0.5.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c097d641745a066856a26eed6e486d4430bb3e32c94f1203ea09c63239b360a0"
-dependencies = [
- "aarch64-cpu 10.0.0",
- "bitflags 2.9.0",
- "memory_addr 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "x86_64 0.15.2",
-]
-
 [[package]]
 name = "page_table_entry"
 version = "0.5.4"
@@ -1409,26 +1437,13 @@
  "x86_64 0.15.2",
 ]
 
-[[package]]
-name = "page_table_multiarch"
-version = "0.5.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4647889585d29762d747be0916d6d28db72967a697d142be86f187a6b496832a"
-dependencies = [
- "log",
- "memory_addr 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "page_table_entry 0.5.3",
- "riscv",
- "x86",
-]
-
 [[package]]
 name = "page_table_multiarch"
 version = "0.5.4"
 dependencies = [
  "log",
  "memory_addr 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "page_table_entry 0.5.4",
+ "page_table_entry",
  "riscv",
  "x86",
 ]
@@ -1474,9 +1489,9 @@
 
 [[package]]
 name = "prettyplease"
-version = "0.2.31"
+version = "0.2.32"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5316f57387668042f561aae71480de936257848f9c43ce528e311d89a07cadeb"
+checksum = "664ec5419c51e34154eec046ebcba56312d5a2fc3b09a06da188e1ad21afadf6"
 dependencies = [
  "proc-macro2",
  "syn 2.0.100",
@@ -1506,9 +1521,9 @@
 
 [[package]]
 name = "proc-macro2"
-version = "1.0.94"
+version = "1.0.95"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a31971752e70b8b2686d7e46ec17fb38dad4051d94024c88df49b667caea9c84"
+checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
 dependencies = [
  "unicode-ident",
 ]
@@ -1738,7 +1753,7 @@
  "bitflags 1.3.2",
  "byteorder",
  "cfg-if",
- "defmt",
+ "defmt 0.3.100",
  "heapless",
  "log",
  "managed",
@@ -1809,7 +1824,8 @@
 [[package]]
 name = "syscalls"
 version = "0.6.18"
-source = "git+https://github.com/jasonwhite/syscalls.git#92624de3dee33427fde46da083809d7e86a721ec"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "43d0e35dc7d73976a53c7e6d7d177ef804a0c0ee774ec77bcc520c2216fd7cbe"
 
 [[package]]
 name = "thiserror"
@@ -1991,11 +2007,37 @@
 
 [[package]]
 name = "windows-core"
-version = "0.52.0"
+version = "0.61.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4763c1de310c86d75a878046489e2e5ba02c649d185f21c67d4cf8a56d098980"
+dependencies = [
+ "windows-implement",
+ "windows-interface",
+ "windows-link",
+ "windows-result",
+ "windows-strings",
+]
+
+[[package]]
+name = "windows-implement"
+version = "0.60.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
+]
+
+[[package]]
+name = "windows-interface"
+version = "0.59.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9"
+checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
 dependencies = [
- "windows-targets",
+ "proc-macro2",
+ "quote",
+ "syn 2.0.100",
 ]
 
 [[package]]
@@ -2004,6 +2046,24 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "76840935b766e1b0a05c0066835fb9ec80071d4c09a16f6bd5f7e655e3c14c38"
 
+[[package]]
+name = "windows-result"
+version = "0.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c64fd11a4fd95df68efcfee5f44a294fe71b8bc6a91993e2791938abcc712252"
+dependencies = [
+ "windows-link",
+]
+
+[[package]]
+name = "windows-strings"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7a2ba9642430ee452d5a7aa78d72907ebe8cfda358e8cb7918a2050581322f97"
+dependencies = [
+ "windows-link",
+]
+
 [[package]]
 name = "windows-sys"
 version = "0.59.0"
@@ -2079,9 +2139,9 @@
 
 [[package]]
 name = "winnow"
-version = "0.7.4"
+version = "0.7.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0e97b544156e9bebe1a0ffbc03484fc1ffe3100cbce3ffb17eac35f7cdd7ab36"
+checksum = "6cb8234a863ea0e8cd7284fcdd4f145233eb00fee02bbdd9861aec44e6477bc5"
 dependencies = [
  "memchr",
 ]
@@ -2199,19 +2259,3 @@
  "quote",
  "syn 2.0.100",
 ]
-
-[[patch.unused]]
-name = "axfs_devfs"
-version = "0.1.0"
-
-[[patch.unused]]
-name = "axfs_ramfs"
-version = "0.1.0"
-
-[[patch.unused]]
-name = "axfs_vfs"
-version = "0.1.0"
-
-[[patch.unused]]
-name = "lwext4_rust"
-version = "0.2.0"
