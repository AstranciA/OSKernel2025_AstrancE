use std::{
    io::Write,
    env,
    fs::File,
    hash::{DefaultHasher, Hash, Hasher},
    path::{Path, PathBuf},
};

use utils::convert_base;

#[cfg(test)]
mod test;

mod utils;
#[derive(Clone, Copy)]
struct BatConfig {
    skip_if_not_exists: bool,
    hash: bool,
}

impl Default for BatConfig {
    fn default() -> Self {
        Self {
            skip_if_not_exists: false,
            hash: true,
        }
    }
}
#[derive(Clone)]
pub struct BatBuilder {
    apps: Vec<AppInfo>,
    config: BatConfig,
}

impl Default for BatBuilder {
    fn default() -> Self {
        Self {
            apps: Vec::new(),
            config: BatConfig {
                skip_if_not_exists: false,
                hash: true,
            },
        }
    }
}
impl BatBuilder {
    // TODO: better error handling
    // TODO: elf file check
    /// add an ELF file to the builder
    pub fn add_elf(&mut self, elf_file: impl AsRef<Path>) -> &mut Self {
        let app_id = self.apps.len();
        let path = elf_file.as_ref();

        if !self.config.skip_if_not_exists && !path.exists() {
            panic!("ELF file not found: {:?}", path);
        }
        let path_name = path
            .to_str()
            .ok_or_else(|| {
                std::io::Error::new(std::io::ErrorKind::InvalidInput, "Invalid ELF file path")
            })
            .unwrap();
        let name_no_ext = path
            .file_stem()
            .ok_or_else(|| {
                std::io::Error::new(std::io::ErrorKind::InvalidInput, "Invalid ELF file path")
            })
            .unwrap()
            .to_str()
            .ok_or_else(|| {
                std::io::Error::new(std::io::ErrorKind::InvalidInput, "Non-UTF8 filename")
            })
            .unwrap();

        let app_info = AppInfo {
            app_idx: app_id,
            app_name: name_no_ext.into(),
            app_path: path_name.into(),
        };
        self.apps.push(app_info);
        self
    }
    pub fn add_elfs(&mut self, elf_files: &[impl AsRef<Path>]) -> &mut Self {
        for elf_file in elf_files {
            self.add_elf(elf_file);
        }
        self
    }
    pub fn from_elfs(elf_files: &[impl AsRef<Path>]) -> Self {
        let mut builder = Self::default();
        builder.add_elfs(elf_files);
        builder
    }

    /** Generate a linker script for the given ELF files.
     *  Linker format reference: [https://github.com/rcore-os/rCore-Tutorial-v3]
     */
    // TODO: support other architectures
    //#[cfg(any(target_arch = "riscv64", target_arch = "riscv32"))]
    pub fn generate_link_script(&self, output_path: impl AsRef<Path>) {
        let output_path = output_path.as_ref();

        let mut f = File::create(output_path).unwrap();

        let apps = &self.apps;

        // application metadata
        writeln!(
            f,
            r#"// this file is auto generated by acbat
.align 8
    .section .data
    .global _num_app
_num_app:
    .quad {}"#,
            apps.len()
        )
        .unwrap();

        // 生成应用入口指针数组
        for app in apps {
            writeln!(f, r#"    .quad {}_start"#, app.app_id(self.config.hash)).unwrap();
        }
        writeln!(f, r#"    .quad {}_end"#, apps.last().unwrap().app_id(self.config.hash)).unwrap();

        // 为每个文件生成引用代码
        for app in apps {
            let app_id = app.app_id(self.config.hash);
            let app_name = &app.app_name;
            let app_path = &app.app_path;
            let app_path = convert_base(
                app_path.as_path(),
                Path::new("./"),
                //env::current_dir().unwrap().as_path(),
                output_path.parent().unwrap(),
            )
            .unwrap();
            println!("Linking {}: {} ({:?})", app_id, app_name, app_path);
            writeln!(
                f,
                r#"
    .section .data
    .global {0}_start
    .global {0}_end
{0}_start:
    .incbin "{1}"
{0}_end:"#,
                app_id,
                app_path.into_os_string().into_string().unwrap()
            )
            .unwrap();
        }
    }

    pub fn skip_if_not_exists(&mut self, skip: bool) -> &mut Self {
        self.config.skip_if_not_exists = skip;
        self
    }
    pub fn with_hash(&mut self, with_hash: bool) -> &mut Self {
        self.config.hash = with_hash;
        self
    }
}

#[derive(Clone, Hash)]
struct AppInfo {
    app_idx: usize,
    app_name: String,
    app_path: PathBuf,
}

impl AppInfo {
    fn app_id(&self, hash: bool) -> String {
        if hash {
            format!(
                "app_{:02}{:08x}",
                self.app_idx,
                (calculate_hash(self) >> 32) as u32
            )
        } else {
            format!("app_{:02}", self.app_idx)
        }
    }
}
fn calculate_hash<T: Hash>(t: &T) -> u64 {
    let mut s = DefaultHasher::new();
    t.hash(&mut s);
    s.finish()
}
